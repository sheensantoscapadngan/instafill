{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFStream from \"../objects/PDFStream\";\nimport PDFCrossRefStream from \"../structures/PDFCrossRefStream\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport PDFWriter from \"./PDFWriter\";\nimport { last, waitForTick } from \"../../utils\";\n\nvar PDFStreamWriter =\n/** @class */\nfunction (_super) {\n  __extends(PDFStreamWriter, _super);\n\n  function PDFStreamWriter(context, objectsPerTick, encodeStreams, objectsPerStream) {\n    var _this = _super.call(this, context, objectsPerTick) || this;\n\n    _this.encodeStreams = encodeStreams;\n    _this.objectsPerStream = objectsPerStream;\n    return _this;\n  }\n\n  PDFStreamWriter.prototype.computeBufferSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            objectNumber = this.context.largestObjectNumber + 1;\n            header = PDFHeader.forVersion(1, 7);\n            size = header.sizeInBytes() + 2;\n            xrefStream = PDFCrossRefStream.create(this.createTrailerDict(), this.encodeStreams);\n            uncompressedObjects = [];\n            compressedObjects = [];\n            objectStreamRefs = [];\n            indirectObjects = this.context.enumerateIndirectObjects();\n            idx = 0, len = indirectObjects.length;\n            _a.label = 1;\n\n          case 1:\n            if (!(idx < len)) return [3\n            /*break*/\n            , 6];\n            indirectObject = indirectObjects[idx];\n            ref = indirectObject[0], object = indirectObject[1];\n            shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object instanceof PDFStream || object instanceof PDFInvalidObject || ref.generationNumber !== 0;\n            if (!shouldNotCompress) return [3\n            /*break*/\n            , 4];\n            uncompressedObjects.push(indirectObject);\n            xrefStream.addUncompressedEntry(ref, size);\n            size += this.computeIndirectObjectSize(indirectObject);\n            if (!this.shouldWaitForTick(1)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , waitForTick()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            chunk = last(compressedObjects);\n            objectStreamRef = last(objectStreamRefs);\n\n            if (!chunk || chunk.length % this.objectsPerStream === 0) {\n              chunk = [];\n              compressedObjects.push(chunk);\n              objectStreamRef = PDFRef.of(objectNumber++);\n              objectStreamRefs.push(objectStreamRef);\n            }\n\n            xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);\n            chunk.push(indirectObject);\n            _a.label = 5;\n\n          case 5:\n            idx++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 6:\n            idx = 0, len = compressedObjects.length;\n            _a.label = 7;\n\n          case 7:\n            if (!(idx < len)) return [3\n            /*break*/\n            , 10];\n            chunk = compressedObjects[idx];\n            ref = objectStreamRefs[idx];\n            objectStream = PDFObjectStream.withContextAndObjects(this.context, chunk, this.encodeStreams);\n            xrefStream.addUncompressedEntry(ref, size);\n            size += this.computeIndirectObjectSize([ref, objectStream]);\n            uncompressedObjects.push([ref, objectStream]);\n            if (!this.shouldWaitForTick(chunk.length)) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , waitForTick()];\n\n          case 8:\n            _a.sent();\n\n            _a.label = 9;\n\n          case 9:\n            idx++;\n            return [3\n            /*break*/\n            , 7];\n\n          case 10:\n            xrefStreamRef = PDFRef.of(objectNumber++);\n            xrefStream.dict.set(PDFName.of('Size'), PDFNumber.of(objectNumber));\n            xrefStream.addUncompressedEntry(xrefStreamRef, size);\n            xrefOffset = size;\n            size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);\n            uncompressedObjects.push([xrefStreamRef, xrefStream]);\n            trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n            size += trailer.sizeInBytes();\n            return [2\n            /*return*/\n            , {\n              size: size,\n              header: header,\n              indirectObjects: uncompressedObjects,\n              trailer: trailer\n            }];\n        }\n      });\n    });\n  };\n\n  PDFStreamWriter.forContext = function (context, objectsPerTick, encodeStreams, objectsPerStream) {\n    if (encodeStreams === void 0) {\n      encodeStreams = true;\n    }\n\n    if (objectsPerStream === void 0) {\n      objectsPerStream = 50;\n    }\n\n    return new PDFStreamWriter(context, objectsPerTick, encodeStreams, objectsPerStream);\n  };\n\n  return PDFStreamWriter;\n}(PDFWriter);\n\nexport default PDFStreamWriter;","map":{"version":3,"sources":["../../../src/core/writers/PDFStreamWriter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFStream from \"../objects/PDFStream\";\nimport PDFCrossRefStream from \"../structures/PDFCrossRefStream\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport PDFWriter from \"./PDFWriter\";\nimport { last, waitForTick } from \"../../utils\";\nvar PDFStreamWriter = /** @class */ (function (_super) {\n    __extends(PDFStreamWriter, _super);\n    function PDFStreamWriter(context, objectsPerTick, encodeStreams, objectsPerStream) {\n        var _this = _super.call(this, context, objectsPerTick) || this;\n        _this.encodeStreams = encodeStreams;\n        _this.objectsPerStream = objectsPerStream;\n        return _this;\n    }\n    PDFStreamWriter.prototype.computeBufferSize = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        objectNumber = this.context.largestObjectNumber + 1;\n                        header = PDFHeader.forVersion(1, 7);\n                        size = header.sizeInBytes() + 2;\n                        xrefStream = PDFCrossRefStream.create(this.createTrailerDict(), this.encodeStreams);\n                        uncompressedObjects = [];\n                        compressedObjects = [];\n                        objectStreamRefs = [];\n                        indirectObjects = this.context.enumerateIndirectObjects();\n                        idx = 0, len = indirectObjects.length;\n                        _a.label = 1;\n                    case 1:\n                        if (!(idx < len)) return [3 /*break*/, 6];\n                        indirectObject = indirectObjects[idx];\n                        ref = indirectObject[0], object = indirectObject[1];\n                        shouldNotCompress = ref === this.context.trailerInfo.Encrypt ||\n                            object instanceof PDFStream ||\n                            object instanceof PDFInvalidObject ||\n                            ref.generationNumber !== 0;\n                        if (!shouldNotCompress) return [3 /*break*/, 4];\n                        uncompressedObjects.push(indirectObject);\n                        xrefStream.addUncompressedEntry(ref, size);\n                        size += this.computeIndirectObjectSize(indirectObject);\n                        if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, waitForTick()];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [3 /*break*/, 5];\n                    case 4:\n                        chunk = last(compressedObjects);\n                        objectStreamRef = last(objectStreamRefs);\n                        if (!chunk || chunk.length % this.objectsPerStream === 0) {\n                            chunk = [];\n                            compressedObjects.push(chunk);\n                            objectStreamRef = PDFRef.of(objectNumber++);\n                            objectStreamRefs.push(objectStreamRef);\n                        }\n                        xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);\n                        chunk.push(indirectObject);\n                        _a.label = 5;\n                    case 5:\n                        idx++;\n                        return [3 /*break*/, 1];\n                    case 6:\n                        idx = 0, len = compressedObjects.length;\n                        _a.label = 7;\n                    case 7:\n                        if (!(idx < len)) return [3 /*break*/, 10];\n                        chunk = compressedObjects[idx];\n                        ref = objectStreamRefs[idx];\n                        objectStream = PDFObjectStream.withContextAndObjects(this.context, chunk, this.encodeStreams);\n                        xrefStream.addUncompressedEntry(ref, size);\n                        size += this.computeIndirectObjectSize([ref, objectStream]);\n                        uncompressedObjects.push([ref, objectStream]);\n                        if (!this.shouldWaitForTick(chunk.length)) return [3 /*break*/, 9];\n                        return [4 /*yield*/, waitForTick()];\n                    case 8:\n                        _a.sent();\n                        _a.label = 9;\n                    case 9:\n                        idx++;\n                        return [3 /*break*/, 7];\n                    case 10:\n                        xrefStreamRef = PDFRef.of(objectNumber++);\n                        xrefStream.dict.set(PDFName.of('Size'), PDFNumber.of(objectNumber));\n                        xrefStream.addUncompressedEntry(xrefStreamRef, size);\n                        xrefOffset = size;\n                        size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);\n                        uncompressedObjects.push([xrefStreamRef, xrefStream]);\n                        trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n                        size += trailer.sizeInBytes();\n                        return [2 /*return*/, { size: size, header: header, indirectObjects: uncompressedObjects, trailer: trailer }];\n                }\n            });\n        });\n    };\n    PDFStreamWriter.forContext = function (context, objectsPerTick, encodeStreams, objectsPerStream) {\n        if (encodeStreams === void 0) { encodeStreams = true; }\n        if (objectsPerStream === void 0) { objectsPerStream = 50; }\n        return new PDFStreamWriter(context, objectsPerTick, encodeStreams, objectsPerStream);\n    };\n    return PDFStreamWriter;\n}(PDFWriter));\nexport default PDFStreamWriter;\n//# sourceMappingURL=PDFStreamWriter.js.map"]},"metadata":{},"sourceType":"module"}