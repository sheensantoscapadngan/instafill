{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PrivateConstructorError } from \"../errors\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsIrregular } from \"../syntax/Irregular\";\nimport { charFromHexCode, copyStringIntoBuffer, toCharCode, toHexString } from \"../../utils\";\n\nvar decodeName = function (name) {\n  return name.replace(/#([\\dABCDEF]{2})/g, function (_, hex) {\n    return charFromHexCode(hex);\n  });\n};\n\nvar isRegularChar = function (charCode) {\n  return charCode >= CharCodes.ExclamationPoint && charCode <= CharCodes.Tilde && !IsIrregular[charCode];\n};\n\nvar ENFORCER = {};\nvar pool = new Map();\n\nvar PDFName =\n/** @class */\nfunction (_super) {\n  __extends(PDFName, _super);\n\n  function PDFName(enforcer, name) {\n    var _this = this;\n\n    if (enforcer !== ENFORCER) throw new PrivateConstructorError('PDFName');\n    _this = _super.call(this) || this;\n    var encodedName = '/';\n\n    for (var idx = 0, len = name.length; idx < len; idx++) {\n      var character = name[idx];\n      var code = toCharCode(character);\n      encodedName += isRegularChar(code) ? character : \"#\" + toHexString(code);\n    }\n\n    _this.encodedName = encodedName;\n    return _this;\n  }\n\n  PDFName.prototype.asBytes = function () {\n    var bytes = [];\n    var hex = '';\n    var escaped = false;\n\n    var pushByte = function (byte) {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n\n    for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {\n      var char = this.encodedName[idx];\n      var byte = toCharCode(char);\n      var nextChar = this.encodedName[idx + 1];\n\n      if (!escaped) {\n        if (byte === CharCodes.Hash) escaped = true;else pushByte(byte);\n      } else {\n        if (byte >= CharCodes.Zero && byte <= CharCodes.Nine || byte >= CharCodes.a && byte <= CharCodes.f || byte >= CharCodes.A && byte <= CharCodes.F) {\n          hex += char;\n\n          if (hex.length === 2 || !(nextChar >= '0' && nextChar <= '9' || nextChar >= 'a' && nextChar <= 'f' || nextChar >= 'A' && nextChar <= 'F')) {\n            pushByte(parseInt(hex, 16));\n            hex = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n\n    return new Uint8Array(bytes);\n  }; // TODO: This should probably use `utf8Decode()`\n  // TODO: Polyfill Array.from?\n\n\n  PDFName.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    return String.fromCharCode.apply(String, Array.from(bytes));\n  };\n\n  PDFName.prototype.asString = function () {\n    return this.encodedName;\n  };\n  /** @deprecated in favor of [[PDFName.asString]] */\n\n\n  PDFName.prototype.value = function () {\n    return this.encodedName;\n  };\n\n  PDFName.prototype.clone = function () {\n    return this;\n  };\n\n  PDFName.prototype.toString = function () {\n    return this.encodedName;\n  };\n\n  PDFName.prototype.sizeInBytes = function () {\n    return this.encodedName.length;\n  };\n\n  PDFName.prototype.copyBytesInto = function (buffer, offset) {\n    offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\n    return this.encodedName.length;\n  };\n\n  PDFName.of = function (name) {\n    var decodedValue = decodeName(name);\n    var instance = pool.get(decodedValue);\n\n    if (!instance) {\n      instance = new PDFName(ENFORCER, decodedValue);\n      pool.set(decodedValue, instance);\n    }\n\n    return instance;\n  };\n  /* tslint:disable member-ordering */\n\n\n  PDFName.Length = PDFName.of('Length');\n  PDFName.FlateDecode = PDFName.of('FlateDecode');\n  PDFName.Resources = PDFName.of('Resources');\n  PDFName.Font = PDFName.of('Font');\n  PDFName.XObject = PDFName.of('XObject');\n  PDFName.ExtGState = PDFName.of('ExtGState');\n  PDFName.Contents = PDFName.of('Contents');\n  PDFName.Type = PDFName.of('Type');\n  PDFName.Parent = PDFName.of('Parent');\n  PDFName.MediaBox = PDFName.of('MediaBox');\n  PDFName.Page = PDFName.of('Page');\n  PDFName.Annots = PDFName.of('Annots');\n  PDFName.TrimBox = PDFName.of('TrimBox');\n  PDFName.ArtBox = PDFName.of('ArtBox');\n  PDFName.BleedBox = PDFName.of('BleedBox');\n  PDFName.CropBox = PDFName.of('CropBox');\n  PDFName.Rotate = PDFName.of('Rotate');\n  PDFName.Title = PDFName.of('Title');\n  PDFName.Author = PDFName.of('Author');\n  PDFName.Subject = PDFName.of('Subject');\n  PDFName.Creator = PDFName.of('Creator');\n  PDFName.Keywords = PDFName.of('Keywords');\n  PDFName.Producer = PDFName.of('Producer');\n  PDFName.CreationDate = PDFName.of('CreationDate');\n  PDFName.ModDate = PDFName.of('ModDate');\n  return PDFName;\n}(PDFObject);\n\nexport default PDFName;","map":{"version":3,"sources":["../../../src/core/objects/PDFName.ts"],"names":[],"mappings":";AAAA,SAAS,uBAAT,QAAkC,WAAlC;AACA,OAAO,SAAP,MAAgB,aAAhB;AACA,OAAO,SAAP,MAAgB,qBAAhB;AACA,SAAS,WAAT,QAAsB,qBAAtB;AACA,SACE,eADF,EAEE,oBAFF,EAGE,UAHF,EAIE,WAJF,QAKC,aALD;;AAOA,IAAM,UAAU,GAAG,UAAC,IAAD,EAAa;AAC9B,SAAA,IAAI,CAAC,OAAL,CAAa,mBAAb,EAAkC,UAAC,CAAD,EAAI,GAAJ,EAAO;AAAK,WAAA,eAAe,CAAf,GAAe,CAAf;AAAoB,GAAlE,CAAA;AAAmE,CADrE;;AAGA,IAAM,aAAa,GAAG,UAAC,QAAD,EAAiB;AACrC,SAAA,QAAQ,IAAI,SAAS,CAAC,gBAAtB,IACA,QAAQ,IAAI,SAAS,CAAC,KADtB,IAEA,CAAC,WAAW,CAAC,QAAD,CAFZ;AAEsB,CAHxB;;AAKA,IAAM,QAAQ,GAAG,EAAjB;AACA,IAAM,IAAI,GAAG,IAAI,GAAJ,EAAb;;AAEA,IAAA,OAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAsB,EAAA,SAAA,CAAA,OAAA,EAAA,MAAA,CAAA;;AA2CpB,WAAA,OAAA,CAAoB,QAApB,EAAmC,IAAnC,EAA+C;AAA/C,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,QAAQ,KAAK,QAAjB,EAA2B,MAAM,IAAI,uBAAJ,CAA4B,SAA5B,CAAN;AAC3B,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IAAP;AAEA,QAAI,WAAW,GAAG,GAAlB;;AACA,SAAK,IAAI,GAAG,GAAG,CAAV,EAAa,GAAG,GAAG,IAAI,CAAC,MAA7B,EAAqC,GAAG,GAAG,GAA3C,EAAgD,GAAG,EAAnD,EAAuD;AACrD,UAAM,SAAS,GAAG,IAAI,CAAC,GAAD,CAAtB;AACA,UAAM,IAAI,GAAG,UAAU,CAAC,SAAD,CAAvB;AACA,MAAA,WAAW,IAAI,aAAa,CAAC,IAAD,CAAb,GAAsB,SAAtB,GAAkC,MAAI,WAAW,CAAC,IAAD,CAAhE;AACD;;AAED,IAAA,KAAI,CAAC,WAAL,GAAmB,WAAnB;;AACD;;AAED,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,QAAM,KAAK,GAAa,EAAxB;AAEA,QAAI,GAAG,GAAG,EAAV;AACA,QAAI,OAAO,GAAG,KAAd;;AAEA,QAAM,QAAQ,GAAG,UAAC,IAAD,EAAc;AAC7B,UAAI,IAAI,KAAK,SAAb,EAAwB,KAAK,CAAC,IAAN,CAAW,IAAX;AACxB,MAAA,OAAO,GAAG,KAAV;AACD,KAHD;;AAKA,SAAK,IAAI,GAAG,GAAG,CAAV,EAAa,GAAG,GAAG,KAAK,WAAL,CAAiB,MAAzC,EAAiD,GAAG,GAAG,GAAvD,EAA4D,GAAG,EAA/D,EAAmE;AACjE,UAAM,IAAI,GAAG,KAAK,WAAL,CAAiB,GAAjB,CAAb;AACA,UAAM,IAAI,GAAG,UAAU,CAAC,IAAD,CAAvB;AACA,UAAM,QAAQ,GAAG,KAAK,WAAL,CAAiB,GAAG,GAAG,CAAvB,CAAjB;;AACA,UAAI,CAAC,OAAL,EAAc;AACZ,YAAI,IAAI,KAAK,SAAS,CAAC,IAAvB,EAA6B,OAAO,GAAG,IAAV,CAA7B,KACK,QAAQ,CAAC,IAAD,CAAR;AACN,OAHD,MAGO;AACL,YACG,IAAI,IAAI,SAAS,CAAC,IAAlB,IAA0B,IAAI,IAAI,SAAS,CAAC,IAA7C,IACC,IAAI,IAAI,SAAS,CAAC,CAAlB,IAAuB,IAAI,IAAI,SAAS,CAAC,CAD1C,IAEC,IAAI,IAAI,SAAS,CAAC,CAAlB,IAAuB,IAAI,IAAI,SAAS,CAAC,CAH5C,EAIE;AACA,UAAA,GAAG,IAAI,IAAP;;AACA,cACE,GAAG,CAAC,MAAJ,KAAe,CAAf,IACA,EACG,QAAQ,IAAI,GAAZ,IAAmB,QAAQ,IAAI,GAAhC,IACC,QAAQ,IAAI,GAAZ,IAAmB,QAAQ,IAAI,GADhC,IAEC,QAAQ,IAAI,GAAZ,IAAmB,QAAQ,IAAI,GAHlC,CAFF,EAOE;AACA,YAAA,QAAQ,CAAC,QAAQ,CAAC,GAAD,EAAM,EAAN,CAAT,CAAR;AACA,YAAA,GAAG,GAAG,EAAN;AACD;AACF,SAjBD,MAiBO;AACL,UAAA,QAAQ,CAAC,IAAD,CAAR;AACD;AACF;AACF;;AAED,WAAO,IAAI,UAAJ,CAAe,KAAf,CAAP;AACD,GA3CD,CAzDF,CAsGE;AACA;;;AACA,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,QAAM,KAAK,GAAG,KAAK,OAAL,EAAd;AACA,WAAO,MAAM,CAAC,YAAP,CAAmB,KAAnB,CAAA,MAAA,EAAuB,KAAK,CAAC,IAAN,CAAW,KAAX,CAAvB,CAAP;AACD,GAHD;;AAKA,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,KAAK,WAAZ;AACD,GAFD;AAIA;;;AACA,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,WAAO,KAAK,WAAZ;AACD,GAFD;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,WAAO,IAAP;AACD,GAFD;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,WAAO,KAAK,WAAZ;AACD,GAFD;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,WAAO,KAAK,WAAL,CAAiB,MAAxB;AACD,GAFD;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,MAAd,EAAkC,MAAlC,EAAgD;AAC9C,IAAA,MAAM,IAAI,oBAAoB,CAAC,KAAK,WAAN,EAAmB,MAAnB,EAA2B,MAA3B,CAA9B;AACA,WAAO,KAAK,WAAL,CAAiB,MAAxB;AACD,GAHD;;AAjIO,EAAA,OAAA,CAAA,EAAA,GAAK,UAAC,IAAD,EAAa;AACvB,QAAM,YAAY,GAAG,UAAU,CAAC,IAAD,CAA/B;AAEA,QAAI,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,YAAT,CAAf;;AACA,QAAI,CAAC,QAAL,EAAe;AACb,MAAA,QAAQ,GAAG,IAAI,OAAJ,CAAY,QAAZ,EAAsB,YAAtB,CAAX;AACA,MAAA,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,QAAvB;AACD;;AAED,WAAO,QAAP;AACD,GAVM;AAYP;;;AACgB,EAAA,OAAA,CAAA,MAAA,GAAS,OAAO,CAAC,EAAR,CAAW,QAAX,CAAT;AACA,EAAA,OAAA,CAAA,WAAA,GAAc,OAAO,CAAC,EAAR,CAAW,aAAX,CAAd;AACA,EAAA,OAAA,CAAA,SAAA,GAAY,OAAO,CAAC,EAAR,CAAW,WAAX,CAAZ;AACA,EAAA,OAAA,CAAA,IAAA,GAAO,OAAO,CAAC,EAAR,CAAW,MAAX,CAAP;AACA,EAAA,OAAA,CAAA,OAAA,GAAU,OAAO,CAAC,EAAR,CAAW,SAAX,CAAV;AACA,EAAA,OAAA,CAAA,SAAA,GAAY,OAAO,CAAC,EAAR,CAAW,WAAX,CAAZ;AACA,EAAA,OAAA,CAAA,QAAA,GAAW,OAAO,CAAC,EAAR,CAAW,UAAX,CAAX;AACA,EAAA,OAAA,CAAA,IAAA,GAAO,OAAO,CAAC,EAAR,CAAW,MAAX,CAAP;AACA,EAAA,OAAA,CAAA,MAAA,GAAS,OAAO,CAAC,EAAR,CAAW,QAAX,CAAT;AACA,EAAA,OAAA,CAAA,QAAA,GAAW,OAAO,CAAC,EAAR,CAAW,UAAX,CAAX;AACA,EAAA,OAAA,CAAA,IAAA,GAAO,OAAO,CAAC,EAAR,CAAW,MAAX,CAAP;AACA,EAAA,OAAA,CAAA,MAAA,GAAS,OAAO,CAAC,EAAR,CAAW,QAAX,CAAT;AACA,EAAA,OAAA,CAAA,OAAA,GAAU,OAAO,CAAC,EAAR,CAAW,SAAX,CAAV;AACA,EAAA,OAAA,CAAA,MAAA,GAAS,OAAO,CAAC,EAAR,CAAW,QAAX,CAAT;AACA,EAAA,OAAA,CAAA,QAAA,GAAW,OAAO,CAAC,EAAR,CAAW,UAAX,CAAX;AACA,EAAA,OAAA,CAAA,OAAA,GAAU,OAAO,CAAC,EAAR,CAAW,SAAX,CAAV;AACA,EAAA,OAAA,CAAA,MAAA,GAAS,OAAO,CAAC,EAAR,CAAW,QAAX,CAAT;AACA,EAAA,OAAA,CAAA,KAAA,GAAQ,OAAO,CAAC,EAAR,CAAW,OAAX,CAAR;AACA,EAAA,OAAA,CAAA,MAAA,GAAS,OAAO,CAAC,EAAR,CAAW,QAAX,CAAT;AACA,EAAA,OAAA,CAAA,OAAA,GAAU,OAAO,CAAC,EAAR,CAAW,SAAX,CAAV;AACA,EAAA,OAAA,CAAA,OAAA,GAAU,OAAO,CAAC,EAAR,CAAW,SAAX,CAAV;AACA,EAAA,OAAA,CAAA,QAAA,GAAW,OAAO,CAAC,EAAR,CAAW,UAAX,CAAX;AACA,EAAA,OAAA,CAAA,QAAA,GAAW,OAAO,CAAC,EAAR,CAAW,UAAX,CAAX;AACA,EAAA,OAAA,CAAA,YAAA,GAAe,OAAO,CAAC,EAAR,CAAW,cAAX,CAAf;AACA,EAAA,OAAA,CAAA,OAAA,GAAU,OAAO,CAAC,EAAR,CAAW,SAAX,CAAV;AAgGlB,SAAA,OAAA;AAAC,CAtID,CAAsB,SAAtB,CAAA;;AAwIA,eAAe,OAAf","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\r\nimport { PrivateConstructorError } from \"../errors\";\r\nimport PDFObject from \"./PDFObject\";\r\nimport CharCodes from \"../syntax/CharCodes\";\r\nimport { IsIrregular } from \"../syntax/Irregular\";\r\nimport { charFromHexCode, copyStringIntoBuffer, toCharCode, toHexString, } from \"../../utils\";\r\nvar decodeName = function (name) {\r\n    return name.replace(/#([\\dABCDEF]{2})/g, function (_, hex) { return charFromHexCode(hex); });\r\n};\r\nvar isRegularChar = function (charCode) {\r\n    return charCode >= CharCodes.ExclamationPoint &&\r\n        charCode <= CharCodes.Tilde &&\r\n        !IsIrregular[charCode];\r\n};\r\nvar ENFORCER = {};\r\nvar pool = new Map();\r\nvar PDFName = /** @class */ (function (_super) {\r\n    __extends(PDFName, _super);\r\n    function PDFName(enforcer, name) {\r\n        var _this = this;\r\n        if (enforcer !== ENFORCER)\r\n            throw new PrivateConstructorError('PDFName');\r\n        _this = _super.call(this) || this;\r\n        var encodedName = '/';\r\n        for (var idx = 0, len = name.length; idx < len; idx++) {\r\n            var character = name[idx];\r\n            var code = toCharCode(character);\r\n            encodedName += isRegularChar(code) ? character : \"#\" + toHexString(code);\r\n        }\r\n        _this.encodedName = encodedName;\r\n        return _this;\r\n    }\r\n    PDFName.prototype.asBytes = function () {\r\n        var bytes = [];\r\n        var hex = '';\r\n        var escaped = false;\r\n        var pushByte = function (byte) {\r\n            if (byte !== undefined)\r\n                bytes.push(byte);\r\n            escaped = false;\r\n        };\r\n        for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {\r\n            var char = this.encodedName[idx];\r\n            var byte = toCharCode(char);\r\n            var nextChar = this.encodedName[idx + 1];\r\n            if (!escaped) {\r\n                if (byte === CharCodes.Hash)\r\n                    escaped = true;\r\n                else\r\n                    pushByte(byte);\r\n            }\r\n            else {\r\n                if ((byte >= CharCodes.Zero && byte <= CharCodes.Nine) ||\r\n                    (byte >= CharCodes.a && byte <= CharCodes.f) ||\r\n                    (byte >= CharCodes.A && byte <= CharCodes.F)) {\r\n                    hex += char;\r\n                    if (hex.length === 2 ||\r\n                        !((nextChar >= '0' && nextChar <= '9') ||\r\n                            (nextChar >= 'a' && nextChar <= 'f') ||\r\n                            (nextChar >= 'A' && nextChar <= 'F'))) {\r\n                        pushByte(parseInt(hex, 16));\r\n                        hex = '';\r\n                    }\r\n                }\r\n                else {\r\n                    pushByte(byte);\r\n                }\r\n            }\r\n        }\r\n        return new Uint8Array(bytes);\r\n    };\r\n    // TODO: This should probably use `utf8Decode()`\r\n    // TODO: Polyfill Array.from?\r\n    PDFName.prototype.decodeText = function () {\r\n        var bytes = this.asBytes();\r\n        return String.fromCharCode.apply(String, Array.from(bytes));\r\n    };\r\n    PDFName.prototype.asString = function () {\r\n        return this.encodedName;\r\n    };\r\n    /** @deprecated in favor of [[PDFName.asString]] */\r\n    PDFName.prototype.value = function () {\r\n        return this.encodedName;\r\n    };\r\n    PDFName.prototype.clone = function () {\r\n        return this;\r\n    };\r\n    PDFName.prototype.toString = function () {\r\n        return this.encodedName;\r\n    };\r\n    PDFName.prototype.sizeInBytes = function () {\r\n        return this.encodedName.length;\r\n    };\r\n    PDFName.prototype.copyBytesInto = function (buffer, offset) {\r\n        offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\r\n        return this.encodedName.length;\r\n    };\r\n    PDFName.of = function (name) {\r\n        var decodedValue = decodeName(name);\r\n        var instance = pool.get(decodedValue);\r\n        if (!instance) {\r\n            instance = new PDFName(ENFORCER, decodedValue);\r\n            pool.set(decodedValue, instance);\r\n        }\r\n        return instance;\r\n    };\r\n    /* tslint:disable member-ordering */\r\n    PDFName.Length = PDFName.of('Length');\r\n    PDFName.FlateDecode = PDFName.of('FlateDecode');\r\n    PDFName.Resources = PDFName.of('Resources');\r\n    PDFName.Font = PDFName.of('Font');\r\n    PDFName.XObject = PDFName.of('XObject');\r\n    PDFName.ExtGState = PDFName.of('ExtGState');\r\n    PDFName.Contents = PDFName.of('Contents');\r\n    PDFName.Type = PDFName.of('Type');\r\n    PDFName.Parent = PDFName.of('Parent');\r\n    PDFName.MediaBox = PDFName.of('MediaBox');\r\n    PDFName.Page = PDFName.of('Page');\r\n    PDFName.Annots = PDFName.of('Annots');\r\n    PDFName.TrimBox = PDFName.of('TrimBox');\r\n    PDFName.ArtBox = PDFName.of('ArtBox');\r\n    PDFName.BleedBox = PDFName.of('BleedBox');\r\n    PDFName.CropBox = PDFName.of('CropBox');\r\n    PDFName.Rotate = PDFName.of('Rotate');\r\n    PDFName.Title = PDFName.of('Title');\r\n    PDFName.Author = PDFName.of('Author');\r\n    PDFName.Subject = PDFName.of('Subject');\r\n    PDFName.Creator = PDFName.of('Creator');\r\n    PDFName.Keywords = PDFName.of('Keywords');\r\n    PDFName.Producer = PDFName.of('Producer');\r\n    PDFName.CreationDate = PDFName.of('CreationDate');\r\n    PDFName.ModDate = PDFName.of('ModDate');\r\n    return PDFName;\r\n}(PDFObject));\r\nexport default PDFName;\r\n//# sourceMappingURL=PDFName.js.map"]},"metadata":{},"sourceType":"module"}