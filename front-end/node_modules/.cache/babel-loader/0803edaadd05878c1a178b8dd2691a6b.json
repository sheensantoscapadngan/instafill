{"ast":null,"code":"import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\n\nvar PDFObjectCopier =\n/** @class */\nfunction () {\n  function PDFObjectCopier(src, dest) {\n    var _this = this;\n\n    this.traversedObjects = new Map(); // prettier-ignore\n\n    this.copy = function (object) {\n      return object instanceof PDFPageLeaf ? _this.copyPDFPage(object) : object instanceof PDFDict ? _this.copyPDFDict(object) : object instanceof PDFArray ? _this.copyPDFArray(object) : object instanceof PDFStream ? _this.copyPDFStream(object) : object instanceof PDFRef ? _this.copyPDFIndirectObject(object) : object.clone();\n    };\n\n    this.copyPDFPage = function (originalPage) {\n      var clonedPage = originalPage.clone(); // Move any entries that the originalPage is inheriting from its parent\n      // tree nodes directly into originalPage so they are preserved during\n      // the copy.\n\n      var InheritableEntries = PDFPageLeaf.InheritableEntries;\n\n      for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n        var key = PDFName.of(InheritableEntries[idx]);\n        var value = clonedPage.getInheritableAttribute(key);\n        if (!clonedPage.get(key) && value) clonedPage.set(key, value);\n      } // Remove the parent reference to prevent the whole donor document's page\n      // tree from being copied when we only need a single page.\n\n\n      clonedPage.delete(PDFName.of('Parent'));\n      return _this.copyPDFDict(clonedPage);\n    };\n\n    this.copyPDFDict = function (originalDict) {\n      if (_this.traversedObjects.has(originalDict)) {\n        return _this.traversedObjects.get(originalDict);\n      }\n\n      var clonedDict = originalDict.clone(_this.dest);\n\n      _this.traversedObjects.set(originalDict, clonedDict);\n\n      var entries = originalDict.entries();\n\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n            key = _a[0],\n            value = _a[1];\n        clonedDict.set(key, _this.copy(value));\n      }\n\n      return clonedDict;\n    };\n\n    this.copyPDFArray = function (originalArray) {\n      if (_this.traversedObjects.has(originalArray)) {\n        return _this.traversedObjects.get(originalArray);\n      }\n\n      var clonedArray = originalArray.clone(_this.dest);\n\n      _this.traversedObjects.set(originalArray, clonedArray);\n\n      for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n        var value = originalArray.get(idx);\n        clonedArray.set(idx, _this.copy(value));\n      }\n\n      return clonedArray;\n    };\n\n    this.copyPDFStream = function (originalStream) {\n      if (_this.traversedObjects.has(originalStream)) {\n        return _this.traversedObjects.get(originalStream);\n      }\n\n      var clonedStream = originalStream.clone(_this.dest);\n\n      _this.traversedObjects.set(originalStream, clonedStream);\n\n      var entries = originalStream.dict.entries();\n\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n            key = _a[0],\n            value = _a[1];\n        clonedStream.dict.set(key, _this.copy(value));\n      }\n\n      return clonedStream;\n    };\n\n    this.copyPDFIndirectObject = function (ref) {\n      var alreadyMapped = _this.traversedObjects.has(ref);\n\n      if (!alreadyMapped) {\n        var newRef = _this.dest.nextRef();\n\n        _this.traversedObjects.set(ref, newRef);\n\n        var dereferencedValue = _this.src.lookup(ref);\n\n        if (dereferencedValue) {\n          var cloned = _this.copy(dereferencedValue);\n\n          _this.dest.assign(newRef, cloned);\n        }\n      }\n\n      return _this.traversedObjects.get(ref);\n    };\n\n    this.src = src;\n    this.dest = dest;\n  }\n\n  PDFObjectCopier.for = function (src, dest) {\n    return new PDFObjectCopier(src, dest);\n  };\n\n  return PDFObjectCopier;\n}();\n\nexport default PDFObjectCopier;","map":{"version":3,"sources":["../../src/core/PDFObjectCopier.ts"],"names":[],"mappings":"AAAA,OAAO,QAAP,MAAe,oBAAf;AACA,OAAO,OAAP,MAAc,mBAAd;AACA,OAAO,OAAP,MAAc,mBAAd;AAEA,OAAO,MAAP,MAAa,kBAAb;AACA,OAAO,SAAP,MAAgB,qBAAhB;AAEA,OAAO,WAAP,MAAkB,0BAAlB;AAEA;;;;;;;;;;;;;;;;;;;;AAoBG;;AACH,IAAA,eAAA;AAAA;AAAA,YAAA;AAQE,WAAA,eAAA,CAAoB,GAApB,EAAqC,IAArC,EAAqD;AAArD,QAAA,KAAA,GAAA,IAAA;;AAFiB,SAAA,gBAAA,GAAmB,IAAI,GAAJ,EAAnB,CAEoC,CAKrD;;AACA,SAAA,IAAA,GAAO,UAAsB,MAAtB,EAA+B;AAAQ,aAC1C,MAAM,YAAY,WAAlB,GAAgC,KAAI,CAAC,WAAL,CAAiB,MAAjB,CAAhC,GACA,MAAM,YAAY,OAAlB,GAAgC,KAAI,CAAC,WAAL,CAAiB,MAAjB,CAAhC,GACA,MAAM,YAAY,QAAlB,GAAgC,KAAI,CAAC,YAAL,CAAkB,MAAlB,CAAhC,GACA,MAAM,YAAY,SAAlB,GAAgC,KAAI,CAAC,aAAL,CAAmB,MAAnB,CAAhC,GACA,MAAM,YAAY,MAAlB,GAAgC,KAAI,CAAC,qBAAL,CAA2B,MAA3B,CAAhC,GACA,MAAM,CANoC,KAM1C,EAN0C;AAOxC,KAPN;;AASQ,SAAA,WAAA,GAAc,UAAC,YAAD,EAA0B;AAC9C,UAAM,UAAU,GAAG,YAAY,CAAC,KAAb,EAAnB,CAD8C,CAG9C;AACA;AACA;;AACQ,UAAA,kBAAkB,GAAK,WAAW,CAAhB,kBAAlB;;AACR,WAAK,IAAI,GAAG,GAAG,CAAV,EAAa,GAAG,GAAG,kBAAkB,CAAC,MAA3C,EAAmD,GAAG,GAAG,GAAzD,EAA8D,GAAG,EAAjE,EAAqE;AACnE,YAAM,GAAG,GAAG,OAAO,CAAC,EAAR,CAAW,kBAAkB,CAAC,GAAD,CAA7B,CAAZ;AACA,YAAM,KAAK,GAAG,UAAU,CAAC,uBAAX,CAAmC,GAAnC,CAAd;AACA,YAAI,CAAC,UAAU,CAAC,GAAX,CAAe,GAAf,CAAD,IAAwB,KAA5B,EAAmC,UAAU,CAAC,GAAX,CAAe,GAAf,EAAoB,KAApB;AACpC,OAX6C,CAa9C;AACA;;;AACA,MAAA,UAAU,CAAC,MAAX,CAAkB,OAAO,CAAC,EAAR,CAAW,QAAX,CAAlB;AAEA,aAAO,KAAI,CAAC,WAAL,CAAiB,UAAjB,CAAP;AACD,KAlBO;;AAoBA,SAAA,WAAA,GAAc,UAAC,YAAD,EAAsB;AAC1C,UAAI,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,YAA1B,CAAJ,EAA6C;AAC3C,eAAO,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,YAA1B,CAAP;AACD;;AAED,UAAM,UAAU,GAAG,YAAY,CAAC,KAAb,CAAmB,KAAI,CAAC,IAAxB,CAAnB;;AACA,MAAA,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,YAA1B,EAAwC,UAAxC;;AAEA,UAAM,OAAO,GAAG,YAAY,CAAC,OAAb,EAAhB;;AAEA,WAAK,IAAI,GAAG,GAAG,CAAV,EAAa,GAAG,GAAG,OAAO,CAAC,MAAhC,EAAwC,GAAG,GAAG,GAA9C,EAAmD,GAAG,EAAtD,EAA0D;AAClD,YAAA,EAAA,GAAe,OAAO,CAAC,GAAD,CAAtB;AAAA,YAAC,GAAG,GAAA,EAAA,CAAA,CAAA,CAAJ;AAAA,YAAM,KAAK,GAAA,EAAA,CAAA,CAAA,CAAX;AACN,QAAA,UAAU,CAAC,GAAX,CAAe,GAAf,EAAoB,KAAI,CAAC,IAAL,CAAU,KAAV,CAApB;AACD;;AAED,aAAO,UAAP;AACD,KAhBO;;AAkBA,SAAA,YAAA,GAAe,UAAC,aAAD,EAAwB;AAC7C,UAAI,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,aAA1B,CAAJ,EAA8C;AAC5C,eAAO,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,aAA1B,CAAP;AACD;;AAED,UAAM,WAAW,GAAG,aAAa,CAAC,KAAd,CAAoB,KAAI,CAAC,IAAzB,CAApB;;AACA,MAAA,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,aAA1B,EAAyC,WAAzC;;AAEA,WAAK,IAAI,GAAG,GAAG,CAAV,EAAa,GAAG,GAAG,aAAa,CAAC,IAAd,EAAxB,EAA8C,GAAG,GAAG,GAApD,EAAyD,GAAG,EAA5D,EAAgE;AAC9D,YAAM,KAAK,GAAG,aAAa,CAAC,GAAd,CAAkB,GAAlB,CAAd;AACA,QAAA,WAAW,CAAC,GAAZ,CAAgB,GAAhB,EAAqB,KAAI,CAAC,IAAL,CAAU,KAAV,CAArB;AACD;;AAED,aAAO,WAAP;AACD,KAdO;;AAgBA,SAAA,aAAA,GAAgB,UAAC,cAAD,EAA0B;AAChD,UAAI,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,cAA1B,CAAJ,EAA+C;AAC7C,eAAO,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,cAA1B,CAAP;AACD;;AAED,UAAM,YAAY,GAAG,cAAc,CAAC,KAAf,CAAqB,KAAI,CAAC,IAA1B,CAArB;;AACA,MAAA,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,cAA1B,EAA0C,YAA1C;;AAEA,UAAM,OAAO,GAAG,cAAc,CAAC,IAAf,CAAoB,OAApB,EAAhB;;AACA,WAAK,IAAI,GAAG,GAAG,CAAV,EAAa,GAAG,GAAG,OAAO,CAAC,MAAhC,EAAwC,GAAG,GAAG,GAA9C,EAAmD,GAAG,EAAtD,EAA0D;AAClD,YAAA,EAAA,GAAe,OAAO,CAAC,GAAD,CAAtB;AAAA,YAAC,GAAG,GAAA,EAAA,CAAA,CAAA,CAAJ;AAAA,YAAM,KAAK,GAAA,EAAA,CAAA,CAAA,CAAX;AACN,QAAA,YAAY,CAAC,IAAb,CAAkB,GAAlB,CAAsB,GAAtB,EAA2B,KAAI,CAAC,IAAL,CAAU,KAAV,CAA3B;AACD;;AAED,aAAO,YAAP;AACD,KAfO;;AAiBA,SAAA,qBAAA,GAAwB,UAAC,GAAD,EAAY;AAC1C,UAAM,aAAa,GAAG,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,GAA1B,CAAtB;;AAEA,UAAI,CAAC,aAAL,EAAoB;AAClB,YAAM,MAAM,GAAG,KAAI,CAAC,IAAL,CAAU,OAAV,EAAf;;AACA,QAAA,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,GAA1B,EAA+B,MAA/B;;AAEA,YAAM,iBAAiB,GAAG,KAAI,CAAC,GAAL,CAAS,MAAT,CAAgB,GAAhB,CAA1B;;AACA,YAAI,iBAAJ,EAAuB;AACrB,cAAM,MAAM,GAAG,KAAI,CAAC,IAAL,CAAU,iBAAV,CAAf;;AACA,UAAA,KAAI,CAAC,IAAL,CAAU,MAAV,CAAiB,MAAjB,EAAyB,MAAzB;AACD;AACF;;AAED,aAAO,KAAI,CAAC,gBAAL,CAAsB,GAAtB,CAA0B,GAA1B,CAAP;AACD,KAfO;;AArFN,SAAK,GAAL,GAAW,GAAX;AACA,SAAK,IAAL,GAAY,IAAZ;AACD;;AAVM,EAAA,eAAA,CAAA,GAAA,GAAM,UAAC,GAAD,EAAkB,IAAlB,EAAkC;AAC7C,WAAA,IAAI,eAAJ,CAAoB,GAApB,EAAyB,IAAzB,CAAA;AAA8B,GADzB;;AA6GT,SAAA,eAAA;AAAC,CA9GD,EAAA;;AAgHA,eAAe,eAAf","sourceRoot":"","sourcesContent":["import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\nvar PDFObjectCopier = /** @class */ (function () {\n    function PDFObjectCopier(src, dest) {\n        var _this = this;\n        this.traversedObjects = new Map();\n        // prettier-ignore\n        this.copy = function (object) { return (object instanceof PDFPageLeaf ? _this.copyPDFPage(object)\n            : object instanceof PDFDict ? _this.copyPDFDict(object)\n                : object instanceof PDFArray ? _this.copyPDFArray(object)\n                    : object instanceof PDFStream ? _this.copyPDFStream(object)\n                        : object instanceof PDFRef ? _this.copyPDFIndirectObject(object)\n                            : object.clone()); };\n        this.copyPDFPage = function (originalPage) {\n            var clonedPage = originalPage.clone();\n            // Move any entries that the originalPage is inheriting from its parent\n            // tree nodes directly into originalPage so they are preserved during\n            // the copy.\n            var InheritableEntries = PDFPageLeaf.InheritableEntries;\n            for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n                var key = PDFName.of(InheritableEntries[idx]);\n                var value = clonedPage.getInheritableAttribute(key);\n                if (!clonedPage.get(key) && value)\n                    clonedPage.set(key, value);\n            }\n            // Remove the parent reference to prevent the whole donor document's page\n            // tree from being copied when we only need a single page.\n            clonedPage.delete(PDFName.of('Parent'));\n            return _this.copyPDFDict(clonedPage);\n        };\n        this.copyPDFDict = function (originalDict) {\n            if (_this.traversedObjects.has(originalDict)) {\n                return _this.traversedObjects.get(originalDict);\n            }\n            var clonedDict = originalDict.clone(_this.dest);\n            _this.traversedObjects.set(originalDict, clonedDict);\n            var entries = originalDict.entries();\n            for (var idx = 0, len = entries.length; idx < len; idx++) {\n                var _a = entries[idx], key = _a[0], value = _a[1];\n                clonedDict.set(key, _this.copy(value));\n            }\n            return clonedDict;\n        };\n        this.copyPDFArray = function (originalArray) {\n            if (_this.traversedObjects.has(originalArray)) {\n                return _this.traversedObjects.get(originalArray);\n            }\n            var clonedArray = originalArray.clone(_this.dest);\n            _this.traversedObjects.set(originalArray, clonedArray);\n            for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n                var value = originalArray.get(idx);\n                clonedArray.set(idx, _this.copy(value));\n            }\n            return clonedArray;\n        };\n        this.copyPDFStream = function (originalStream) {\n            if (_this.traversedObjects.has(originalStream)) {\n                return _this.traversedObjects.get(originalStream);\n            }\n            var clonedStream = originalStream.clone(_this.dest);\n            _this.traversedObjects.set(originalStream, clonedStream);\n            var entries = originalStream.dict.entries();\n            for (var idx = 0, len = entries.length; idx < len; idx++) {\n                var _a = entries[idx], key = _a[0], value = _a[1];\n                clonedStream.dict.set(key, _this.copy(value));\n            }\n            return clonedStream;\n        };\n        this.copyPDFIndirectObject = function (ref) {\n            var alreadyMapped = _this.traversedObjects.has(ref);\n            if (!alreadyMapped) {\n                var newRef = _this.dest.nextRef();\n                _this.traversedObjects.set(ref, newRef);\n                var dereferencedValue = _this.src.lookup(ref);\n                if (dereferencedValue) {\n                    var cloned = _this.copy(dereferencedValue);\n                    _this.dest.assign(newRef, cloned);\n                }\n            }\n            return _this.traversedObjects.get(ref);\n        };\n        this.src = src;\n        this.dest = dest;\n    }\n    PDFObjectCopier.for = function (src, dest) {\n        return new PDFObjectCopier(src, dest);\n    };\n    return PDFObjectCopier;\n}());\nexport default PDFObjectCopier;\n//# sourceMappingURL=PDFObjectCopier.js.map"]},"metadata":{},"sourceType":"module"}