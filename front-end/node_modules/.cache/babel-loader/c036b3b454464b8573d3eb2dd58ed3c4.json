{"ast":null,"code":"import { __assign, __spreadArrays } from \"tslib\";\nimport PDFDocument from \"../PDFDocument\";\nimport { colorToComponents, setFillingColor } from \"../colors\";\nimport { toDegrees, rotateRectangle, reduceRotation, adjustDimsForRotation, degrees } from \"../rotations\";\nimport { PDFRef, PDFWidgetAnnotation, PDFName, MethodNotImplementedError, AcroFieldFlags, PDFAcroTerminal, AnnotationFlags } from \"../../core\";\nimport { addRandomSuffix, assertIs, assertMultiple, assertOrUndefined } from \"../../utils\";\nimport { ImageAlignment } from '../image';\nimport { drawImage, rotateInPlace } from '../operations';\nexport var assertFieldAppearanceOptions = function (options) {\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, 'options.x', ['number']);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, 'options.y', ['number']);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, 'options.width', ['number']);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, 'options.height', ['number']);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, 'options.textColor', [[Object, 'Color']]);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, 'options.backgroundColor', [[Object, 'Color']]);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, 'options.borderColor', [[Object, 'Color']]);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, 'options.borderWidth', ['number']);\n  assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, 'options.rotate', [[Object, 'Rotation']]);\n};\n/**\r\n * Represents a field of a [[PDFForm]].\r\n *\r\n * This class is effectively abstract. All fields in a [[PDFForm]] will\r\n * actually be an instance of a subclass of this class.\r\n *\r\n * Note that each field in a PDF is represented by a single field object.\r\n * However, a given field object may be rendered at multiple locations within\r\n * the document (across one or more pages). The rendering of a field is\r\n * controlled by its widgets. Each widget causes its field to be displayed at a\r\n * particular location in the document.\r\n *\r\n * Most of the time each field in a PDF has only a single widget, and thus is\r\n * only rendered once. However, if a field is rendered multiple times, it will\r\n * have multiple widgets - one for each location it is rendered.\r\n *\r\n * This abstraction of field objects and widgets is defined in the PDF\r\n * specification and dictates how PDF files store fields and where they are\r\n * to be rendered.\r\n */\n\nvar PDFField =\n/** @class */\nfunction () {\n  function PDFField(acroField, ref, doc) {\n    assertIs(acroField, 'acroField', [[PDFAcroTerminal, 'PDFAcroTerminal']]);\n    assertIs(ref, 'ref', [[PDFRef, 'PDFRef']]);\n    assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\n    this.acroField = acroField;\n    this.ref = ref;\n    this.doc = doc;\n  }\n  /**\r\n   * Get the fully qualified name of this field. For example:\r\n   * ```js\r\n   * const fields = form.getFields()\r\n   * fields.forEach(field => {\r\n   *   const name = field.getName()\r\n   *   console.log('Field name:', name)\r\n   * })\r\n   * ```\r\n   * Note that PDF fields are structured as a tree. Each field is the\r\n   * descendent of a series of ancestor nodes all the way up to the form node,\r\n   * which is always the root of the tree. Each node in the tree (except for\r\n   * the form node) has a partial name. Partial names can be composed of any\r\n   * unicode characters except a period (`.`). The fully qualified name of a\r\n   * field is composed of the partial names of all its ancestors joined\r\n   * with periods. This means that splitting the fully qualified name on\r\n   * periods and taking the last element of the resulting array will give you\r\n   * the partial name of a specific field.\r\n   * @returns The fully qualified name of this field.\r\n   */\n\n\n  PDFField.prototype.getName = function () {\n    var _a;\n\n    return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : '';\n  };\n  /**\r\n   * Returns `true` if this field is read only. This means that PDF readers\r\n   * will not allow users to interact with the field or change its value. See\r\n   * [[PDFField.enableReadOnly]] and [[PDFField.disableReadOnly]].\r\n   * For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * if (field.isReadOnly()) console.log('Read only is enabled')\r\n   * ```\r\n   * @returns Whether or not this is a read only field.\r\n   */\n\n\n  PDFField.prototype.isReadOnly = function () {\n    return this.acroField.hasFlag(AcroFieldFlags.ReadOnly);\n  };\n  /**\r\n   * Prevent PDF readers from allowing users to interact with this field or\r\n   * change its value. The field will not respond to mouse or keyboard input.\r\n   * For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * field.enableReadOnly()\r\n   * ```\r\n   * Useful for fields whose values are computed, imported from a database, or\r\n   * prefilled by software before being displayed to the user.\r\n   */\n\n\n  PDFField.prototype.enableReadOnly = function () {\n    this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, true);\n  };\n  /**\r\n   * Allow users to interact with this field and change its value in PDF\r\n   * readers via mouse and keyboard input. For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * field.disableReadOnly()\r\n   * ```\r\n   */\n\n\n  PDFField.prototype.disableReadOnly = function () {\n    this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, false);\n  };\n  /**\r\n   * Returns `true` if this field must have a value when the form is submitted.\r\n   * See [[PDFField.enableRequired]] and [[PDFField.disableRequired]].\r\n   * For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * if (field.isRequired()) console.log('Field is required')\r\n   * ```\r\n   * @returns Whether or not this field is required.\r\n   */\n\n\n  PDFField.prototype.isRequired = function () {\n    return this.acroField.hasFlag(AcroFieldFlags.Required);\n  };\n  /**\r\n   * Require this field to have a value when the form is submitted.\r\n   * For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * field.enableRequired()\r\n   * ```\r\n   */\n\n\n  PDFField.prototype.enableRequired = function () {\n    this.acroField.setFlagTo(AcroFieldFlags.Required, true);\n  };\n  /**\r\n   * Do not require this field to have a value when the form is submitted.\r\n   * For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * field.disableRequired()\r\n   * ```\r\n   */\n\n\n  PDFField.prototype.disableRequired = function () {\n    this.acroField.setFlagTo(AcroFieldFlags.Required, false);\n  };\n  /**\r\n   * Returns `true` if this field's value should be exported when the form is\r\n   * submitted. See [[PDFField.enableExporting]] and\r\n   * [[PDFField.disableExporting]].\r\n   * For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * if (field.isExported()) console.log('Exporting is enabled')\r\n   * ```\r\n   * @returns Whether or not this field's value should be exported.\r\n   */\n\n\n  PDFField.prototype.isExported = function () {\n    return !this.acroField.hasFlag(AcroFieldFlags.NoExport);\n  };\n  /**\r\n   * Indicate that this field's value should be exported when the form is\r\n   * submitted in a PDF reader. For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * field.enableExporting()\r\n   * ```\r\n   */\n\n\n  PDFField.prototype.enableExporting = function () {\n    this.acroField.setFlagTo(AcroFieldFlags.NoExport, false);\n  };\n  /**\r\n   * Indicate that this field's value should **not** be exported when the form\r\n   * is submitted in a PDF reader. For example:\r\n   * ```js\r\n   * const field = form.getField('some.field')\r\n   * field.disableExporting()\r\n   * ```\r\n   */\n\n\n  PDFField.prototype.disableExporting = function () {\n    this.acroField.setFlagTo(AcroFieldFlags.NoExport, true);\n  };\n  /** @ignore */\n\n\n  PDFField.prototype.needsAppearancesUpdate = function () {\n    throw new MethodNotImplementedError(this.constructor.name, 'needsAppearancesUpdate');\n  };\n  /** @ignore */\n\n\n  PDFField.prototype.defaultUpdateAppearances = function (_font) {\n    throw new MethodNotImplementedError(this.constructor.name, 'defaultUpdateAppearances');\n  };\n\n  PDFField.prototype.markAsDirty = function () {\n    this.doc.getForm().markFieldAsDirty(this.ref);\n  };\n\n  PDFField.prototype.markAsClean = function () {\n    this.doc.getForm().markFieldAsClean(this.ref);\n  };\n\n  PDFField.prototype.isDirty = function () {\n    return this.doc.getForm().fieldIsDirty(this.ref);\n  };\n\n  PDFField.prototype.createWidget = function (options) {\n    var _a;\n\n    var textColor = options.textColor;\n    var backgroundColor = options.backgroundColor;\n    var borderColor = options.borderColor;\n    var borderWidth = options.borderWidth;\n    var degreesAngle = toDegrees(options.rotate);\n    var caption = options.caption;\n    var x = options.x;\n    var y = options.y;\n    var width = options.width + borderWidth;\n    var height = options.height + borderWidth;\n    var hidden = Boolean(options.hidden);\n    assertMultiple(degreesAngle, 'degreesAngle', 90); // Create a widget for this field\n\n    var widget = PDFWidgetAnnotation.create(this.doc.context, this.ref); // Set widget properties\n\n    var rect = rotateRectangle({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, borderWidth, degreesAngle);\n    widget.setRectangle(rect);\n    var ac = widget.getOrCreateAppearanceCharacteristics();\n\n    if (backgroundColor) {\n      ac.setBackgroundColor(colorToComponents(backgroundColor));\n    }\n\n    ac.setRotation(degreesAngle);\n    if (caption) ac.setCaptions({\n      normal: caption\n    });\n    if (borderColor) ac.setBorderColor(colorToComponents(borderColor));\n    var bs = widget.getOrCreateBorderStyle();\n    if (borderWidth !== undefined) bs.setWidth(borderWidth);\n    widget.setFlagTo(AnnotationFlags.Print, true);\n    widget.setFlagTo(AnnotationFlags.Hidden, hidden);\n    widget.setFlagTo(AnnotationFlags.Invisible, false); // Set acrofield properties\n\n    if (textColor) {\n      var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : '';\n      var newDa = da + '\\n' + setFillingColor(textColor).toString();\n      this.acroField.setDefaultAppearance(newDa);\n    }\n\n    return widget;\n  };\n\n  PDFField.prototype.updateWidgetAppearanceWithFont = function (widget, font, _a) {\n    var normal = _a.normal,\n        rollover = _a.rollover,\n        down = _a.down;\n    this.updateWidgetAppearances(widget, {\n      normal: this.createAppearanceStream(widget, normal, font),\n      rollover: rollover && this.createAppearanceStream(widget, rollover, font),\n      down: down && this.createAppearanceStream(widget, down, font)\n    });\n  };\n\n  PDFField.prototype.updateOnOffWidgetAppearance = function (widget, onValue, _a) {\n    var normal = _a.normal,\n        rollover = _a.rollover,\n        down = _a.down;\n    this.updateWidgetAppearances(widget, {\n      normal: this.createAppearanceDict(widget, normal, onValue),\n      rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),\n      down: down && this.createAppearanceDict(widget, down, onValue)\n    });\n  };\n\n  PDFField.prototype.updateWidgetAppearances = function (widget, _a) {\n    var normal = _a.normal,\n        rollover = _a.rollover,\n        down = _a.down;\n    widget.setNormalAppearance(normal);\n\n    if (rollover) {\n      widget.setRolloverAppearance(rollover);\n    } else {\n      widget.removeRolloverAppearance();\n    }\n\n    if (down) {\n      widget.setDownAppearance(down);\n    } else {\n      widget.removeDownAppearance();\n    }\n  }; // // TODO: Do we need to do this...?\n  // private foo(font: PDFFont, dict: PDFDict) {\n  //   if (!dict.lookup(PDFName.of('DR'))) {\n  //     dict.set(PDFName.of('DR'), dict.context.obj({}));\n  //   }\n  //   const DR = dict.lookup(PDFName.of('DR'), PDFDict);\n  //   if (!DR.lookup(PDFName.of('Font'))) {\n  //     DR.set(PDFName.of('Font'), dict.context.obj({}));\n  //   }\n  //   const Font = DR.lookup(PDFName.of('Font'), PDFDict);\n  //   Font.set(PDFName.of(font.name), font.ref);\n  // }\n\n\n  PDFField.prototype.createAppearanceStream = function (widget, appearance, font) {\n    var _a;\n\n    var context = this.acroField.dict.context;\n\n    var _b = widget.getRectangle(),\n        width = _b.width,\n        height = _b.height; // TODO: Do we need to do this...?\n    // if (font) {\n    //   this.foo(font, widget.dict);\n    //   this.foo(font, this.doc.getForm().acroForm.dict);\n    // }\n    // END TODO\n\n\n    var Resources = font && {\n      Font: (_a = {}, _a[font.name] = font.ref, _a)\n    };\n    var stream = context.formXObject(appearance, {\n      Resources: Resources,\n      BBox: context.obj([0, 0, width, height]),\n      Matrix: context.obj([1, 0, 0, 1, 0, 0])\n    });\n    var streamRef = context.register(stream);\n    return streamRef;\n  };\n  /**\r\n   * Create a FormXObject of the supplied image and add it to context.\r\n   * The FormXObject size is calculated based on the widget (including\r\n   * the alignment).\r\n   * @param widget The widget that should display the image.\r\n   * @param alignment The alignment of the image.\r\n   * @param image The image that should be displayed.\r\n   * @returns The ref for the FormXObject that was added to the context.\r\n   */\n\n\n  PDFField.prototype.createImageAppearanceStream = function (widget, image, alignment) {\n    // NOTE: This implementation doesn't handle image borders.\n    // NOTE: Acrobat seems to resize the image (maybe even skewing its aspect\n    //       ratio) to fit perfectly within the widget's rectangle. This method\n    //       does not currently do that. Should there be an option for that?\n    var _a;\n\n    var _b;\n\n    var context = this.acroField.dict.context;\n    var rectangle = widget.getRectangle();\n    var ap = widget.getAppearanceCharacteristics();\n    var bs = widget.getBorderStyle();\n    var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;\n    var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());\n    var rotate = rotateInPlace(__assign(__assign({}, rectangle), {\n      rotation: rotation\n    }));\n    var adj = adjustDimsForRotation(rectangle, rotation);\n    var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2); // Support borders on images and maybe other properties\n\n    var options = {\n      x: borderWidth,\n      y: borderWidth,\n      width: imageDims.width,\n      height: imageDims.height,\n      //\n      rotate: degrees(0),\n      xSkew: degrees(0),\n      ySkew: degrees(0)\n    };\n\n    if (alignment === ImageAlignment.Center) {\n      options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;\n      options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;\n    } else if (alignment === ImageAlignment.Right) {\n      options.x = adj.width - borderWidth - imageDims.width;\n      options.y = adj.height - borderWidth - imageDims.height;\n    }\n\n    var imageName = addRandomSuffix('Image', 10);\n\n    var appearance = __spreadArrays(rotate, drawImage(imageName, options)); ////////////\n\n\n    var Resources = {\n      XObject: (_a = {}, _a[imageName] = image.ref, _a)\n    };\n    var stream = context.formXObject(appearance, {\n      Resources: Resources,\n      BBox: context.obj([0, 0, rectangle.width, rectangle.height]),\n      Matrix: context.obj([1, 0, 0, 1, 0, 0])\n    });\n    return context.register(stream);\n  };\n\n  PDFField.prototype.createAppearanceDict = function (widget, appearance, onValue) {\n    var context = this.acroField.dict.context;\n    var onStreamRef = this.createAppearanceStream(widget, appearance.on);\n    var offStreamRef = this.createAppearanceStream(widget, appearance.off);\n    var appearanceDict = context.obj({});\n    appearanceDict.set(onValue, onStreamRef);\n    appearanceDict.set(PDFName.of('Off'), offStreamRef);\n    return appearanceDict;\n  };\n\n  return PDFField;\n}();\n\nexport default PDFField;","map":{"version":3,"sources":["../../../src/api/form/PDFField.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __spreadArrays } from \"tslib\";\r\nimport PDFDocument from \"../PDFDocument\";\r\nimport { colorToComponents, setFillingColor } from \"../colors\";\r\nimport { toDegrees, rotateRectangle, reduceRotation, adjustDimsForRotation, degrees, } from \"../rotations\";\r\nimport { PDFRef, PDFWidgetAnnotation, PDFName, MethodNotImplementedError, AcroFieldFlags, PDFAcroTerminal, AnnotationFlags, } from \"../../core\";\r\nimport { addRandomSuffix, assertIs, assertMultiple, assertOrUndefined, } from \"../../utils\";\r\nimport { ImageAlignment } from '../image';\r\nimport { drawImage, rotateInPlace } from '../operations';\r\nexport var assertFieldAppearanceOptions = function (options) {\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, 'options.x', ['number']);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, 'options.y', ['number']);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, 'options.width', ['number']);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, 'options.height', ['number']);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, 'options.textColor', [\r\n        [Object, 'Color'],\r\n    ]);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, 'options.backgroundColor', [\r\n        [Object, 'Color'],\r\n    ]);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, 'options.borderColor', [\r\n        [Object, 'Color'],\r\n    ]);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, 'options.borderWidth', ['number']);\r\n    assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, 'options.rotate', [[Object, 'Rotation']]);\r\n};\r\n/**\r\n * Represents a field of a [[PDFForm]].\r\n *\r\n * This class is effectively abstract. All fields in a [[PDFForm]] will\r\n * actually be an instance of a subclass of this class.\r\n *\r\n * Note that each field in a PDF is represented by a single field object.\r\n * However, a given field object may be rendered at multiple locations within\r\n * the document (across one or more pages). The rendering of a field is\r\n * controlled by its widgets. Each widget causes its field to be displayed at a\r\n * particular location in the document.\r\n *\r\n * Most of the time each field in a PDF has only a single widget, and thus is\r\n * only rendered once. However, if a field is rendered multiple times, it will\r\n * have multiple widgets - one for each location it is rendered.\r\n *\r\n * This abstraction of field objects and widgets is defined in the PDF\r\n * specification and dictates how PDF files store fields and where they are\r\n * to be rendered.\r\n */\r\nvar PDFField = /** @class */ (function () {\r\n    function PDFField(acroField, ref, doc) {\r\n        assertIs(acroField, 'acroField', [[PDFAcroTerminal, 'PDFAcroTerminal']]);\r\n        assertIs(ref, 'ref', [[PDFRef, 'PDFRef']]);\r\n        assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\r\n        this.acroField = acroField;\r\n        this.ref = ref;\r\n        this.doc = doc;\r\n    }\r\n    /**\r\n     * Get the fully qualified name of this field. For example:\r\n     * ```js\r\n     * const fields = form.getFields()\r\n     * fields.forEach(field => {\r\n     *   const name = field.getName()\r\n     *   console.log('Field name:', name)\r\n     * })\r\n     * ```\r\n     * Note that PDF fields are structured as a tree. Each field is the\r\n     * descendent of a series of ancestor nodes all the way up to the form node,\r\n     * which is always the root of the tree. Each node in the tree (except for\r\n     * the form node) has a partial name. Partial names can be composed of any\r\n     * unicode characters except a period (`.`). The fully qualified name of a\r\n     * field is composed of the partial names of all its ancestors joined\r\n     * with periods. This means that splitting the fully qualified name on\r\n     * periods and taking the last element of the resulting array will give you\r\n     * the partial name of a specific field.\r\n     * @returns The fully qualified name of this field.\r\n     */\r\n    PDFField.prototype.getName = function () {\r\n        var _a;\r\n        return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : '';\r\n    };\r\n    /**\r\n     * Returns `true` if this field is read only. This means that PDF readers\r\n     * will not allow users to interact with the field or change its value. See\r\n     * [[PDFField.enableReadOnly]] and [[PDFField.disableReadOnly]].\r\n     * For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * if (field.isReadOnly()) console.log('Read only is enabled')\r\n     * ```\r\n     * @returns Whether or not this is a read only field.\r\n     */\r\n    PDFField.prototype.isReadOnly = function () {\r\n        return this.acroField.hasFlag(AcroFieldFlags.ReadOnly);\r\n    };\r\n    /**\r\n     * Prevent PDF readers from allowing users to interact with this field or\r\n     * change its value. The field will not respond to mouse or keyboard input.\r\n     * For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * field.enableReadOnly()\r\n     * ```\r\n     * Useful for fields whose values are computed, imported from a database, or\r\n     * prefilled by software before being displayed to the user.\r\n     */\r\n    PDFField.prototype.enableReadOnly = function () {\r\n        this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, true);\r\n    };\r\n    /**\r\n     * Allow users to interact with this field and change its value in PDF\r\n     * readers via mouse and keyboard input. For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * field.disableReadOnly()\r\n     * ```\r\n     */\r\n    PDFField.prototype.disableReadOnly = function () {\r\n        this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, false);\r\n    };\r\n    /**\r\n     * Returns `true` if this field must have a value when the form is submitted.\r\n     * See [[PDFField.enableRequired]] and [[PDFField.disableRequired]].\r\n     * For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * if (field.isRequired()) console.log('Field is required')\r\n     * ```\r\n     * @returns Whether or not this field is required.\r\n     */\r\n    PDFField.prototype.isRequired = function () {\r\n        return this.acroField.hasFlag(AcroFieldFlags.Required);\r\n    };\r\n    /**\r\n     * Require this field to have a value when the form is submitted.\r\n     * For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * field.enableRequired()\r\n     * ```\r\n     */\r\n    PDFField.prototype.enableRequired = function () {\r\n        this.acroField.setFlagTo(AcroFieldFlags.Required, true);\r\n    };\r\n    /**\r\n     * Do not require this field to have a value when the form is submitted.\r\n     * For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * field.disableRequired()\r\n     * ```\r\n     */\r\n    PDFField.prototype.disableRequired = function () {\r\n        this.acroField.setFlagTo(AcroFieldFlags.Required, false);\r\n    };\r\n    /**\r\n     * Returns `true` if this field's value should be exported when the form is\r\n     * submitted. See [[PDFField.enableExporting]] and\r\n     * [[PDFField.disableExporting]].\r\n     * For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * if (field.isExported()) console.log('Exporting is enabled')\r\n     * ```\r\n     * @returns Whether or not this field's value should be exported.\r\n     */\r\n    PDFField.prototype.isExported = function () {\r\n        return !this.acroField.hasFlag(AcroFieldFlags.NoExport);\r\n    };\r\n    /**\r\n     * Indicate that this field's value should be exported when the form is\r\n     * submitted in a PDF reader. For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * field.enableExporting()\r\n     * ```\r\n     */\r\n    PDFField.prototype.enableExporting = function () {\r\n        this.acroField.setFlagTo(AcroFieldFlags.NoExport, false);\r\n    };\r\n    /**\r\n     * Indicate that this field's value should **not** be exported when the form\r\n     * is submitted in a PDF reader. For example:\r\n     * ```js\r\n     * const field = form.getField('some.field')\r\n     * field.disableExporting()\r\n     * ```\r\n     */\r\n    PDFField.prototype.disableExporting = function () {\r\n        this.acroField.setFlagTo(AcroFieldFlags.NoExport, true);\r\n    };\r\n    /** @ignore */\r\n    PDFField.prototype.needsAppearancesUpdate = function () {\r\n        throw new MethodNotImplementedError(this.constructor.name, 'needsAppearancesUpdate');\r\n    };\r\n    /** @ignore */\r\n    PDFField.prototype.defaultUpdateAppearances = function (_font) {\r\n        throw new MethodNotImplementedError(this.constructor.name, 'defaultUpdateAppearances');\r\n    };\r\n    PDFField.prototype.markAsDirty = function () {\r\n        this.doc.getForm().markFieldAsDirty(this.ref);\r\n    };\r\n    PDFField.prototype.markAsClean = function () {\r\n        this.doc.getForm().markFieldAsClean(this.ref);\r\n    };\r\n    PDFField.prototype.isDirty = function () {\r\n        return this.doc.getForm().fieldIsDirty(this.ref);\r\n    };\r\n    PDFField.prototype.createWidget = function (options) {\r\n        var _a;\r\n        var textColor = options.textColor;\r\n        var backgroundColor = options.backgroundColor;\r\n        var borderColor = options.borderColor;\r\n        var borderWidth = options.borderWidth;\r\n        var degreesAngle = toDegrees(options.rotate);\r\n        var caption = options.caption;\r\n        var x = options.x;\r\n        var y = options.y;\r\n        var width = options.width + borderWidth;\r\n        var height = options.height + borderWidth;\r\n        var hidden = Boolean(options.hidden);\r\n        assertMultiple(degreesAngle, 'degreesAngle', 90);\r\n        // Create a widget for this field\r\n        var widget = PDFWidgetAnnotation.create(this.doc.context, this.ref);\r\n        // Set widget properties\r\n        var rect = rotateRectangle({ x: x, y: y, width: width, height: height }, borderWidth, degreesAngle);\r\n        widget.setRectangle(rect);\r\n        var ac = widget.getOrCreateAppearanceCharacteristics();\r\n        if (backgroundColor) {\r\n            ac.setBackgroundColor(colorToComponents(backgroundColor));\r\n        }\r\n        ac.setRotation(degreesAngle);\r\n        if (caption)\r\n            ac.setCaptions({ normal: caption });\r\n        if (borderColor)\r\n            ac.setBorderColor(colorToComponents(borderColor));\r\n        var bs = widget.getOrCreateBorderStyle();\r\n        if (borderWidth !== undefined)\r\n            bs.setWidth(borderWidth);\r\n        widget.setFlagTo(AnnotationFlags.Print, true);\r\n        widget.setFlagTo(AnnotationFlags.Hidden, hidden);\r\n        widget.setFlagTo(AnnotationFlags.Invisible, false);\r\n        // Set acrofield properties\r\n        if (textColor) {\r\n            var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : '';\r\n            var newDa = da + '\\n' + setFillingColor(textColor).toString();\r\n            this.acroField.setDefaultAppearance(newDa);\r\n        }\r\n        return widget;\r\n    };\r\n    PDFField.prototype.updateWidgetAppearanceWithFont = function (widget, font, _a) {\r\n        var normal = _a.normal, rollover = _a.rollover, down = _a.down;\r\n        this.updateWidgetAppearances(widget, {\r\n            normal: this.createAppearanceStream(widget, normal, font),\r\n            rollover: rollover && this.createAppearanceStream(widget, rollover, font),\r\n            down: down && this.createAppearanceStream(widget, down, font),\r\n        });\r\n    };\r\n    PDFField.prototype.updateOnOffWidgetAppearance = function (widget, onValue, _a) {\r\n        var normal = _a.normal, rollover = _a.rollover, down = _a.down;\r\n        this.updateWidgetAppearances(widget, {\r\n            normal: this.createAppearanceDict(widget, normal, onValue),\r\n            rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),\r\n            down: down && this.createAppearanceDict(widget, down, onValue),\r\n        });\r\n    };\r\n    PDFField.prototype.updateWidgetAppearances = function (widget, _a) {\r\n        var normal = _a.normal, rollover = _a.rollover, down = _a.down;\r\n        widget.setNormalAppearance(normal);\r\n        if (rollover) {\r\n            widget.setRolloverAppearance(rollover);\r\n        }\r\n        else {\r\n            widget.removeRolloverAppearance();\r\n        }\r\n        if (down) {\r\n            widget.setDownAppearance(down);\r\n        }\r\n        else {\r\n            widget.removeDownAppearance();\r\n        }\r\n    };\r\n    // // TODO: Do we need to do this...?\r\n    // private foo(font: PDFFont, dict: PDFDict) {\r\n    //   if (!dict.lookup(PDFName.of('DR'))) {\r\n    //     dict.set(PDFName.of('DR'), dict.context.obj({}));\r\n    //   }\r\n    //   const DR = dict.lookup(PDFName.of('DR'), PDFDict);\r\n    //   if (!DR.lookup(PDFName.of('Font'))) {\r\n    //     DR.set(PDFName.of('Font'), dict.context.obj({}));\r\n    //   }\r\n    //   const Font = DR.lookup(PDFName.of('Font'), PDFDict);\r\n    //   Font.set(PDFName.of(font.name), font.ref);\r\n    // }\r\n    PDFField.prototype.createAppearanceStream = function (widget, appearance, font) {\r\n        var _a;\r\n        var context = this.acroField.dict.context;\r\n        var _b = widget.getRectangle(), width = _b.width, height = _b.height;\r\n        // TODO: Do we need to do this...?\r\n        // if (font) {\r\n        //   this.foo(font, widget.dict);\r\n        //   this.foo(font, this.doc.getForm().acroForm.dict);\r\n        // }\r\n        // END TODO\r\n        var Resources = font && { Font: (_a = {}, _a[font.name] = font.ref, _a) };\r\n        var stream = context.formXObject(appearance, {\r\n            Resources: Resources,\r\n            BBox: context.obj([0, 0, width, height]),\r\n            Matrix: context.obj([1, 0, 0, 1, 0, 0]),\r\n        });\r\n        var streamRef = context.register(stream);\r\n        return streamRef;\r\n    };\r\n    /**\r\n     * Create a FormXObject of the supplied image and add it to context.\r\n     * The FormXObject size is calculated based on the widget (including\r\n     * the alignment).\r\n     * @param widget The widget that should display the image.\r\n     * @param alignment The alignment of the image.\r\n     * @param image The image that should be displayed.\r\n     * @returns The ref for the FormXObject that was added to the context.\r\n     */\r\n    PDFField.prototype.createImageAppearanceStream = function (widget, image, alignment) {\r\n        // NOTE: This implementation doesn't handle image borders.\r\n        // NOTE: Acrobat seems to resize the image (maybe even skewing its aspect\r\n        //       ratio) to fit perfectly within the widget's rectangle. This method\r\n        //       does not currently do that. Should there be an option for that?\r\n        var _a;\r\n        var _b;\r\n        var context = this.acroField.dict.context;\r\n        var rectangle = widget.getRectangle();\r\n        var ap = widget.getAppearanceCharacteristics();\r\n        var bs = widget.getBorderStyle();\r\n        var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;\r\n        var rotation = reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());\r\n        var rotate = rotateInPlace(__assign(__assign({}, rectangle), { rotation: rotation }));\r\n        var adj = adjustDimsForRotation(rectangle, rotation);\r\n        var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);\r\n        // Support borders on images and maybe other properties\r\n        var options = {\r\n            x: borderWidth,\r\n            y: borderWidth,\r\n            width: imageDims.width,\r\n            height: imageDims.height,\r\n            //\r\n            rotate: degrees(0),\r\n            xSkew: degrees(0),\r\n            ySkew: degrees(0),\r\n        };\r\n        if (alignment === ImageAlignment.Center) {\r\n            options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;\r\n            options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;\r\n        }\r\n        else if (alignment === ImageAlignment.Right) {\r\n            options.x = adj.width - borderWidth - imageDims.width;\r\n            options.y = adj.height - borderWidth - imageDims.height;\r\n        }\r\n        var imageName = addRandomSuffix('Image', 10);\r\n        var appearance = __spreadArrays(rotate, drawImage(imageName, options));\r\n        ////////////\r\n        var Resources = { XObject: (_a = {}, _a[imageName] = image.ref, _a) };\r\n        var stream = context.formXObject(appearance, {\r\n            Resources: Resources,\r\n            BBox: context.obj([0, 0, rectangle.width, rectangle.height]),\r\n            Matrix: context.obj([1, 0, 0, 1, 0, 0]),\r\n        });\r\n        return context.register(stream);\r\n    };\r\n    PDFField.prototype.createAppearanceDict = function (widget, appearance, onValue) {\r\n        var context = this.acroField.dict.context;\r\n        var onStreamRef = this.createAppearanceStream(widget, appearance.on);\r\n        var offStreamRef = this.createAppearanceStream(widget, appearance.off);\r\n        var appearanceDict = context.obj({});\r\n        appearanceDict.set(onValue, onStreamRef);\r\n        appearanceDict.set(PDFName.of('Off'), offStreamRef);\r\n        return appearanceDict;\r\n    };\r\n    return PDFField;\r\n}());\r\nexport default PDFField;\r\n//# sourceMappingURL=PDFField.js.map"]},"metadata":{},"sourceType":"module"}