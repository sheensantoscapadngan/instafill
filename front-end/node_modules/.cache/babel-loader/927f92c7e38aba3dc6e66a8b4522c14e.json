{"ast":null,"code":"import { __assign } from 'tslib';\nimport { mix } from 'popmotion';\nimport { complex, px } from 'style-value-types';\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\n\n\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\r\n   * If latest is a string, if it's a percentage we can return immediately as it's\r\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n   */\n\n  if (typeof latest === \"string\") {\n    if (px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\r\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n   * pixel value as a percentage of each axis\r\n   */\n\n\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\n\nvar varToken = \"_$css\";\n\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n      treeScale = _a.treeScale;\n  var original = latest;\n  /**\r\n   * We need to first strip and store CSS variables from the string.\r\n   */\n\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n\n  var shadow = complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n  if (shadow.length > 5) return original;\n  var template = complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\r\n   * Ideally we'd correct x and y scales individually, but because blur and\r\n   * spread apply to both we have to take a scale average and apply that instead.\r\n   * We could potentially improve the outcome of this by incorporating the ratio between\r\n   * the two scales.\r\n   */\n\n  var averageScale = mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n\n  return output;\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar valueScaleCorrection = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\n/**\r\n * @internal\r\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n\nexport { addScaleCorrection, correctBorderRadius, correctBoxShadow, pixelsToPercent, valueScaleCorrection };","map":{"version":3,"sources":["C:/Users/User/Documents/GitHub/instafill/front-end/node_modules/framer-motion/dist/es/render/dom/projection/scale-correction.js"],"names":["__assign","mix","complex","px","cssVariableRegex","pixelsToPercent","pixels","axis","max","min","correctBorderRadius","latest","_layoutState","_a","target","test","parseFloat","x","y","varToken","correctBoxShadow","delta","treeScale","original","containsCSSVariables","includes","cssVariables","replace","match","push","shadow","parse","length","template","createTransformer","offset","xScale","scale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","process","valueScaleCorrection","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow","addScaleCorrection","correctors","key"],"mappings":"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","sourcesContent":["import { __assign } from 'tslib';\r\nimport { mix } from 'popmotion';\r\nimport { complex, px } from 'style-value-types';\r\nimport { cssVariableRegex } from '../utils/css-variables-conversion.js';\r\n\r\nfunction pixelsToPercent(pixels, axis) {\r\n    return (pixels / (axis.max - axis.min)) * 100;\r\n}\r\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\r\nfunction correctBorderRadius(latest, _layoutState, _a) {\r\n    var target = _a.target;\r\n    /**\r\n     * If latest is a string, if it's a percentage we can return immediately as it's\r\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n     */\r\n    if (typeof latest === \"string\") {\r\n        if (px.test(latest)) {\r\n            latest = parseFloat(latest);\r\n        }\r\n        else {\r\n            return latest;\r\n        }\r\n    }\r\n    /**\r\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n     * pixel value as a percentage of each axis\r\n     */\r\n    var x = pixelsToPercent(latest, target.x);\r\n    var y = pixelsToPercent(latest, target.y);\r\n    return x + \"% \" + y + \"%\";\r\n}\r\nvar varToken = \"_$css\";\r\nfunction correctBoxShadow(latest, _a) {\r\n    var delta = _a.delta, treeScale = _a.treeScale;\r\n    var original = latest;\r\n    /**\r\n     * We need to first strip and store CSS variables from the string.\r\n     */\r\n    var containsCSSVariables = latest.includes(\"var(\");\r\n    var cssVariables = [];\r\n    if (containsCSSVariables) {\r\n        latest = latest.replace(cssVariableRegex, function (match) {\r\n            cssVariables.push(match);\r\n            return varToken;\r\n        });\r\n    }\r\n    var shadow = complex.parse(latest);\r\n    // TODO: Doesn't support multiple shadows\r\n    if (shadow.length > 5)\r\n        return original;\r\n    var template = complex.createTransformer(latest);\r\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\r\n    // Calculate the overall context scale\r\n    var xScale = delta.x.scale * treeScale.x;\r\n    var yScale = delta.y.scale * treeScale.y;\r\n    shadow[0 + offset] /= xScale;\r\n    shadow[1 + offset] /= yScale;\r\n    /**\r\n     * Ideally we'd correct x and y scales individually, but because blur and\r\n     * spread apply to both we have to take a scale average and apply that instead.\r\n     * We could potentially improve the outcome of this by incorporating the ratio between\r\n     * the two scales.\r\n     */\r\n    var averageScale = mix(xScale, yScale, 0.5);\r\n    // Blur\r\n    if (typeof shadow[2 + offset] === \"number\")\r\n        shadow[2 + offset] /= averageScale;\r\n    // Spread\r\n    if (typeof shadow[3 + offset] === \"number\")\r\n        shadow[3 + offset] /= averageScale;\r\n    var output = template(shadow);\r\n    if (containsCSSVariables) {\r\n        var i_1 = 0;\r\n        output = output.replace(varToken, function () {\r\n            var cssVariable = cssVariables[i_1];\r\n            i_1++;\r\n            return cssVariable;\r\n        });\r\n    }\r\n    return output;\r\n}\r\nvar borderCorrectionDefinition = {\r\n    process: correctBorderRadius,\r\n};\r\nvar valueScaleCorrection = {\r\n    borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ] }),\r\n    borderTopLeftRadius: borderCorrectionDefinition,\r\n    borderTopRightRadius: borderCorrectionDefinition,\r\n    borderBottomLeftRadius: borderCorrectionDefinition,\r\n    borderBottomRightRadius: borderCorrectionDefinition,\r\n    boxShadow: {\r\n        process: correctBoxShadow,\r\n    },\r\n};\r\n/**\r\n * @internal\r\n */\r\nfunction addScaleCorrection(correctors) {\r\n    for (var key in correctors) {\r\n        valueScaleCorrection[key] = correctors[key];\r\n    }\r\n}\r\n\r\nexport { addScaleCorrection, correctBorderRadius, correctBoxShadow, pixelsToPercent, valueScaleCorrection };\r\n"]},"metadata":{},"sourceType":"module"}