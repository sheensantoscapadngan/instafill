{"ast":null,"code":"import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline,\n    CarriageReturn = CharCodes.CarriageReturn; // TODO: Throw error if eof is reached before finishing object parse...\n\nvar BaseParser =\n/** @class */\nfunction () {\n  function BaseParser(bytes, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n\n    this.bytes = bytes;\n    this.capNumbers = capNumbers;\n  }\n\n  BaseParser.prototype.parseRawInt = function () {\n    var value = '';\n\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n\n    var numberValue = Number(value);\n\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n\n    return numberValue;\n  }; // TODO: Maybe handle exponential format?\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n\n\n  BaseParser.prototype.parseRawNumber = function () {\n    var value = ''; // Parse integer-part, the leading (+ | - | . | 0-9)\n\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsNumeric[byte]) break;\n      value += charFromCode(this.bytes.next());\n      if (byte === CharCodes.Period) break;\n    } // Parse decimal-part, the trailing (0-9)\n\n\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n\n    var numberValue = Number(value);\n\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n\n    if (numberValue > Number.MAX_SAFE_INTEGER) {\n      if (this.capNumbers) {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n        console.warn(msg);\n        return Number.MAX_SAFE_INTEGER;\n      } else {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n        console.warn(msg);\n      }\n    }\n\n    return numberValue;\n  };\n\n  BaseParser.prototype.skipWhitespace = function () {\n    while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n      this.bytes.next();\n    }\n  };\n\n  BaseParser.prototype.skipLine = function () {\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return;\n      this.bytes.next();\n    }\n  };\n\n  BaseParser.prototype.skipComment = function () {\n    if (this.bytes.peek() !== CharCodes.Percent) return false;\n\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return true;\n      this.bytes.next();\n    }\n\n    return true;\n  };\n\n  BaseParser.prototype.skipWhitespaceAndComments = function () {\n    this.skipWhitespace();\n\n    while (this.skipComment()) this.skipWhitespace();\n  };\n\n  BaseParser.prototype.matchKeyword = function (keyword) {\n    var initialOffset = this.bytes.offset();\n\n    for (var idx = 0, len = keyword.length; idx < len; idx++) {\n      if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n        this.bytes.moveTo(initialOffset);\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return BaseParser;\n}();\n\nexport default BaseParser;","map":{"version":3,"sources":["../../../src/core/parser/BaseParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline, CarriageReturn = CharCodes.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */ (function () {\n    function BaseParser(bytes, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        this.bytes = bytes;\n        this.capNumbers = capNumbers;\n    }\n    BaseParser.prototype.parseRawInt = function () {\n        var value = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsDigit[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n        }\n        var numberValue = Number(value);\n        if (!value || !isFinite(numberValue)) {\n            throw new NumberParsingError(this.bytes.position(), value);\n        }\n        return numberValue;\n    };\n    // TODO: Maybe handle exponential format?\n    // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n    BaseParser.prototype.parseRawNumber = function () {\n        var value = '';\n        // Parse integer-part, the leading (+ | - | . | 0-9)\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsNumeric[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n            if (byte === CharCodes.Period)\n                break;\n        }\n        // Parse decimal-part, the trailing (0-9)\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsDigit[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n        }\n        var numberValue = Number(value);\n        if (!value || !isFinite(numberValue)) {\n            throw new NumberParsingError(this.bytes.position(), value);\n        }\n        if (numberValue > Number.MAX_SAFE_INTEGER) {\n            if (this.capNumbers) {\n                var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n                console.warn(msg);\n                return Number.MAX_SAFE_INTEGER;\n            }\n            else {\n                var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n                console.warn(msg);\n            }\n        }\n        return numberValue;\n    };\n    BaseParser.prototype.skipWhitespace = function () {\n        while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n            this.bytes.next();\n        }\n    };\n    BaseParser.prototype.skipLine = function () {\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (byte === Newline || byte === CarriageReturn)\n                return;\n            this.bytes.next();\n        }\n    };\n    BaseParser.prototype.skipComment = function () {\n        if (this.bytes.peek() !== CharCodes.Percent)\n            return false;\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (byte === Newline || byte === CarriageReturn)\n                return true;\n            this.bytes.next();\n        }\n        return true;\n    };\n    BaseParser.prototype.skipWhitespaceAndComments = function () {\n        this.skipWhitespace();\n        while (this.skipComment())\n            this.skipWhitespace();\n    };\n    BaseParser.prototype.matchKeyword = function (keyword) {\n        var initialOffset = this.bytes.offset();\n        for (var idx = 0, len = keyword.length; idx < len; idx++) {\n            if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n                this.bytes.moveTo(initialOffset);\n                return false;\n            }\n        }\n        return true;\n    };\n    return BaseParser;\n}());\nexport default BaseParser;\n//# sourceMappingURL=BaseParser.js.map"]},"metadata":{},"sourceType":"module"}