{"ast":null,"code":"import { createContext, useContext, useMemo, createElement } from 'react';\nimport { __rest, __spread } from 'tslib';\n/**\r\n * @public\r\n */\n\nvar MotionConfigContext = createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  features: [],\n  isStatic: false\n});\n/**\r\n * MotionConfig can be used in combination with the `m` component to cut bundle size\r\n * and dynamically load only the features you use.\r\n *\r\n * ```jsx\r\n * import {\r\n *   m as motion,\r\n *   AnimationFeature,\r\n *   MotionConfig\r\n * } from \"framer-motion\"\r\n *\r\n * export function App() {\r\n *   return (\r\n *     <MotionConfig features={[AnimationFeature]}>\r\n *       <motion.div animate={{ x: 100 }} />\r\n *     </MotionConfig>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\n\nfunction MotionConfig(_a) {\n  var children = _a.children,\n      _b = _a.features,\n      features = _b === void 0 ? [] : _b,\n      transition = _a.transition,\n      props = __rest(_a, [\"children\", \"features\", \"transition\"]);\n\n  var pluginContext = useContext(MotionConfigContext);\n\n  var loadedFeatures = __spread(new Set(__spread(pluginContext.features, features))); // We do want to rerender children when the number of loaded features changes\n\n\n  var value = useMemo(function () {\n    return {\n      features: loadedFeatures,\n      transition: transition || pluginContext.transition\n    };\n  }, [loadedFeatures.length, transition]); // Mutative to prevent triggering rerenders in all listening\n  // components every time this component renders\n\n  for (var key in props) {\n    value[key] = props[key];\n  }\n\n  return createElement(MotionConfigContext.Provider, {\n    value: value\n  }, children);\n}\n\nexport { MotionConfig, MotionConfigContext };","map":{"version":3,"sources":["D:/Documents/GitHub/instafill/front-end/node_modules/framer-motion/dist/es/context/MotionConfigContext.js"],"names":["createContext","useContext","useMemo","createElement","__rest","__spread","MotionConfigContext","transformPagePoint","p","features","isStatic","MotionConfig","_a","children","_b","transition","props","pluginContext","loadedFeatures","Set","value","length","key","Provider"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,UAAxB,EAAoCC,OAApC,EAA6CC,aAA7C,QAAkE,OAAlE;AACA,SAASC,MAAT,EAAiBC,QAAjB,QAAiC,OAAjC;AAEA;AACA;AACA;;AACA,IAAIC,mBAAmB,GAAGN,aAAa,CAAC;AACpCO,EAAAA,kBAAkB,EAAE,UAAUC,CAAV,EAAa;AAAE,WAAOA,CAAP;AAAW,GADV;AAEpCC,EAAAA,QAAQ,EAAE,EAF0B;AAGpCC,EAAAA,QAAQ,EAAE;AAH0B,CAAD,CAAvC;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,EAAtB,EAA0B;AACtB,MAAIC,QAAQ,GAAGD,EAAE,CAACC,QAAlB;AAAA,MAA4BC,EAAE,GAAGF,EAAE,CAACH,QAApC;AAAA,MAA8CA,QAAQ,GAAGK,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9E;AAAA,MAAkFC,UAAU,GAAGH,EAAE,CAACG,UAAlG;AAAA,MAA8GC,KAAK,GAAGZ,MAAM,CAACQ,EAAD,EAAK,CAAC,UAAD,EAAa,UAAb,EAAyB,YAAzB,CAAL,CAA5H;;AACA,MAAIK,aAAa,GAAGhB,UAAU,CAACK,mBAAD,CAA9B;;AACA,MAAIY,cAAc,GAAGb,QAAQ,CAAC,IAAIc,GAAJ,CAAQd,QAAQ,CAACY,aAAa,CAACR,QAAf,EAAyBA,QAAzB,CAAhB,CAAD,CAA7B,CAHsB,CAItB;;;AACA,MAAIW,KAAK,GAAGlB,OAAO,CAAC,YAAY;AAAE,WAAQ;AACtCO,MAAAA,QAAQ,EAAES,cAD4B;AAEtCH,MAAAA,UAAU,EAAEA,UAAU,IAAIE,aAAa,CAACF;AAFF,KAAR;AAG7B,GAHc,EAGZ,CAACG,cAAc,CAACG,MAAhB,EAAwBN,UAAxB,CAHY,CAAnB,CALsB,CAStB;AACA;;AACA,OAAK,IAAIO,GAAT,IAAgBN,KAAhB,EAAuB;AACnBI,IAAAA,KAAK,CAACE,GAAD,CAAL,GAAaN,KAAK,CAACM,GAAD,CAAlB;AACH;;AACD,SAAQnB,aAAa,CAACG,mBAAmB,CAACiB,QAArB,EAA+B;AAAEH,IAAAA,KAAK,EAAEA;AAAT,GAA/B,EAAiDP,QAAjD,CAArB;AACH;;AAED,SAASF,YAAT,EAAuBL,mBAAvB","sourcesContent":["import { createContext, useContext, useMemo, createElement } from 'react';\r\nimport { __rest, __spread } from 'tslib';\r\n\r\n/**\r\n * @public\r\n */\r\nvar MotionConfigContext = createContext({\r\n    transformPagePoint: function (p) { return p; },\r\n    features: [],\r\n    isStatic: false,\r\n});\r\n/**\r\n * MotionConfig can be used in combination with the `m` component to cut bundle size\r\n * and dynamically load only the features you use.\r\n *\r\n * ```jsx\r\n * import {\r\n *   m as motion,\r\n *   AnimationFeature,\r\n *   MotionConfig\r\n * } from \"framer-motion\"\r\n *\r\n * export function App() {\r\n *   return (\r\n *     <MotionConfig features={[AnimationFeature]}>\r\n *       <motion.div animate={{ x: 100 }} />\r\n *     </MotionConfig>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction MotionConfig(_a) {\r\n    var children = _a.children, _b = _a.features, features = _b === void 0 ? [] : _b, transition = _a.transition, props = __rest(_a, [\"children\", \"features\", \"transition\"]);\r\n    var pluginContext = useContext(MotionConfigContext);\r\n    var loadedFeatures = __spread(new Set(__spread(pluginContext.features, features)));\r\n    // We do want to rerender children when the number of loaded features changes\r\n    var value = useMemo(function () { return ({\r\n        features: loadedFeatures,\r\n        transition: transition || pluginContext.transition,\r\n    }); }, [loadedFeatures.length, transition]);\r\n    // Mutative to prevent triggering rerenders in all listening\r\n    // components every time this component renders\r\n    for (var key in props) {\r\n        value[key] = props[key];\r\n    }\r\n    return (createElement(MotionConfigContext.Provider, { value: value }, children));\r\n}\r\n\r\nexport { MotionConfig, MotionConfigContext };\r\n"]},"metadata":{},"sourceType":"module"}