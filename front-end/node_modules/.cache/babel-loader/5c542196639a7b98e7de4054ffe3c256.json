{"ast":null,"code":"import { ReparseError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\n\nvar PDFXRefStreamParser =\n/** @class */\nfunction () {\n  function PDFXRefStreamParser(rawStream) {\n    this.alreadyParsed = false;\n    this.dict = rawStream.dict;\n    this.bytes = ByteStream.fromPDFRawStream(rawStream);\n    this.context = this.dict.context;\n    var Size = this.dict.lookup(PDFName.of('Size'), PDFNumber);\n    var Index = this.dict.lookup(PDFName.of('Index'));\n\n    if (Index instanceof PDFArray) {\n      this.subsections = [];\n\n      for (var idx = 0, len = Index.size(); idx < len; idx += 2) {\n        var firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();\n        var length_1 = Index.lookup(idx + 1, PDFNumber).asNumber();\n        this.subsections.push({\n          firstObjectNumber: firstObjectNumber,\n          length: length_1\n        });\n      }\n    } else {\n      this.subsections = [{\n        firstObjectNumber: 0,\n        length: Size.asNumber()\n      }];\n    }\n\n    var W = this.dict.lookup(PDFName.of('W'), PDFArray);\n    this.byteWidths = [-1, -1, -1];\n\n    for (var idx = 0, len = W.size(); idx < len; idx++) {\n      this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();\n    }\n  }\n\n  PDFXRefStreamParser.prototype.parseIntoContext = function () {\n    if (this.alreadyParsed) {\n      throw new ReparseError('PDFXRefStreamParser', 'parseIntoContext');\n    }\n\n    this.alreadyParsed = true;\n    this.context.trailerInfo = {\n      Root: this.dict.get(PDFName.of('Root')),\n      Encrypt: this.dict.get(PDFName.of('Encrypt')),\n      Info: this.dict.get(PDFName.of('Info')),\n      ID: this.dict.get(PDFName.of('ID'))\n    };\n    var entries = this.parseEntries(); // for (let idx = 0, len = entries.length; idx < len; idx++) {\n    // const entry = entries[idx];\n    // if (entry.deleted) this.context.delete(entry.ref);\n    // }\n\n    return entries;\n  };\n\n  PDFXRefStreamParser.prototype.parseEntries = function () {\n    var entries = [];\n    var _a = this.byteWidths,\n        typeFieldWidth = _a[0],\n        offsetFieldWidth = _a[1],\n        genFieldWidth = _a[2];\n\n    for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {\n      var _b = this.subsections[subsectionIdx],\n          firstObjectNumber = _b.firstObjectNumber,\n          length_2 = _b.length;\n\n      for (var objIdx = 0; objIdx < length_2; objIdx++) {\n        var type = 0;\n\n        for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {\n          type = type << 8 | this.bytes.next();\n        }\n\n        var offset = 0;\n\n        for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {\n          offset = offset << 8 | this.bytes.next();\n        }\n\n        var generationNumber = 0;\n\n        for (var idx = 0, len = genFieldWidth; idx < len; idx++) {\n          generationNumber = generationNumber << 8 | this.bytes.next();\n        } // When the `type` field is absent, it defaults to 1\n\n\n        if (typeFieldWidth === 0) type = 1;\n        var objectNumber = firstObjectNumber + objIdx;\n        var entry = {\n          ref: PDFRef.of(objectNumber, generationNumber),\n          offset: offset,\n          deleted: type === 0,\n          inObjectStream: type === 2\n        };\n        entries.push(entry);\n      }\n    }\n\n    return entries;\n  };\n\n  PDFXRefStreamParser.forStream = function (rawStream) {\n    return new PDFXRefStreamParser(rawStream);\n  };\n\n  return PDFXRefStreamParser;\n}();\n\nexport default PDFXRefStreamParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFXRefStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ReparseError } from \"../errors\";\r\nimport PDFArray from \"../objects/PDFArray\";\r\nimport PDFName from \"../objects/PDFName\";\r\nimport PDFNumber from \"../objects/PDFNumber\";\r\nimport PDFRef from \"../objects/PDFRef\";\r\nimport ByteStream from \"./ByteStream\";\r\nvar PDFXRefStreamParser = /** @class */ (function () {\r\n    function PDFXRefStreamParser(rawStream) {\r\n        this.alreadyParsed = false;\r\n        this.dict = rawStream.dict;\r\n        this.bytes = ByteStream.fromPDFRawStream(rawStream);\r\n        this.context = this.dict.context;\r\n        var Size = this.dict.lookup(PDFName.of('Size'), PDFNumber);\r\n        var Index = this.dict.lookup(PDFName.of('Index'));\r\n        if (Index instanceof PDFArray) {\r\n            this.subsections = [];\r\n            for (var idx = 0, len = Index.size(); idx < len; idx += 2) {\r\n                var firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();\r\n                var length_1 = Index.lookup(idx + 1, PDFNumber).asNumber();\r\n                this.subsections.push({ firstObjectNumber: firstObjectNumber, length: length_1 });\r\n            }\r\n        }\r\n        else {\r\n            this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];\r\n        }\r\n        var W = this.dict.lookup(PDFName.of('W'), PDFArray);\r\n        this.byteWidths = [-1, -1, -1];\r\n        for (var idx = 0, len = W.size(); idx < len; idx++) {\r\n            this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();\r\n        }\r\n    }\r\n    PDFXRefStreamParser.prototype.parseIntoContext = function () {\r\n        if (this.alreadyParsed) {\r\n            throw new ReparseError('PDFXRefStreamParser', 'parseIntoContext');\r\n        }\r\n        this.alreadyParsed = true;\r\n        this.context.trailerInfo = {\r\n            Root: this.dict.get(PDFName.of('Root')),\r\n            Encrypt: this.dict.get(PDFName.of('Encrypt')),\r\n            Info: this.dict.get(PDFName.of('Info')),\r\n            ID: this.dict.get(PDFName.of('ID')),\r\n        };\r\n        var entries = this.parseEntries();\r\n        // for (let idx = 0, len = entries.length; idx < len; idx++) {\r\n        // const entry = entries[idx];\r\n        // if (entry.deleted) this.context.delete(entry.ref);\r\n        // }\r\n        return entries;\r\n    };\r\n    PDFXRefStreamParser.prototype.parseEntries = function () {\r\n        var entries = [];\r\n        var _a = this.byteWidths, typeFieldWidth = _a[0], offsetFieldWidth = _a[1], genFieldWidth = _a[2];\r\n        for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {\r\n            var _b = this.subsections[subsectionIdx], firstObjectNumber = _b.firstObjectNumber, length_2 = _b.length;\r\n            for (var objIdx = 0; objIdx < length_2; objIdx++) {\r\n                var type = 0;\r\n                for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {\r\n                    type = (type << 8) | this.bytes.next();\r\n                }\r\n                var offset = 0;\r\n                for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {\r\n                    offset = (offset << 8) | this.bytes.next();\r\n                }\r\n                var generationNumber = 0;\r\n                for (var idx = 0, len = genFieldWidth; idx < len; idx++) {\r\n                    generationNumber = (generationNumber << 8) | this.bytes.next();\r\n                }\r\n                // When the `type` field is absent, it defaults to 1\r\n                if (typeFieldWidth === 0)\r\n                    type = 1;\r\n                var objectNumber = firstObjectNumber + objIdx;\r\n                var entry = {\r\n                    ref: PDFRef.of(objectNumber, generationNumber),\r\n                    offset: offset,\r\n                    deleted: type === 0,\r\n                    inObjectStream: type === 2,\r\n                };\r\n                entries.push(entry);\r\n            }\r\n        }\r\n        return entries;\r\n    };\r\n    PDFXRefStreamParser.forStream = function (rawStream) {\r\n        return new PDFXRefStreamParser(rawStream);\r\n    };\r\n    return PDFXRefStreamParser;\r\n}());\r\nexport default PDFXRefStreamParser;\r\n//# sourceMappingURL=PDFXRefStreamParser.js.map"]},"metadata":{},"sourceType":"module"}