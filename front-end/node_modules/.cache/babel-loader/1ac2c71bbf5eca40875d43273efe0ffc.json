{"ast":null,"code":"import { forwardRef, useContext, createElement, Fragment } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { useFeatures } from './features/use-features.js';\nimport { MotionContext } from '../context/MotionContext/index.js';\nimport { useVisualElement } from './utils/use-visual-element.js';\nimport { useMotionRef } from './utils/use-motion-ref.js';\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n *\r\n * @internal\r\n */\n\nfunction createMotionComponent(_a) {\n  var defaultFeatures = _a.defaultFeatures,\n      createVisualElement = _a.createVisualElement,\n      useRender = _a.useRender,\n      useVisualState = _a.useVisualState;\n\n  function MotionComponent(props, externalRef) {\n    /**\r\n     * If we're rendering in a static environment, we only visually update the component\r\n     * as a result of a React-rerender rather than interactions or animations. This\r\n     * means we don't need to load additional memory structures like VisualElement,\r\n     * or any gesture/animation features.\r\n     */\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\r\n     * Create the tree context. This is memoized and will only trigger renders\r\n     * when the current tree variant changes in static mode.\r\n     */\n\n    var context = useCreateMotionContext(props, isStatic);\n    /**\r\n     *\r\n     */\n\n    var visualState = useVisualState(props, isStatic);\n\n    if (!isStatic && typeof window !== \"undefined\") {\n      /**\r\n       * Create a VisualElement for this component. A VisualElement provides a common\r\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n       * providing a way of rendering to these APIs outside of the React render loop\r\n       * for more performant animations and interactions\r\n       */\n      context.visualElement = useVisualElement(isStatic, visualState, createVisualElement, props);\n      /**\r\n       * Load Motion gesture and animation features. These are rendered as renderless\r\n       * components so each feature can optionally make use of React lifecycle methods.\r\n       *\r\n       * TODO: The intention is to move these away from a React-centric to a\r\n       * VisualElement-centric lifecycle scheme.\r\n       */\n\n      features = useFeatures(defaultFeatures, context.visualElement, props);\n    }\n    /**\r\n     * The mount order and hierarchy is specific to ensure our element ref\r\n     * is hydrated by the time features fire their effects.\r\n     */\n\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n\nexport { createMotionComponent };","map":{"version":3,"sources":["C:/Users/User/Documents/GitHub/instafill/front-end/node_modules/framer-motion/dist/es/motion/index.js"],"names":["forwardRef","useContext","createElement","Fragment","MotionConfigContext","useFeatures","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","createMotionComponent","_a","defaultFeatures","createVisualElement","useRender","useVisualState","MotionComponent","props","externalRef","isStatic","features","context","visualState","window","visualElement","Provider","value"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,UAArB,EAAiCC,aAAjC,EAAgDC,QAAhD,QAAgE,OAAhE;AACA,SAASC,mBAAT,QAAoC,mCAApC;AACA,SAASC,WAAT,QAA4B,4BAA5B;AACA,SAASC,aAAT,QAA8B,mCAA9B;AACA,SAASC,gBAAT,QAAiC,+BAAjC;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,sBAAT,QAAuC,oCAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,qBAAT,CAA+BC,EAA/B,EAAmC;AAC/B,MAAIC,eAAe,GAAGD,EAAE,CAACC,eAAzB;AAAA,MAA0CC,mBAAmB,GAAGF,EAAE,CAACE,mBAAnE;AAAA,MAAwFC,SAAS,GAAGH,EAAE,CAACG,SAAvG;AAAA,MAAkHC,cAAc,GAAGJ,EAAE,CAACI,cAAtI;;AACA,WAASC,eAAT,CAAyBC,KAAzB,EAAgCC,WAAhC,EAA6C;AACzC;AACR;AACA;AACA;AACA;AACA;AACQ,QAAIC,QAAQ,GAAGlB,UAAU,CAACG,mBAAD,CAAV,CAAgCe,QAA/C;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA;AACR;AACA;AACA;;AACQ,QAAIC,OAAO,GAAGZ,sBAAsB,CAACQ,KAAD,EAAQE,QAAR,CAApC;AACA;AACR;AACA;;AACQ,QAAIG,WAAW,GAAGP,cAAc,CAACE,KAAD,EAAQE,QAAR,CAAhC;;AACA,QAAI,CAACA,QAAD,IAAa,OAAOI,MAAP,KAAkB,WAAnC,EAAgD;AAC5C;AACZ;AACA;AACA;AACA;AACA;AACYF,MAAAA,OAAO,CAACG,aAAR,GAAwBjB,gBAAgB,CAACY,QAAD,EAAWG,WAAX,EAAwBT,mBAAxB,EAA6CI,KAA7C,CAAxC;AACA;AACZ;AACA;AACA;AACA;AACA;AACA;;AACYG,MAAAA,QAAQ,GAAGf,WAAW,CAACO,eAAD,EAAkBS,OAAO,CAACG,aAA1B,EAAyCP,KAAzC,CAAtB;AACH;AACD;AACR;AACA;AACA;;;AACQ,WAAQf,aAAa,CAACC,QAAD,EAAW,IAAX,EACjBD,aAAa,CAACI,aAAa,CAACmB,QAAf,EAAyB;AAAEC,MAAAA,KAAK,EAAEL;AAAT,KAAzB,EAA6CP,SAAS,CAACG,KAAD,EAAQT,YAAY,CAACc,WAAD,EAAcD,OAAO,CAACG,aAAtB,EAAqCN,WAArC,CAApB,EAAuEI,WAAvE,EAAoFH,QAApF,CAAtD,CADI,EAEjBC,QAFiB,CAArB;AAGH;;AACD,SAAOpB,UAAU,CAACgB,eAAD,CAAjB;AACH;;AAED,SAASN,qBAAT","sourcesContent":["import { forwardRef, useContext, createElement, Fragment } from 'react';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\r\nimport { useFeatures } from './features/use-features.js';\r\nimport { MotionContext } from '../context/MotionContext/index.js';\r\nimport { useVisualElement } from './utils/use-visual-element.js';\r\nimport { useMotionRef } from './utils/use-motion-ref.js';\r\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n *\r\n * @internal\r\n */\r\nfunction createMotionComponent(_a) {\r\n    var defaultFeatures = _a.defaultFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState;\r\n    function MotionComponent(props, externalRef) {\r\n        /**\r\n         * If we're rendering in a static environment, we only visually update the component\r\n         * as a result of a React-rerender rather than interactions or animations. This\r\n         * means we don't need to load additional memory structures like VisualElement,\r\n         * or any gesture/animation features.\r\n         */\r\n        var isStatic = useContext(MotionConfigContext).isStatic;\r\n        var features = null;\r\n        /**\r\n         * Create the tree context. This is memoized and will only trigger renders\r\n         * when the current tree variant changes in static mode.\r\n         */\r\n        var context = useCreateMotionContext(props, isStatic);\r\n        /**\r\n         *\r\n         */\r\n        var visualState = useVisualState(props, isStatic);\r\n        if (!isStatic && typeof window !== \"undefined\") {\r\n            /**\r\n             * Create a VisualElement for this component. A VisualElement provides a common\r\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n             * providing a way of rendering to these APIs outside of the React render loop\r\n             * for more performant animations and interactions\r\n             */\r\n            context.visualElement = useVisualElement(isStatic, visualState, createVisualElement, props);\r\n            /**\r\n             * Load Motion gesture and animation features. These are rendered as renderless\r\n             * components so each feature can optionally make use of React lifecycle methods.\r\n             *\r\n             * TODO: The intention is to move these away from a React-centric to a\r\n             * VisualElement-centric lifecycle scheme.\r\n             */\r\n            features = useFeatures(defaultFeatures, context.visualElement, props);\r\n        }\r\n        /**\r\n         * The mount order and hierarchy is specific to ensure our element ref\r\n         * is hydrated by the time features fire their effects.\r\n         */\r\n        return (createElement(Fragment, null,\r\n            createElement(MotionContext.Provider, { value: context }, useRender(props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\r\n            features));\r\n    }\r\n    return forwardRef(MotionComponent);\r\n}\r\n\r\nexport { createMotionComponent };\r\n"]},"metadata":{},"sourceType":"module"}