{"ast":null,"code":"import { __assign } from 'tslib';\nimport { Presence } from '../types.js';\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\nimport { createCrossfader } from './crossfader.js';\n\nfunction layoutStack() {\n  var stack = new Set();\n  var state = {\n    leadIsExiting: false\n  };\n\n  var prevState = __assign({}, state);\n\n  var prevValues;\n  var prevViewportBox;\n  var prevDragCursor;\n  var crossfader = createCrossfader();\n  var needsCrossfadeAnimation = false;\n\n  function getFollowViewportBox() {\n    return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n  }\n\n  function getFollowLayout() {\n    var _a;\n\n    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n  }\n\n  return {\n    add: function (element) {\n      element.setCrossfader(crossfader);\n      stack.add(element);\n      /**\r\n       * Hydrate new element with previous drag position if we have one\r\n       */\n\n      if (prevDragCursor) element.prevDragCursor = prevDragCursor;\n      if (!state.lead) state.lead = element;\n    },\n    remove: function (element) {\n      stack.delete(element);\n    },\n    getLead: function () {\n      return state.lead;\n    },\n    updateSnapshot: function () {\n      if (!state.lead) return;\n      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();\n      prevViewportBox = state.lead.prevViewportBox;\n      var dragControls = elementDragControls.get(state.lead);\n\n      if (dragControls && dragControls.isDragging) {\n        prevDragCursor = dragControls.cursorProgress;\n      }\n    },\n    clearSnapshot: function () {\n      prevDragCursor = prevViewportBox = undefined;\n    },\n    updateLeadAndFollow: function () {\n      var _a;\n\n      prevState = __assign({}, state);\n      var lead;\n      var follow;\n      var order = Array.from(stack);\n\n      for (var i = order.length; i--; i >= 0) {\n        var element = order[i];\n        if (lead) follow !== null && follow !== void 0 ? follow : follow = element;\n        lead !== null && lead !== void 0 ? lead : lead = element;\n        if (lead && follow) break;\n      }\n\n      state.lead = lead;\n      state.follow = follow;\n      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n      crossfader.setOptions({\n        lead: lead,\n        follow: follow,\n        prevValues: prevValues,\n        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)\n      });\n\n      if (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting) {\n        needsCrossfadeAnimation = true;\n      }\n    },\n    animate: function (child, shouldCrossfade) {\n      if (shouldCrossfade === void 0) {\n        shouldCrossfade = false;\n      }\n\n      if (child === state.lead) {\n        if (shouldCrossfade) {\n          /**\r\n           * Point a lead to itself in case it was previously pointing\r\n           * to a different visual element\r\n           */\n          child.pointTo(state.lead);\n        } else {\n          child.setVisibility(true);\n        }\n\n        var config = {};\n\n        if (child.presence === Presence.Entering) {\n          config.originBox = getFollowViewportBox();\n        } else if (child.presence === Presence.Exiting) {\n          config.targetBox = getFollowLayout();\n        }\n\n        if (needsCrossfadeAnimation) {\n          needsCrossfadeAnimation = false;\n          var transition = child.getDefaultTransition();\n          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);\n        }\n\n        child.notifyLayoutReady(config);\n      } else {\n        if (shouldCrossfade) {\n          state.lead && child.pointTo(state.lead);\n        } else {\n          child.setVisibility(false);\n        }\n      }\n    }\n  };\n}\n\nexport { layoutStack };","map":{"version":3,"sources":["D:/Documents/GitHub/instafill/front-end/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js"],"names":["__assign","Presence","elementDragControls","createCrossfader","layoutStack","stack","Set","state","leadIsExiting","prevState","prevValues","prevViewportBox","prevDragCursor","crossfader","needsCrossfadeAnimation","getFollowViewportBox","follow","getFollowLayout","_a","getLayoutState","layout","add","element","setCrossfader","lead","remove","delete","getLead","updateSnapshot","isActive","getLatestValues","dragControls","get","isDragging","cursorProgress","clearSnapshot","undefined","updateLeadAndFollow","order","Array","from","i","length","presence","Exiting","setOptions","crossfadeOpacity","isPresenceRoot","animate","child","shouldCrossfade","pointTo","setVisibility","config","Entering","originBox","targetBox","transition","getDefaultTransition","toLead","fromLead","notifyLayoutReady"],"mappings":"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","sourcesContent":["import { __assign } from 'tslib';\r\nimport { Presence } from '../types.js';\r\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\r\nimport { createCrossfader } from './crossfader.js';\r\n\r\nfunction layoutStack() {\r\n    var stack = new Set();\r\n    var state = { leadIsExiting: false };\r\n    var prevState = __assign({}, state);\r\n    var prevValues;\r\n    var prevViewportBox;\r\n    var prevDragCursor;\r\n    var crossfader = createCrossfader();\r\n    var needsCrossfadeAnimation = false;\r\n    function getFollowViewportBox() {\r\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\r\n    }\r\n    function getFollowLayout() {\r\n        var _a;\r\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\r\n    }\r\n    return {\r\n        add: function (element) {\r\n            element.setCrossfader(crossfader);\r\n            stack.add(element);\r\n            /**\r\n             * Hydrate new element with previous drag position if we have one\r\n             */\r\n            if (prevDragCursor)\r\n                element.prevDragCursor = prevDragCursor;\r\n            if (!state.lead)\r\n                state.lead = element;\r\n        },\r\n        remove: function (element) {\r\n            stack.delete(element);\r\n        },\r\n        getLead: function () { return state.lead; },\r\n        updateSnapshot: function () {\r\n            if (!state.lead)\r\n                return;\r\n            prevValues = crossfader.isActive()\r\n                ? crossfader.getLatestValues()\r\n                : state.lead.getLatestValues();\r\n            prevViewportBox = state.lead.prevViewportBox;\r\n            var dragControls = elementDragControls.get(state.lead);\r\n            if (dragControls && dragControls.isDragging) {\r\n                prevDragCursor = dragControls.cursorProgress;\r\n            }\r\n        },\r\n        clearSnapshot: function () {\r\n            prevDragCursor = prevViewportBox = undefined;\r\n        },\r\n        updateLeadAndFollow: function () {\r\n            var _a;\r\n            prevState = __assign({}, state);\r\n            var lead;\r\n            var follow;\r\n            var order = Array.from(stack);\r\n            for (var i = order.length; i--; i >= 0) {\r\n                var element = order[i];\r\n                if (lead)\r\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\r\n                lead !== null && lead !== void 0 ? lead : (lead = element);\r\n                if (lead && follow)\r\n                    break;\r\n            }\r\n            state.lead = lead;\r\n            state.follow = follow;\r\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\r\n            crossfader.setOptions({\r\n                lead: lead,\r\n                follow: follow,\r\n                prevValues: prevValues,\r\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\r\n            });\r\n            if (prevState.lead !== state.lead ||\r\n                prevState.leadIsExiting !== state.leadIsExiting) {\r\n                needsCrossfadeAnimation = true;\r\n            }\r\n        },\r\n        animate: function (child, shouldCrossfade) {\r\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\r\n            if (child === state.lead) {\r\n                if (shouldCrossfade) {\r\n                    /**\r\n                     * Point a lead to itself in case it was previously pointing\r\n                     * to a different visual element\r\n                     */\r\n                    child.pointTo(state.lead);\r\n                }\r\n                else {\r\n                    child.setVisibility(true);\r\n                }\r\n                var config = {};\r\n                if (child.presence === Presence.Entering) {\r\n                    config.originBox = getFollowViewportBox();\r\n                }\r\n                else if (child.presence === Presence.Exiting) {\r\n                    config.targetBox = getFollowLayout();\r\n                }\r\n                if (needsCrossfadeAnimation) {\r\n                    needsCrossfadeAnimation = false;\r\n                    var transition = child.getDefaultTransition();\r\n                    child.presence === Presence.Entering\r\n                        ? crossfader.toLead(transition)\r\n                        : crossfader.fromLead(transition);\r\n                }\r\n                child.notifyLayoutReady(config);\r\n            }\r\n            else {\r\n                if (shouldCrossfade) {\r\n                    state.lead && child.pointTo(state.lead);\r\n                }\r\n                else {\r\n                    child.setVisibility(false);\r\n                }\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nexport { layoutStack };\r\n"]},"metadata":{},"sourceType":"module"}