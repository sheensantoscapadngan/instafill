{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\n\nvar PDFPageTree =\n/** @class */\nfunction (_super) {\n  __extends(PDFPageTree, _super);\n\n  function PDFPageTree() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PDFPageTree.prototype.Parent = function () {\n    return this.lookup(PDFName.of('Parent'));\n  };\n\n  PDFPageTree.prototype.Kids = function () {\n    return this.lookup(PDFName.of('Kids'), PDFArray);\n  };\n\n  PDFPageTree.prototype.Count = function () {\n    return this.lookup(PDFName.of('Count'), PDFNumber);\n  };\n\n  PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n    var Kids = this.Kids();\n    Kids.push(treeRef);\n  };\n\n  PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n    var Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  };\n  /**\r\n   * Inserts the given ref as a leaf node of this page tree at the specified\r\n   * index (zero-based). Also increments the `Count` of each page tree in the\r\n   * hierarchy to accomodate the new page.\r\n   *\r\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\r\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\r\n   * which the method was first called).\r\n   */\n\n\n  PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n\n    if (targetIndex > Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n\n    var leafsRemainingUntilTarget = targetIndex;\n\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n\n      if (kid instanceof PDFPageLeaf) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    } // Should never get here if `targetIndex` is valid\n\n\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  };\n  /**\r\n   * Removes the leaf node at the specified index (zero-based) from this page\r\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\r\n   * account for the removed page.\r\n   *\r\n   * If `prune` is true, then intermediate tree nodes will be removed from the\r\n   * tree if they contain 0 children after the leaf node is removed.\r\n   */\n\n\n  PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n    if (prune === void 0) {\n      prune = true;\n    }\n\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n\n    if (targetIndex >= Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n\n    var leafsRemainingUntilTarget = targetIndex;\n\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n\n      if (kid instanceof PDFPageLeaf) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    } // Should never get here if `targetIndex` is valid\n\n\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  };\n\n  PDFPageTree.prototype.ascend = function (visitor) {\n    visitor(this);\n    var Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  };\n  /** Performs a Post-Order traversal of this page tree */\n\n\n  PDFPageTree.prototype.traverse = function (visitor) {\n    var Kids = this.Kids();\n\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  };\n\n  PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n    var Kids = this.Kids();\n    this.ascend(function (node) {\n      var newCount = node.Count().asNumber() + 1;\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n    });\n    Kids.insert(kidIdx, leafRef);\n  };\n\n  PDFPageTree.prototype.removeKid = function (kidIdx) {\n    var Kids = this.Kids();\n    var kid = Kids.lookup(kidIdx);\n\n    if (kid instanceof PDFPageLeaf) {\n      this.ascend(function (node) {\n        var newCount = node.Count().asNumber() - 1;\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n      });\n    }\n\n    Kids.remove(kidIdx);\n  };\n\n  PDFPageTree.withContext = function (context, parent) {\n    var dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n    dict.set(PDFName.of('Kids'), context.obj([]));\n    dict.set(PDFName.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n\n  PDFPageTree.fromMapWithContext = function (map, context) {\n    return new PDFPageTree(map, context);\n  };\n\n  return PDFPageTree;\n}(PDFDict);\n\nexport default PDFPageTree;","map":{"version":3,"sources":["../../../src/core/structures/PDFPageTree.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\r\nimport PDFArray from \"../objects/PDFArray\";\r\nimport PDFDict from \"../objects/PDFDict\";\r\nimport PDFName from \"../objects/PDFName\";\r\nimport PDFNumber from \"../objects/PDFNumber\";\r\nimport PDFPageLeaf from \"./PDFPageLeaf\";\r\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\r\nvar PDFPageTree = /** @class */ (function (_super) {\r\n    __extends(PDFPageTree, _super);\r\n    function PDFPageTree() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PDFPageTree.prototype.Parent = function () {\r\n        return this.lookup(PDFName.of('Parent'));\r\n    };\r\n    PDFPageTree.prototype.Kids = function () {\r\n        return this.lookup(PDFName.of('Kids'), PDFArray);\r\n    };\r\n    PDFPageTree.prototype.Count = function () {\r\n        return this.lookup(PDFName.of('Count'), PDFNumber);\r\n    };\r\n    PDFPageTree.prototype.pushTreeNode = function (treeRef) {\r\n        var Kids = this.Kids();\r\n        Kids.push(treeRef);\r\n    };\r\n    PDFPageTree.prototype.pushLeafNode = function (leafRef) {\r\n        var Kids = this.Kids();\r\n        this.insertLeafKid(Kids.size(), leafRef);\r\n    };\r\n    /**\r\n     * Inserts the given ref as a leaf node of this page tree at the specified\r\n     * index (zero-based). Also increments the `Count` of each page tree in the\r\n     * hierarchy to accomodate the new page.\r\n     *\r\n     * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\r\n     * or `undefined` if it was inserted into the root node (the PDFPageTree upon\r\n     * which the method was first called).\r\n     */\r\n    PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\r\n        var Kids = this.Kids();\r\n        var Count = this.Count().asNumber();\r\n        if (targetIndex > Count) {\r\n            throw new InvalidTargetIndexError(targetIndex, Count);\r\n        }\r\n        var leafsRemainingUntilTarget = targetIndex;\r\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\r\n            if (leafsRemainingUntilTarget === 0) {\r\n                // Insert page and return\r\n                this.insertLeafKid(idx, leafRef);\r\n                return undefined;\r\n            }\r\n            var kidRef = Kids.get(idx);\r\n            var kid = this.context.lookup(kidRef);\r\n            if (kid instanceof PDFPageTree) {\r\n                if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\r\n                    // Dig in\r\n                    return (kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef);\r\n                }\r\n                else {\r\n                    // Move on\r\n                    leafsRemainingUntilTarget -= kid.Count().asNumber();\r\n                }\r\n            }\r\n            if (kid instanceof PDFPageLeaf) {\r\n                // Move on\r\n                leafsRemainingUntilTarget -= 1;\r\n            }\r\n        }\r\n        if (leafsRemainingUntilTarget === 0) {\r\n            // Insert page at the end and return\r\n            this.insertLeafKid(Kids.size(), leafRef);\r\n            return undefined;\r\n        }\r\n        // Should never get here if `targetIndex` is valid\r\n        throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\r\n    };\r\n    /**\r\n     * Removes the leaf node at the specified index (zero-based) from this page\r\n     * tree. Also decrements the `Count` of each page tree in the hierarchy to\r\n     * account for the removed page.\r\n     *\r\n     * If `prune` is true, then intermediate tree nodes will be removed from the\r\n     * tree if they contain 0 children after the leaf node is removed.\r\n     */\r\n    PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\r\n        if (prune === void 0) { prune = true; }\r\n        var Kids = this.Kids();\r\n        var Count = this.Count().asNumber();\r\n        if (targetIndex >= Count) {\r\n            throw new InvalidTargetIndexError(targetIndex, Count);\r\n        }\r\n        var leafsRemainingUntilTarget = targetIndex;\r\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\r\n            var kidRef = Kids.get(idx);\r\n            var kid = this.context.lookup(kidRef);\r\n            if (kid instanceof PDFPageTree) {\r\n                if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\r\n                    // Dig in\r\n                    kid.removeLeafNode(leafsRemainingUntilTarget, prune);\r\n                    if (prune && kid.Kids().size() === 0)\r\n                        Kids.remove(idx);\r\n                    return;\r\n                }\r\n                else {\r\n                    // Move on\r\n                    leafsRemainingUntilTarget -= kid.Count().asNumber();\r\n                }\r\n            }\r\n            if (kid instanceof PDFPageLeaf) {\r\n                if (leafsRemainingUntilTarget === 0) {\r\n                    // Remove page and return\r\n                    this.removeKid(idx);\r\n                    return;\r\n                }\r\n                else {\r\n                    // Move on\r\n                    leafsRemainingUntilTarget -= 1;\r\n                }\r\n            }\r\n        }\r\n        // Should never get here if `targetIndex` is valid\r\n        throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\r\n    };\r\n    PDFPageTree.prototype.ascend = function (visitor) {\r\n        visitor(this);\r\n        var Parent = this.Parent();\r\n        if (Parent)\r\n            Parent.ascend(visitor);\r\n    };\r\n    /** Performs a Post-Order traversal of this page tree */\r\n    PDFPageTree.prototype.traverse = function (visitor) {\r\n        var Kids = this.Kids();\r\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\r\n            var kidRef = Kids.get(idx);\r\n            var kid = this.context.lookup(kidRef);\r\n            if (kid instanceof PDFPageTree)\r\n                kid.traverse(visitor);\r\n            visitor(kid, kidRef);\r\n        }\r\n    };\r\n    PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\r\n        var Kids = this.Kids();\r\n        this.ascend(function (node) {\r\n            var newCount = node.Count().asNumber() + 1;\r\n            node.set(PDFName.of('Count'), PDFNumber.of(newCount));\r\n        });\r\n        Kids.insert(kidIdx, leafRef);\r\n    };\r\n    PDFPageTree.prototype.removeKid = function (kidIdx) {\r\n        var Kids = this.Kids();\r\n        var kid = Kids.lookup(kidIdx);\r\n        if (kid instanceof PDFPageLeaf) {\r\n            this.ascend(function (node) {\r\n                var newCount = node.Count().asNumber() - 1;\r\n                node.set(PDFName.of('Count'), PDFNumber.of(newCount));\r\n            });\r\n        }\r\n        Kids.remove(kidIdx);\r\n    };\r\n    PDFPageTree.withContext = function (context, parent) {\r\n        var dict = new Map();\r\n        dict.set(PDFName.of('Type'), PDFName.of('Pages'));\r\n        dict.set(PDFName.of('Kids'), context.obj([]));\r\n        dict.set(PDFName.of('Count'), context.obj(0));\r\n        if (parent)\r\n            dict.set(PDFName.of('Parent'), parent);\r\n        return new PDFPageTree(dict, context);\r\n    };\r\n    PDFPageTree.fromMapWithContext = function (map, context) {\r\n        return new PDFPageTree(map, context);\r\n    };\r\n    return PDFPageTree;\r\n}(PDFDict));\r\nexport default PDFPageTree;\r\n//# sourceMappingURL=PDFPageTree.js.map"]},"metadata":{},"sourceType":"module"}