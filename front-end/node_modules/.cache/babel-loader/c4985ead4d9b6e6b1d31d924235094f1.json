{"ast":null,"code":"import { __rest, __assign, __spread } from 'tslib';\nimport { resolveVariant } from './variants.js';\nimport { complex } from 'style-value-types';\nimport { findValueType, getAnimatableNone } from '../dom/utils/value-types.js';\nimport { isNumericalString } from '../../utils/is-numerical-string.js';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.js';\nimport { motionValue } from '../../value/index.js';\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\n\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\n\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n\n  var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n      _b = _a.transitionEnd,\n      transitionEnd = _b === void 0 ? {} : _b,\n      _c = _a.transition,\n      target = __rest(_a, [\"transitionEnd\", \"transition\"]);\n\n  target = __assign(__assign({}, target), transitionEnd);\n\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = __spread(variantLabels).reverse();\n\n  reversedLabels.forEach(function (key) {\n    var _a;\n\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b, _c;\n\n  var _d;\n\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\r\n     * If the target is a series of keyframes, we can use the first value\r\n     * in the array. If this first value is null, we'll still need to read from the DOM.\r\n     */\n\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\r\n     * If the target isn't keyframes, or the first keyframe was null, we need to\r\n     * first check if an origin value was explicitly defined in the transition as \"from\",\r\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\r\n     */\n\n\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\r\n     * If value is still undefined or null, ignore it. Preferably this would throw,\r\n     * but this was causing issues in Framer.\r\n     */\n\n\n    if (value === undefined || value === null) continue;\n\n    if (typeof value === \"string\" && isNumericalString(value)) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n\n    visualElement.addValue(key, motionValue(value));\n    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n    visualElement.setBaseTarget(key, value);\n  }\n}\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };","map":{"version":3,"sources":["D:/programming stuff i dont save on oneDrive/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/render/utils/setters.js"],"names":["__rest","__assign","__spread","resolveVariant","complex","findValueType","getAnimatableNone","isNumericalString","resolveFinalValueInKeyframes","motionValue","setMotionValue","visualElement","key","value","hasValue","getValue","set","addValue","setTarget","definition","resolved","_a","makeTargetAnimatable","_b","transitionEnd","_c","transition","target","setVariants","variantLabels","reversedLabels","reverse","forEach","variant","getVariant","variantChildren","child","setValues","Array","isArray","checkTargetForNewValues","origin","_d","newValueKeys","Object","keys","filter","numNewValues","length","i","targetValue","readValue","undefined","parseFloat","test","setBaseTarget","getOriginFromTransition","valueTransition","from","getOrigin","get"],"mappings":"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","sourcesContent":["import { __rest, __assign, __spread } from 'tslib';\r\nimport { resolveVariant } from './variants.js';\r\nimport { complex } from 'style-value-types';\r\nimport { findValueType, getAnimatableNone } from '../dom/utils/value-types.js';\r\nimport { isNumericalString } from '../../utils/is-numerical-string.js';\r\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.js';\r\nimport { motionValue } from '../../value/index.js';\r\n\r\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\r\nfunction setMotionValue(visualElement, key, value) {\r\n    if (visualElement.hasValue(key)) {\r\n        visualElement.getValue(key).set(value);\r\n    }\r\n    else {\r\n        visualElement.addValue(key, motionValue(value));\r\n    }\r\n}\r\nfunction setTarget(visualElement, definition) {\r\n    var resolved = resolveVariant(visualElement, definition);\r\n    var _a = resolved\r\n        ? visualElement.makeTargetAnimatable(resolved, false)\r\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b, _c = _a.transition, target = __rest(_a, [\"transitionEnd\", \"transition\"]);\r\n    target = __assign(__assign({}, target), transitionEnd);\r\n    for (var key in target) {\r\n        var value = resolveFinalValueInKeyframes(target[key]);\r\n        setMotionValue(visualElement, key, value);\r\n    }\r\n}\r\nfunction setVariants(visualElement, variantLabels) {\r\n    var reversedLabels = __spread(variantLabels).reverse();\r\n    reversedLabels.forEach(function (key) {\r\n        var _a;\r\n        var variant = visualElement.getVariant(key);\r\n        variant && setTarget(visualElement, variant);\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\r\n            setVariants(child, variantLabels);\r\n        });\r\n    });\r\n}\r\nfunction setValues(visualElement, definition) {\r\n    if (Array.isArray(definition)) {\r\n        return setVariants(visualElement, definition);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        return setVariants(visualElement, [definition]);\r\n    }\r\n    else {\r\n        setTarget(visualElement, definition);\r\n    }\r\n}\r\nfunction checkTargetForNewValues(visualElement, target, origin) {\r\n    var _a, _b, _c;\r\n    var _d;\r\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\r\n    var numNewValues = newValueKeys.length;\r\n    if (!numNewValues)\r\n        return;\r\n    for (var i = 0; i < numNewValues; i++) {\r\n        var key = newValueKeys[i];\r\n        var targetValue = target[key];\r\n        var value = null;\r\n        /**\r\n         * If the target is a series of keyframes, we can use the first value\r\n         * in the array. If this first value is null, we'll still need to read from the DOM.\r\n         */\r\n        if (Array.isArray(targetValue)) {\r\n            value = targetValue[0];\r\n        }\r\n        /**\r\n         * If the target isn't keyframes, or the first keyframe was null, we need to\r\n         * first check if an origin value was explicitly defined in the transition as \"from\",\r\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\r\n         */\r\n        if (value === null) {\r\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\r\n        }\r\n        /**\r\n         * If value is still undefined or null, ignore it. Preferably this would throw,\r\n         * but this was causing issues in Framer.\r\n         */\r\n        if (value === undefined || value === null)\r\n            continue;\r\n        if (typeof value === \"string\" && isNumericalString(value)) {\r\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n            value = parseFloat(value);\r\n        }\r\n        else if (!findValueType(value) && complex.test(targetValue)) {\r\n            value = getAnimatableNone(key, targetValue);\r\n        }\r\n        visualElement.addValue(key, motionValue(value));\r\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\r\n        visualElement.setBaseTarget(key, value);\r\n    }\r\n}\r\nfunction getOriginFromTransition(key, transition) {\r\n    if (!transition)\r\n        return;\r\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\r\n    return valueTransition.from;\r\n}\r\nfunction getOrigin(target, transition, visualElement) {\r\n    var _a, _b;\r\n    var origin = {};\r\n    for (var key in target) {\r\n        origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\r\n    }\r\n    return origin;\r\n}\r\n\r\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };\r\n"]},"metadata":{},"sourceType":"module"}