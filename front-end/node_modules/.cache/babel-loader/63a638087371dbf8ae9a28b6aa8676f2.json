{"ast":null,"code":"import { useEffect } from 'react';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.js';\nimport { isAnimationControls } from '../../animation/animation-controls.js';\nimport { createAnimationState } from '../../render/utils/animation-state.js';\nvar AnimationState = makeRenderlessComponent(function (props) {\n  var visualElement = props.visualElement,\n      animate = props.animate;\n  /**\n   * We dynamically generate the AnimationState manager as it contains a reference\n   * to the underlying animation library. We only want to load that if we load this,\n   * so people can optionally code split it out using the `m` component.\n   */\n\n  visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n  /**\n   * Subscribe any provided AnimationControls to the component's VisualElement\n   */\n\n  if (isAnimationControls(animate)) {\n    useEffect(function () {\n      return animate.subscribe(visualElement);\n    }, [animate]);\n  }\n});\n/**\n * @public\n */\n\nvar Animation = {\n  key: \"animation\",\n  shouldRender: function () {\n    return true;\n  },\n  getComponent: function (_a) {\n    var animate = _a.animate,\n        whileHover = _a.whileHover,\n        whileFocus = _a.whileFocus,\n        whileTap = _a.whileTap,\n        whileDrag = _a.whileDrag,\n        exit = _a.exit,\n        variants = _a.variants;\n    return animate || whileHover || whileFocus || whileTap || whileDrag || exit || variants ? AnimationState : undefined;\n  }\n};\nexport { Animation };","map":{"version":3,"sources":["F:/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/motion/features/animation.js"],"names":["useEffect","makeRenderlessComponent","isAnimationControls","createAnimationState","AnimationState","props","visualElement","animate","animationState","subscribe","Animation","key","shouldRender","getComponent","_a","whileHover","whileFocus","whileTap","whileDrag","exit","variants","undefined"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,SAASC,uBAAT,QAAwC,uCAAxC;AACA,SAASC,mBAAT,QAAoC,uCAApC;AACA,SAASC,oBAAT,QAAqC,uCAArC;AAEA,IAAIC,cAAc,GAAGH,uBAAuB,CAAC,UAAUI,KAAV,EAAiB;AAC1D,MAAIC,aAAa,GAAGD,KAAK,CAACC,aAA1B;AAAA,MAAyCC,OAAO,GAAGF,KAAK,CAACE,OAAzD;AACA;AACJ;AACA;AACA;AACA;;AACID,EAAAA,aAAa,CAACE,cAAd,KAAiCF,aAAa,CAACE,cAAd,GAA+BL,oBAAoB,CAACG,aAAD,CAApF;AACA;AACJ;AACA;;AACI,MAAIJ,mBAAmB,CAACK,OAAD,CAAvB,EAAkC;AAC9BP,IAAAA,SAAS,CAAC,YAAY;AAAE,aAAOO,OAAO,CAACE,SAAR,CAAkBH,aAAlB,CAAP;AAA0C,KAAzD,EAA2D,CAACC,OAAD,CAA3D,CAAT;AACH;AACJ,CAd2C,CAA5C;AAeA;AACA;AACA;;AACA,IAAIG,SAAS,GAAG;AACZC,EAAAA,GAAG,EAAE,WADO;AAEZC,EAAAA,YAAY,EAAE,YAAY;AAAE,WAAO,IAAP;AAAc,GAF9B;AAGZC,EAAAA,YAAY,EAAE,UAAUC,EAAV,EAAc;AACxB,QAAIP,OAAO,GAAGO,EAAE,CAACP,OAAjB;AAAA,QAA0BQ,UAAU,GAAGD,EAAE,CAACC,UAA1C;AAAA,QAAsDC,UAAU,GAAGF,EAAE,CAACE,UAAtE;AAAA,QAAkFC,QAAQ,GAAGH,EAAE,CAACG,QAAhG;AAAA,QAA0GC,SAAS,GAAGJ,EAAE,CAACI,SAAzH;AAAA,QAAoIC,IAAI,GAAGL,EAAE,CAACK,IAA9I;AAAA,QAAoJC,QAAQ,GAAGN,EAAE,CAACM,QAAlK;AACA,WAAOb,OAAO,IACVQ,UADG,IAEHC,UAFG,IAGHC,QAHG,IAIHC,SAJG,IAKHC,IALG,IAMHC,QANG,GAODhB,cAPC,GAQDiB,SARN;AASH;AAdW,CAAhB;AAiBA,SAASX,SAAT","sourcesContent":["import { useEffect } from 'react';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.js';\nimport { isAnimationControls } from '../../animation/animation-controls.js';\nimport { createAnimationState } from '../../render/utils/animation-state.js';\n\nvar AnimationState = makeRenderlessComponent(function (props) {\n    var visualElement = props.visualElement, animate = props.animate;\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    if (isAnimationControls(animate)) {\n        useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\n    }\n});\n/**\n * @public\n */\nvar Animation = {\n    key: \"animation\",\n    shouldRender: function () { return true; },\n    getComponent: function (_a) {\n        var animate = _a.animate, whileHover = _a.whileHover, whileFocus = _a.whileFocus, whileTap = _a.whileTap, whileDrag = _a.whileDrag, exit = _a.exit, variants = _a.variants;\n        return animate ||\n            whileHover ||\n            whileFocus ||\n            whileTap ||\n            whileDrag ||\n            exit ||\n            variants\n            ? AnimationState\n            : undefined;\n    },\n};\n\nexport { Animation };\n"]},"metadata":{},"sourceType":"module"}