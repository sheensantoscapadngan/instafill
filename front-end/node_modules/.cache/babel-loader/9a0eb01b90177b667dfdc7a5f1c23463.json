{"ast":null,"code":"import { mix, distance, clamp, progress } from 'popmotion';\n\nvar clampProgress = function (v) {\n  return clamp(0, 1, v);\n};\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\n\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return distance(value, target) < maxDistance;\n}\n\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\r\n * Currently this only accepts numerical origins, measured as 0-1, but could\r\n * accept pixel values by comparing to the target axis.\r\n */\n\n\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\n\nexport { calcOrigin, isNear, updateAxisDelta, updateBoxDelta };","map":{"version":3,"sources":["C:/Users/GAMER/OneDrive/Desktop/programming stuff/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js"],"names":["mix","distance","clamp","progress","clampProgress","v","isNear","value","target","maxDistance","calcLength","axis","max","min","calcOrigin","source","origin","sourceLength","targetLength","updateAxisDelta","delta","originPoint","scale","translate","updateBoxDelta","x","defaultOrigin","originX","y","originY"],"mappings":"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","sourcesContent":["import { mix, distance, clamp, progress } from 'popmotion';\r\n\r\nvar clampProgress = function (v) { return clamp(0, 1, v); };\r\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\r\nfunction isNear(value, target, maxDistance) {\r\n    if (target === void 0) { target = 0; }\r\n    if (maxDistance === void 0) { maxDistance = 0.01; }\r\n    return distance(value, target) < maxDistance;\r\n}\r\nfunction calcLength(axis) {\r\n    return axis.max - axis.min;\r\n}\r\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\r\nfunction calcOrigin(source, target) {\r\n    var origin = 0.5;\r\n    var sourceLength = calcLength(source);\r\n    var targetLength = calcLength(target);\r\n    if (targetLength > sourceLength) {\r\n        origin = progress(target.min, target.max - sourceLength, source.min);\r\n    }\r\n    else if (sourceLength > targetLength) {\r\n        origin = progress(source.min, source.max - targetLength, target.min);\r\n    }\r\n    return clampProgress(origin);\r\n}\r\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateAxisDelta(delta, source, target, origin) {\r\n    if (origin === void 0) { origin = 0.5; }\r\n    delta.origin = origin;\r\n    delta.originPoint = mix(source.min, source.max, delta.origin);\r\n    delta.scale = calcLength(target) / calcLength(source);\r\n    if (isNear(delta.scale, 1, 0.0001))\r\n        delta.scale = 1;\r\n    delta.translate =\r\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\r\n    if (isNear(delta.translate))\r\n        delta.translate = 0;\r\n}\r\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateBoxDelta(delta, source, target, origin) {\r\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\r\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\r\n}\r\n/**\r\n * Currently this only accepts numerical origins, measured as 0-1, but could\r\n * accept pixel values by comparing to the target axis.\r\n */\r\nfunction defaultOrigin(origin) {\r\n    return typeof origin === \"number\" ? origin : 0.5;\r\n}\r\n\r\nexport { calcOrigin, isNear, updateAxisDelta, updateBoxDelta };\r\n"]},"metadata":{},"sourceType":"module"}