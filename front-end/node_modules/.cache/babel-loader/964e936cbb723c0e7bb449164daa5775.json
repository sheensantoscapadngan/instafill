{"ast":null,"code":"import { toHexString } from \"./strings\";\n/**\r\n * Encodes a string to UTF-8.\r\n *\r\n * @param input The string to be encoded.\r\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\r\n *                      to the start of the encoding. (default `true`)\r\n * @returns A Uint8Array containing the UTF-8 encoding of the input string.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * JavaScript strings are composed of Unicode code points. Code points are\r\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\r\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\r\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\r\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\r\n * This function implements the UTF-8 encoding form.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * In UTF-8, each code point is mapped to a sequence of 1, 2, 3, or 4 bytes.\r\n * Note that the logic which defines this mapping is slightly convoluted, and\r\n * not as straightforward as the mapping logic for UTF-16 or UTF-32. The UTF-8\r\n * mapping logic is as follows [2]:\r\n *\r\n * â€¢ If a code point is in the range U+0000..U+007F, then view it as a 7-bit\r\n *   integer: 0bxxxxxxx. Map the code point to 1 byte with the first high order\r\n *   bit set to 0:\r\n *\r\n *       b1=0b0xxxxxxx\r\n *\r\n * â€¢ If a code point is in the range U+0080..U+07FF, then view it as an 11-bit\r\n *   integer: 0byyyyyxxxxxx. Map the code point to 2 bytes with the first 5 bits\r\n *   of the code point stored in the first byte, and the last 6 bits stored in\r\n *   the second byte:\r\n *\r\n *       b1=0b110yyyyy    b2=0b10xxxxxx\r\n *\r\n * â€¢ If a code point is in the range U+0800..U+FFFF, then view it as a 16-bit\r\n *   integer, 0bzzzzyyyyyyxxxxxx. Map the code point to 3 bytes with the first\r\n *   4 bits stored in the first byte, the next 6 bits stored in the second byte,\r\n *   and the last 6 bits in the third byte:\r\n *\r\n *       b1=0b1110zzzz    b2=0b10yyyyyy    b3=0b10xxxxxx\r\n *\r\n * â€¢ If a code point is in the range U+10000...U+10FFFF, then view it as a\r\n *   21-bit integer, 0bvvvzzzzzzyyyyyyxxxxxx. Map the code point to 4 bytes with\r\n *   the first 3 bits stored in the first byte, the next 6 bits stored in the\r\n *   second byte, the next 6 bits stored in the third byte, and the last 6 bits\r\n *   stored in the fourth byte:\r\n *\r\n *       b1=0b11110xxx    b2=0b10zzzzzz    b3=0b10yyyyyy    b4=0b10xxxxxx\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * It is important to note, when iterating through the code points of a string\r\n * in JavaScript, that if a character is encoded as a surrogate pair it will\r\n * increase the string's length by 2 instead of 1 [4]. For example:\r\n *\r\n * ```\r\n * > 'a'.length\r\n * 1\r\n * > 'ðŸ’©'.length\r\n * 2\r\n * > 'èªž'.length\r\n * 1\r\n * > 'aðŸ’©èªž'.length\r\n * 4\r\n * ```\r\n *\r\n * The results of the above example are explained by the fact that the\r\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\r\n *\r\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\r\n * we must \"jump\" an extra index after encoding a character as a surrogate\r\n * pair. In practice, this means we must increment the index of our for loop by\r\n * 2 if we encode a surrogate pair, and 1 in all other cases.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * References:\r\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\r\n *         3.9  Unicode Encoding Forms - UTF-8\r\n *   - [2] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding.html\r\n *   - [3] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding-Algorithm.html\r\n *   - [4] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\r\n *\r\n */\n\nexport var utf8Encode = function (input, byteOrderMark) {\n  if (byteOrderMark === void 0) {\n    byteOrderMark = true;\n  }\n\n  var encoded = [];\n  if (byteOrderMark) encoded.push(0xef, 0xbb, 0xbf);\n\n  for (var idx = 0, len = input.length; idx < len;) {\n    var codePoint = input.codePointAt(idx); // One byte encoding\n\n    if (codePoint < 0x80) {\n      var byte1 = codePoint & 0x7f;\n      encoded.push(byte1);\n      idx += 1;\n    } // Two byte encoding\n    else if (codePoint < 0x0800) {\n        var byte1 = codePoint >> 6 & 0x1f | 0xc0;\n        var byte2 = codePoint & 0x3f | 0x80;\n        encoded.push(byte1, byte2);\n        idx += 1;\n      } // Three byte encoding\n      else if (codePoint < 0x010000) {\n          var byte1 = codePoint >> 12 & 0x0f | 0xe0;\n          var byte2 = codePoint >> 6 & 0x3f | 0x80;\n          var byte3 = codePoint & 0x3f | 0x80;\n          encoded.push(byte1, byte2, byte3);\n          idx += 1;\n        } // Four byte encoding (surrogate pair)\n        else if (codePoint < 0x110000) {\n            var byte1 = codePoint >> 18 & 0x07 | 0xf0;\n            var byte2 = codePoint >> 12 & 0x3f | 0x80;\n            var byte3 = codePoint >> 6 & 0x3f | 0x80;\n            var byte4 = codePoint >> 0 & 0x3f | 0x80;\n            encoded.push(byte1, byte2, byte3, byte4);\n            idx += 2;\n          } // Should never reach this case\n          else throw new Error(\"Invalid code point: 0x\" + toHexString(codePoint));\n  }\n\n  return new Uint8Array(encoded);\n};\n/**\r\n * Encodes a string to UTF-16.\r\n *\r\n * @param input The string to be encoded.\r\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\r\n *                      to the start of the encoding. (default `true`)\r\n * @returns A Uint16Array containing the UTF-16 encoding of the input string.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * JavaScript strings are composed of Unicode code points. Code points are\r\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\r\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\r\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\r\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\r\n * This function implements the UTF-16 encoding form.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * In UTF-16, each code point is mapped to one or two 16-bit integers. The\r\n * UTF-16 mapping logic is as follows [2]:\r\n *\r\n * â€¢ If a code point is in the range U+0000..U+FFFF, then map the code point to\r\n *   a 16-bit integer with the most significant byte first.\r\n *\r\n * â€¢ If a code point is in the range U+10000..U+10000, then map the code point\r\n *   to two 16-bit integers. The first integer should contain the high surrogate\r\n *   and the second integer should contain the low surrogate. Both surrogates\r\n *   should be written with the most significant byte first.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * It is important to note, when iterating through the code points of a string\r\n * in JavaScript, that if a character is encoded as a surrogate pair it will\r\n * increase the string's length by 2 instead of 1 [4]. For example:\r\n *\r\n * ```\r\n * > 'a'.length\r\n * 1\r\n * > 'ðŸ’©'.length\r\n * 2\r\n * > 'èªž'.length\r\n * 1\r\n * > 'aðŸ’©èªž'.length\r\n * 4\r\n * ```\r\n *\r\n * The results of the above example are explained by the fact that the\r\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\r\n *\r\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\r\n * we must \"jump\" an extra index after encoding a character as a surrogate\r\n * pair. In practice, this means we must increment the index of our for loop by\r\n * 2 if we encode a surrogate pair, and 1 in all other cases.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * References:\r\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\r\n *         3.9  Unicode Encoding Forms - UTF-8\r\n *   - [2] http://www.herongyang.com/Unicode/UTF-16-UTF-16-Encoding.html\r\n *   - [3] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\r\n *\r\n */\n\nexport var utf16Encode = function (input, byteOrderMark) {\n  if (byteOrderMark === void 0) {\n    byteOrderMark = true;\n  }\n\n  var encoded = [];\n  if (byteOrderMark) encoded.push(0xfeff);\n\n  for (var idx = 0, len = input.length; idx < len;) {\n    var codePoint = input.codePointAt(idx); // Two byte encoding\n\n    if (codePoint < 0x010000) {\n      encoded.push(codePoint);\n      idx += 1;\n    } // Four byte encoding (surrogate pair)\n    else if (codePoint < 0x110000) {\n        encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));\n        idx += 2;\n      } // Should never reach this case\n      else throw new Error(\"Invalid code point: 0x\" + toHexString(codePoint));\n  }\n\n  return new Uint16Array(encoded);\n};\n/**\r\n * Returns `true` if the `codePoint` is within the\r\n * Basic Multilingual Plane (BMP). Code points inside the BMP are not encoded\r\n * with surrogate pairs.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\n\nexport var isWithinBMP = function (codePoint) {\n  return codePoint >= 0 && codePoint <= 0xffff;\n};\n/**\r\n * Returns `true` if the given `codePoint` is valid and must be represented\r\n * with a surrogate pair when encoded.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\n\nexport var hasSurrogates = function (codePoint) {\n  return codePoint >= 0x010000 && codePoint <= 0x10ffff;\n}; // From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\n\nexport var highSurrogate = function (codePoint) {\n  return Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;\n}; // From Unicode 3.0 spec, section 3.7:\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\n\nexport var lowSurrogate = function (codePoint) {\n  return (codePoint - 0x10000) % 0x400 + 0xdc00;\n};\nvar ByteOrder;\n\n(function (ByteOrder) {\n  ByteOrder[\"BigEndian\"] = \"BigEndian\";\n  ByteOrder[\"LittleEndian\"] = \"LittleEndian\";\n})(ByteOrder || (ByteOrder = {}));\n\nvar REPLACEMENT = 'ï¿½'.codePointAt(0);\n/**\r\n * Decodes a Uint8Array of data to a string using UTF-16.\r\n *\r\n * Note that this function attempts to recover from erronous input by\r\n * inserting the replacement character (ï¿½) to mark invalid code points\r\n * and surrogate pairs.\r\n *\r\n * @param input A Uint8Array containing UTF-16 encoded data\r\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be read\r\n *                      at the start of the encoding. (default `true`)\r\n * @returns The decoded string.\r\n */\n\nexport var utf16Decode = function (input, byteOrderMark) {\n  if (byteOrderMark === void 0) {\n    byteOrderMark = true;\n  } // Need at least 2 bytes of data in UTF-16 encodings\n\n\n  if (input.length <= 1) return String.fromCodePoint(REPLACEMENT);\n  var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian; // Skip byte order mark if needed\n\n  var idx = byteOrderMark ? 2 : 0;\n  var codePoints = [];\n\n  while (input.length - idx >= 2) {\n    var first = decodeValues(input[idx++], input[idx++], byteOrder);\n\n    if (isHighSurrogate(first)) {\n      if (input.length - idx < 2) {\n        // Need at least 2 bytes left for the low surrogate that is required\n        codePoints.push(REPLACEMENT);\n      } else {\n        var second = decodeValues(input[idx++], input[idx++], byteOrder);\n\n        if (isLowSurrogate(second)) {\n          codePoints.push(first, second);\n        } else {\n          // Low surrogates should always follow high surrogates\n          codePoints.push(REPLACEMENT);\n        }\n      }\n    } else if (isLowSurrogate(first)) {\n      // High surrogates should always come first since `decodeValues()`\n      // accounts for the byte ordering\n      idx += 2;\n      codePoints.push(REPLACEMENT);\n    } else {\n      codePoints.push(first);\n    }\n  } // There shouldn't be extra byte(s) left over\n\n\n  if (idx < input.length) codePoints.push(REPLACEMENT);\n  return String.fromCodePoint.apply(String, codePoints);\n};\n/**\r\n * Returns `true` if the given `codePoint` is a high surrogate.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\n\nvar isHighSurrogate = function (codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n};\n/**\r\n * Returns `true` if the given `codePoint` is a low surrogate.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\n\n\nvar isLowSurrogate = function (codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n};\n/**\r\n * Decodes the given utf-16 values first and second using the specified\r\n * byte order.\r\n * @param first The first byte of the encoding.\r\n * @param second The second byte of the encoding.\r\n * @param byteOrder The byte order of the encoding.\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Examples\r\n */\n\n\nvar decodeValues = function (first, second, byteOrder) {\n  // Append the binary representation of the preceding byte by shifting the\n  // first one 8 to the left and than applying a bitwise or-operator to append\n  // the second one.\n  if (byteOrder === ByteOrder.LittleEndian) return second << 8 | first;\n  if (byteOrder === ByteOrder.BigEndian) return first << 8 | second;\n  throw new Error(\"Invalid byteOrder: \" + byteOrder);\n};\n/**\r\n * Returns whether the given array contains a byte order mark for the\r\n * UTF-16BE or UTF-16LE encoding. If it has neither, BigEndian is assumed.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16\r\n *\r\n * @param bytes The byte array to be evaluated.\r\n */\n// prettier-ignore\n\n\nvar readBOM = function (bytes) {\n  return hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian : ByteOrder.BigEndian;\n};\n\nvar hasUtf16BigEndianBOM = function (bytes) {\n  return bytes[0] === 0xfe && bytes[1] === 0xff;\n};\n\nvar hasUtf16LittleEndianBOM = function (bytes) {\n  return bytes[0] === 0xff && bytes[1] === 0xfe;\n};\n\nexport var hasUtf16BOM = function (bytes) {\n  return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);\n};","map":{"version":3,"sources":["../../src/utils/unicode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { toHexString } from \"./strings\";\r\n/**\r\n * Encodes a string to UTF-8.\r\n *\r\n * @param input The string to be encoded.\r\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\r\n *                      to the start of the encoding. (default `true`)\r\n * @returns A Uint8Array containing the UTF-8 encoding of the input string.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * JavaScript strings are composed of Unicode code points. Code points are\r\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\r\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\r\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\r\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\r\n * This function implements the UTF-8 encoding form.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * In UTF-8, each code point is mapped to a sequence of 1, 2, 3, or 4 bytes.\r\n * Note that the logic which defines this mapping is slightly convoluted, and\r\n * not as straightforward as the mapping logic for UTF-16 or UTF-32. The UTF-8\r\n * mapping logic is as follows [2]:\r\n *\r\n * â€¢ If a code point is in the range U+0000..U+007F, then view it as a 7-bit\r\n *   integer: 0bxxxxxxx. Map the code point to 1 byte with the first high order\r\n *   bit set to 0:\r\n *\r\n *       b1=0b0xxxxxxx\r\n *\r\n * â€¢ If a code point is in the range U+0080..U+07FF, then view it as an 11-bit\r\n *   integer: 0byyyyyxxxxxx. Map the code point to 2 bytes with the first 5 bits\r\n *   of the code point stored in the first byte, and the last 6 bits stored in\r\n *   the second byte:\r\n *\r\n *       b1=0b110yyyyy    b2=0b10xxxxxx\r\n *\r\n * â€¢ If a code point is in the range U+0800..U+FFFF, then view it as a 16-bit\r\n *   integer, 0bzzzzyyyyyyxxxxxx. Map the code point to 3 bytes with the first\r\n *   4 bits stored in the first byte, the next 6 bits stored in the second byte,\r\n *   and the last 6 bits in the third byte:\r\n *\r\n *       b1=0b1110zzzz    b2=0b10yyyyyy    b3=0b10xxxxxx\r\n *\r\n * â€¢ If a code point is in the range U+10000...U+10FFFF, then view it as a\r\n *   21-bit integer, 0bvvvzzzzzzyyyyyyxxxxxx. Map the code point to 4 bytes with\r\n *   the first 3 bits stored in the first byte, the next 6 bits stored in the\r\n *   second byte, the next 6 bits stored in the third byte, and the last 6 bits\r\n *   stored in the fourth byte:\r\n *\r\n *       b1=0b11110xxx    b2=0b10zzzzzz    b3=0b10yyyyyy    b4=0b10xxxxxx\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * It is important to note, when iterating through the code points of a string\r\n * in JavaScript, that if a character is encoded as a surrogate pair it will\r\n * increase the string's length by 2 instead of 1 [4]. For example:\r\n *\r\n * ```\r\n * > 'a'.length\r\n * 1\r\n * > 'ðŸ’©'.length\r\n * 2\r\n * > 'èªž'.length\r\n * 1\r\n * > 'aðŸ’©èªž'.length\r\n * 4\r\n * ```\r\n *\r\n * The results of the above example are explained by the fact that the\r\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\r\n *\r\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\r\n * we must \"jump\" an extra index after encoding a character as a surrogate\r\n * pair. In practice, this means we must increment the index of our for loop by\r\n * 2 if we encode a surrogate pair, and 1 in all other cases.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * References:\r\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\r\n *         3.9  Unicode Encoding Forms - UTF-8\r\n *   - [2] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding.html\r\n *   - [3] http://www.herongyang.com/Unicode/UTF-8-UTF-8-Encoding-Algorithm.html\r\n *   - [4] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\r\n *\r\n */\r\nexport var utf8Encode = function (input, byteOrderMark) {\r\n    if (byteOrderMark === void 0) { byteOrderMark = true; }\r\n    var encoded = [];\r\n    if (byteOrderMark)\r\n        encoded.push(0xef, 0xbb, 0xbf);\r\n    for (var idx = 0, len = input.length; idx < len;) {\r\n        var codePoint = input.codePointAt(idx);\r\n        // One byte encoding\r\n        if (codePoint < 0x80) {\r\n            var byte1 = codePoint & 0x7f;\r\n            encoded.push(byte1);\r\n            idx += 1;\r\n        }\r\n        // Two byte encoding\r\n        else if (codePoint < 0x0800) {\r\n            var byte1 = ((codePoint >> 6) & 0x1f) | 0xc0;\r\n            var byte2 = (codePoint & 0x3f) | 0x80;\r\n            encoded.push(byte1, byte2);\r\n            idx += 1;\r\n        }\r\n        // Three byte encoding\r\n        else if (codePoint < 0x010000) {\r\n            var byte1 = ((codePoint >> 12) & 0x0f) | 0xe0;\r\n            var byte2 = ((codePoint >> 6) & 0x3f) | 0x80;\r\n            var byte3 = (codePoint & 0x3f) | 0x80;\r\n            encoded.push(byte1, byte2, byte3);\r\n            idx += 1;\r\n        }\r\n        // Four byte encoding (surrogate pair)\r\n        else if (codePoint < 0x110000) {\r\n            var byte1 = ((codePoint >> 18) & 0x07) | 0xf0;\r\n            var byte2 = ((codePoint >> 12) & 0x3f) | 0x80;\r\n            var byte3 = ((codePoint >> 6) & 0x3f) | 0x80;\r\n            var byte4 = ((codePoint >> 0) & 0x3f) | 0x80;\r\n            encoded.push(byte1, byte2, byte3, byte4);\r\n            idx += 2;\r\n        }\r\n        // Should never reach this case\r\n        else\r\n            throw new Error(\"Invalid code point: 0x\" + toHexString(codePoint));\r\n    }\r\n    return new Uint8Array(encoded);\r\n};\r\n/**\r\n * Encodes a string to UTF-16.\r\n *\r\n * @param input The string to be encoded.\r\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be added\r\n *                      to the start of the encoding. (default `true`)\r\n * @returns A Uint16Array containing the UTF-16 encoding of the input string.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * JavaScript strings are composed of Unicode code points. Code points are\r\n * integers in the range 0 to 1,114,111 (0x10FFFF). When serializing a string,\r\n * it must be encoded as a sequence of words. A word is typically 8, 16, or 32\r\n * bytes in size. As such, Unicode defines three encoding forms: UTF-8, UTF-16,\r\n * and UTF-32. These encoding forms are described in the Unicode standard [1].\r\n * This function implements the UTF-16 encoding form.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * In UTF-16, each code point is mapped to one or two 16-bit integers. The\r\n * UTF-16 mapping logic is as follows [2]:\r\n *\r\n * â€¢ If a code point is in the range U+0000..U+FFFF, then map the code point to\r\n *   a 16-bit integer with the most significant byte first.\r\n *\r\n * â€¢ If a code point is in the range U+10000..U+10000, then map the code point\r\n *   to two 16-bit integers. The first integer should contain the high surrogate\r\n *   and the second integer should contain the low surrogate. Both surrogates\r\n *   should be written with the most significant byte first.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * It is important to note, when iterating through the code points of a string\r\n * in JavaScript, that if a character is encoded as a surrogate pair it will\r\n * increase the string's length by 2 instead of 1 [4]. For example:\r\n *\r\n * ```\r\n * > 'a'.length\r\n * 1\r\n * > 'ðŸ’©'.length\r\n * 2\r\n * > 'èªž'.length\r\n * 1\r\n * > 'aðŸ’©èªž'.length\r\n * 4\r\n * ```\r\n *\r\n * The results of the above example are explained by the fact that the\r\n * characters 'a' and 'èªž' are not represented by surrogate pairs, but 'ðŸ’©' is.\r\n *\r\n * Because of this idiosyncrasy in JavaScript's string implementation and APIs,\r\n * we must \"jump\" an extra index after encoding a character as a surrogate\r\n * pair. In practice, this means we must increment the index of our for loop by\r\n * 2 if we encode a surrogate pair, and 1 in all other cases.\r\n *\r\n * -----------------------------------------------------------------------------\r\n *\r\n * References:\r\n *   - [1] https://www.unicode.org/versions/Unicode12.0.0/UnicodeStandard-12.0.pdf\r\n *         3.9  Unicode Encoding Forms - UTF-8\r\n *   - [2] http://www.herongyang.com/Unicode/UTF-16-UTF-16-Encoding.html\r\n *   - [3] https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description\r\n *\r\n */\r\nexport var utf16Encode = function (input, byteOrderMark) {\r\n    if (byteOrderMark === void 0) { byteOrderMark = true; }\r\n    var encoded = [];\r\n    if (byteOrderMark)\r\n        encoded.push(0xfeff);\r\n    for (var idx = 0, len = input.length; idx < len;) {\r\n        var codePoint = input.codePointAt(idx);\r\n        // Two byte encoding\r\n        if (codePoint < 0x010000) {\r\n            encoded.push(codePoint);\r\n            idx += 1;\r\n        }\r\n        // Four byte encoding (surrogate pair)\r\n        else if (codePoint < 0x110000) {\r\n            encoded.push(highSurrogate(codePoint), lowSurrogate(codePoint));\r\n            idx += 2;\r\n        }\r\n        // Should never reach this case\r\n        else\r\n            throw new Error(\"Invalid code point: 0x\" + toHexString(codePoint));\r\n    }\r\n    return new Uint16Array(encoded);\r\n};\r\n/**\r\n * Returns `true` if the `codePoint` is within the\r\n * Basic Multilingual Plane (BMP). Code points inside the BMP are not encoded\r\n * with surrogate pairs.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\r\nexport var isWithinBMP = function (codePoint) {\r\n    return codePoint >= 0 && codePoint <= 0xffff;\r\n};\r\n/**\r\n * Returns `true` if the given `codePoint` is valid and must be represented\r\n * with a surrogate pair when encoded.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\r\nexport var hasSurrogates = function (codePoint) {\r\n    return codePoint >= 0x010000 && codePoint <= 0x10ffff;\r\n};\r\n// From Unicode 3.0 spec, section 3.7:\r\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\r\nexport var highSurrogate = function (codePoint) {\r\n    return Math.floor((codePoint - 0x10000) / 0x400) + 0xd800;\r\n};\r\n// From Unicode 3.0 spec, section 3.7:\r\n//   http://unicode.org/versions/Unicode3.0.0/ch03.pdf\r\nexport var lowSurrogate = function (codePoint) {\r\n    return ((codePoint - 0x10000) % 0x400) + 0xdc00;\r\n};\r\nvar ByteOrder;\r\n(function (ByteOrder) {\r\n    ByteOrder[\"BigEndian\"] = \"BigEndian\";\r\n    ByteOrder[\"LittleEndian\"] = \"LittleEndian\";\r\n})(ByteOrder || (ByteOrder = {}));\r\nvar REPLACEMENT = 'ï¿½'.codePointAt(0);\r\n/**\r\n * Decodes a Uint8Array of data to a string using UTF-16.\r\n *\r\n * Note that this function attempts to recover from erronous input by\r\n * inserting the replacement character (ï¿½) to mark invalid code points\r\n * and surrogate pairs.\r\n *\r\n * @param input A Uint8Array containing UTF-16 encoded data\r\n * @param byteOrderMark Whether or not a byte order marker (BOM) should be read\r\n *                      at the start of the encoding. (default `true`)\r\n * @returns The decoded string.\r\n */\r\nexport var utf16Decode = function (input, byteOrderMark) {\r\n    if (byteOrderMark === void 0) { byteOrderMark = true; }\r\n    // Need at least 2 bytes of data in UTF-16 encodings\r\n    if (input.length <= 1)\r\n        return String.fromCodePoint(REPLACEMENT);\r\n    var byteOrder = byteOrderMark ? readBOM(input) : ByteOrder.BigEndian;\r\n    // Skip byte order mark if needed\r\n    var idx = byteOrderMark ? 2 : 0;\r\n    var codePoints = [];\r\n    while (input.length - idx >= 2) {\r\n        var first = decodeValues(input[idx++], input[idx++], byteOrder);\r\n        if (isHighSurrogate(first)) {\r\n            if (input.length - idx < 2) {\r\n                // Need at least 2 bytes left for the low surrogate that is required\r\n                codePoints.push(REPLACEMENT);\r\n            }\r\n            else {\r\n                var second = decodeValues(input[idx++], input[idx++], byteOrder);\r\n                if (isLowSurrogate(second)) {\r\n                    codePoints.push(first, second);\r\n                }\r\n                else {\r\n                    // Low surrogates should always follow high surrogates\r\n                    codePoints.push(REPLACEMENT);\r\n                }\r\n            }\r\n        }\r\n        else if (isLowSurrogate(first)) {\r\n            // High surrogates should always come first since `decodeValues()`\r\n            // accounts for the byte ordering\r\n            idx += 2;\r\n            codePoints.push(REPLACEMENT);\r\n        }\r\n        else {\r\n            codePoints.push(first);\r\n        }\r\n    }\r\n    // There shouldn't be extra byte(s) left over\r\n    if (idx < input.length)\r\n        codePoints.push(REPLACEMENT);\r\n    return String.fromCodePoint.apply(String, codePoints);\r\n};\r\n/**\r\n * Returns `true` if the given `codePoint` is a high surrogate.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\r\nvar isHighSurrogate = function (codePoint) {\r\n    return codePoint >= 0xd800 && codePoint <= 0xdbff;\r\n};\r\n/**\r\n * Returns `true` if the given `codePoint` is a low surrogate.\r\n * @param codePoint The code point to be evaluated.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Description\r\n */\r\nvar isLowSurrogate = function (codePoint) {\r\n    return codePoint >= 0xdc00 && codePoint <= 0xdfff;\r\n};\r\n/**\r\n * Decodes the given utf-16 values first and second using the specified\r\n * byte order.\r\n * @param first The first byte of the encoding.\r\n * @param second The second byte of the encoding.\r\n * @param byteOrder The byte order of the encoding.\r\n * Reference: https://en.wikipedia.org/wiki/UTF-16#Examples\r\n */\r\nvar decodeValues = function (first, second, byteOrder) {\r\n    // Append the binary representation of the preceding byte by shifting the\r\n    // first one 8 to the left and than applying a bitwise or-operator to append\r\n    // the second one.\r\n    if (byteOrder === ByteOrder.LittleEndian)\r\n        return (second << 8) | first;\r\n    if (byteOrder === ByteOrder.BigEndian)\r\n        return (first << 8) | second;\r\n    throw new Error(\"Invalid byteOrder: \" + byteOrder);\r\n};\r\n/**\r\n * Returns whether the given array contains a byte order mark for the\r\n * UTF-16BE or UTF-16LE encoding. If it has neither, BigEndian is assumed.\r\n *\r\n * Reference: https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16\r\n *\r\n * @param bytes The byte array to be evaluated.\r\n */\r\n// prettier-ignore\r\nvar readBOM = function (bytes) { return (hasUtf16BigEndianBOM(bytes) ? ByteOrder.BigEndian\r\n    : hasUtf16LittleEndianBOM(bytes) ? ByteOrder.LittleEndian\r\n        : ByteOrder.BigEndian); };\r\nvar hasUtf16BigEndianBOM = function (bytes) {\r\n    return bytes[0] === 0xfe && bytes[1] === 0xff;\r\n};\r\nvar hasUtf16LittleEndianBOM = function (bytes) {\r\n    return bytes[0] === 0xff && bytes[1] === 0xfe;\r\n};\r\nexport var hasUtf16BOM = function (bytes) {\r\n    return hasUtf16BigEndianBOM(bytes) || hasUtf16LittleEndianBOM(bytes);\r\n};\r\n//# sourceMappingURL=unicode.js.map"]},"metadata":{},"sourceType":"module"}