{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFPage from \"../PDFPage\";\nimport PDFFont from \"../PDFFont\";\nimport PDFField, { assertFieldAppearanceOptions } from \"./PDFField\";\nimport { normalizeAppearance, defaultTextFieldAppearanceProvider } from \"./appearances\";\nimport { rgb } from \"../colors\";\nimport { degrees } from \"../rotations\";\nimport { RichTextFieldReadError, ExceededMaxLengthError, InvalidMaxLengthError } from \"../errors\";\nimport { ImageAlignment } from \"../image/alignment\";\nimport { TextAlignment } from \"../text/alignment\";\nimport { PDFHexString, PDFStream, PDFAcroText, AcroTextFlags } from \"../../core\";\nimport { assertIs, assertIsOneOf, assertOrUndefined, assertPositive, assertRangeOrUndefined } from \"../../utils\";\n/**\r\n * Represents a text field of a [[PDFForm]].\r\n *\r\n * [[PDFTextField]] fields are boxes that display text entered by the user. The\r\n * purpose of a text field is to enable users to enter text or view text values\r\n * in the document prefilled by software. Users can click on a text field and\r\n * input text via their keyboard. Some text fields allow multiple lines of text\r\n * to be entered (see [[PDFTextField.isMultiline]]).\r\n */\n\nvar PDFTextField =\n/** @class */\nfunction (_super) {\n  __extends(PDFTextField, _super);\n\n  function PDFTextField(acroText, ref, doc) {\n    var _this = _super.call(this, acroText, ref, doc) || this;\n\n    assertIs(acroText, 'acroText', [[PDFAcroText, 'PDFAcroText']]);\n    _this.acroField = acroText;\n    return _this;\n  }\n  /**\r\n   * Get the text that this field contains. This text is visible to users who\r\n   * view this field in a PDF reader.\r\n   *\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * const text = textField.getText()\r\n   * console.log('Text field contents:', text)\r\n   * ```\r\n   *\r\n   * Note that if this text field contains no underlying value, `undefined`\r\n   * will be returned. Text fields may also contain an underlying value that\r\n   * is simply an empty string (`''`). This detail is largely irrelevant for\r\n   * most applications. In general, you'll want to treat both cases the same\r\n   * way and simply consider the text field to be empty. In either case, the\r\n   * text field will appear empty to users when viewed in a PDF reader.\r\n   *\r\n   * An error will be thrown if this is a rich text field. `pdf-lib` does not\r\n   * support reading rich text fields. Nor do most PDF readers and writers.\r\n   * Rich text fields are based on XFA (XML Forms Architecture). Relatively few\r\n   * PDFs use rich text fields or XFA. Unlike PDF itself, XFA is not an ISO\r\n   * standard. XFA has been deprecated in PDF 2.0:\r\n   * * https://en.wikipedia.org/wiki/XFA\r\n   * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\r\n   *\r\n   * @returns The text contained in this text field.\r\n   */\n\n\n  PDFTextField.prototype.getText = function () {\n    var value = this.acroField.getValue();\n\n    if (!value && this.isRichFormatted()) {\n      throw new RichTextFieldReadError(this.getName());\n    }\n\n    return value === null || value === void 0 ? void 0 : value.decodeText();\n  };\n  /**\r\n   * Set the text for this field. This operation is analogous to a human user\r\n   * clicking on the text field in a PDF reader and typing in text via their\r\n   * keyboard. This method will update the underlying state of the text field\r\n   * to indicate what text has been set. PDF libraries and readers will be able\r\n   * to extract these values from the saved document and determine what text\r\n   * was set.\r\n   *\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('best.superhero.text.field')\r\n   * textField.setText('One Punch Man')\r\n   * ```\r\n   *\r\n   * This method will mark this text field as dirty, causing its appearance\r\n   * streams to be updated when either [[PDFDocument.save]] or\r\n   * [[PDFForm.updateFieldAppearances]] is called. The updated streams will\r\n   * display the text this field contains inside the widgets of this text\r\n   * field.\r\n   *\r\n   * **IMPORTANT:** The default font used to update appearance streams is\r\n   * [[StandardFonts.Helvetica]]. Note that this is a WinAnsi font. This means\r\n   * that encoding errors will be thrown if this field contains text outside\r\n   * the WinAnsi character set (the latin alphabet).\r\n   *\r\n   * Embedding a custom font and passing it to\r\n   * [[PDFForm.updateFieldAppearances]] or [[PDFTextField.updateAppearances]]\r\n   * allows you to generate appearance streams with characters outside the\r\n   * latin alphabet (assuming the custom font supports them).\r\n   *\r\n   * If this is a rich text field, it will be converted to a standard text\r\n   * field in order to set the text. `pdf-lib` does not support writing rich\r\n   * text strings. Nor do most PDF readers and writers. See\r\n   * [[PDFTextField.getText]] for more information about rich text fields and\r\n   * their deprecation in PDF 2.0.\r\n   *\r\n   * @param text The text this field should contain.\r\n   */\n\n\n  PDFTextField.prototype.setText = function (text) {\n    assertOrUndefined(text, 'text', ['string']);\n    var maxLength = this.getMaxLength();\n\n    if (maxLength !== undefined && text && text.length > maxLength) {\n      throw new ExceededMaxLengthError(text.length, maxLength, this.getName());\n    }\n\n    this.markAsDirty();\n    this.disableRichFormatting();\n\n    if (text) {\n      this.acroField.setValue(PDFHexString.fromText(text));\n    } else {\n      this.acroField.removeValue();\n    }\n  };\n  /**\r\n   * Get the alignment for this text field. This value represents the\r\n   * justification of the text when it is displayed to the user in PDF readers.\r\n   * There are three possible alignments: left, center, and right. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * const alignment = textField.getAlignment()\r\n   * if (alignment === TextAlignment.Left) console.log('Text is left justified')\r\n   * if (alignment === TextAlignment.Center) console.log('Text is centered')\r\n   * if (alignment === TextAlignment.Right) console.log('Text is right justified')\r\n   * ```\r\n   * @returns The alignment of this text field.\r\n   */\n\n\n  PDFTextField.prototype.getAlignment = function () {\n    var quadding = this.acroField.getQuadding(); // prettier-ignore\n\n    return quadding === 0 ? TextAlignment.Left : quadding === 1 ? TextAlignment.Center : quadding === 2 ? TextAlignment.Right : TextAlignment.Left;\n  };\n  /**\r\n   * Set the alignment for this text field. This will determine the\r\n   * justification of the text when it is displayed to the user in PDF readers.\r\n   * There are three possible alignments: left, center, and right. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   *\r\n   * // Text will be left justified when displayed\r\n   * textField.setAlignment(TextAlignment.Left)\r\n   *\r\n   * // Text will be centered when displayed\r\n   * textField.setAlignment(TextAlignment.Center)\r\n   *\r\n   * // Text will be right justified when displayed\r\n   * textField.setAlignment(TextAlignment.Right)\r\n   * ```\r\n   * This method will mark this text field as dirty. See\r\n   * [[PDFTextField.setText]] for more details about what this means.\r\n   * @param alignment The alignment for this text field.\r\n   */\n\n\n  PDFTextField.prototype.setAlignment = function (alignment) {\n    assertIsOneOf(alignment, 'alignment', TextAlignment);\n    this.markAsDirty();\n    this.acroField.setQuadding(alignment);\n  };\n  /**\r\n   * Get the maximum length of this field. This value represents the maximum\r\n   * number of characters that can be typed into this field by the user. If\r\n   * this field does not have a maximum length, `undefined` is returned.\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * const maxLength = textField.getMaxLength()\r\n   * if (maxLength === undefined) console.log('No max length')\r\n   * else console.log(`Max length is ${maxLength}`)\r\n   * ```\r\n   * @returns The maximum number of characters allowed in this field, or\r\n   *          `undefined` if no limit exists.\r\n   */\n\n\n  PDFTextField.prototype.getMaxLength = function () {\n    return this.acroField.getMaxLength();\n  };\n  /**\r\n   * Set the maximum length of this field. This limits the number of characters\r\n   * that can be typed into this field by the user. This also limits the length\r\n   * of the string that can be passed to [[PDFTextField.setText]]. This limit\r\n   * can be removed by passing `undefined` as `maxLength`. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   *\r\n   * // Allow between 0 and 5 characters to be entered\r\n   * textField.setMaxLength(5)\r\n   *\r\n   * // Allow any number of characters to be entered\r\n   * textField.setMaxLength(undefined)\r\n   * ```\r\n   * This method will mark this text field as dirty. See\r\n   * [[PDFTextField.setText]] for more details about what this means.\r\n   * @param maxLength The maximum number of characters allowed in this field, or\r\n   *                  `undefined` to remove the limit.\r\n   */\n\n\n  PDFTextField.prototype.setMaxLength = function (maxLength) {\n    assertRangeOrUndefined(maxLength, 'maxLength', 0, Number.MAX_SAFE_INTEGER);\n    this.markAsDirty();\n\n    if (maxLength === undefined) {\n      this.acroField.removeMaxLength();\n    } else {\n      var text = this.getText();\n\n      if (text && text.length > maxLength) {\n        throw new InvalidMaxLengthError(text.length, maxLength, this.getName());\n      }\n\n      this.acroField.setMaxLength(maxLength);\n    }\n  };\n  /**\r\n   * Remove the maximum length for this text field. This allows any number of\r\n   * characters to be typed into this field by the user. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.removeMaxLength()\r\n   * ```\r\n   * Calling this method is equivalent to passing `undefined` to\r\n   * [[PDFTextField.setMaxLength]].\r\n   */\n\n\n  PDFTextField.prototype.removeMaxLength = function () {\n    this.markAsDirty();\n    this.acroField.removeMaxLength();\n  };\n  /**\r\n   * Display an image inside the bounds of this text field's widgets. For example:\r\n   * ```js\r\n   * const pngImage = await pdfDoc.embedPng(...)\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.setImage(pngImage)\r\n   * ```\r\n   * This will update the appearances streams for each of this text field's widgets.\r\n   * @param image The image that should be displayed.\r\n   */\n\n\n  PDFTextField.prototype.setImage = function (image) {\n    var fieldAlignment = this.getAlignment(); // prettier-ignore\n\n    var alignment = fieldAlignment === TextAlignment.Center ? ImageAlignment.Center : fieldAlignment === TextAlignment.Right ? ImageAlignment.Right : ImageAlignment.Left;\n    var widgets = this.acroField.getWidgets();\n\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      var streamRef = this.createImageAppearanceStream(widget, image, alignment);\n      this.updateWidgetAppearances(widget, {\n        normal: streamRef\n      });\n    }\n\n    this.markAsClean();\n  };\n  /**\r\n   * Set the font size for this field. Larger font sizes will result in larger\r\n   * text being displayed when PDF readers render this text field. Font sizes\r\n   * may be integer or floating point numbers. Supplying a negative font size\r\n   * will cause this method to throw an error.\r\n   *\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.setFontSize(4)\r\n   * textField.setFontSize(15.7)\r\n   * ```\r\n   *\r\n   * > This method depends upon the existence of a default appearance\r\n   * > (`/DA`) string. If this field does not have a default appearance string,\r\n   * > or that string does not contain a font size (via the `Tf` operator),\r\n   * > then this method will throw an error.\r\n   *\r\n   * @param fontSize The font size to be used when rendering text in this field.\r\n   */\n\n\n  PDFTextField.prototype.setFontSize = function (fontSize) {\n    assertPositive(fontSize, 'fontSize');\n    this.acroField.setFontSize(fontSize);\n    this.markAsDirty();\n  };\n  /**\r\n   * Returns `true` if each line of text is shown on a new line when this\r\n   * field is displayed in a PDF reader. The alternative is that all lines of\r\n   * text are merged onto a single line when displayed. See\r\n   * [[PDFTextField.enableMultiline]] and [[PDFTextField.disableMultiline]].\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isMultiline()) console.log('Multiline is enabled')\r\n   * ```\r\n   * @returns Whether or not this is a multiline text field.\r\n   */\n\n\n  PDFTextField.prototype.isMultiline = function () {\n    return this.acroField.hasFlag(AcroTextFlags.Multiline);\n  };\n  /**\r\n   * Display each line of text on a new line when this field is displayed in a\r\n   * PDF reader. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enableMultiline()\r\n   * ```\r\n   * This method will mark this text field as dirty. See\r\n   * [[PDFTextField.setText]] for more details about what this means.\r\n   */\n\n\n  PDFTextField.prototype.enableMultiline = function () {\n    this.markAsDirty();\n    this.acroField.setFlagTo(AcroTextFlags.Multiline, true);\n  };\n  /**\r\n   * Display each line of text on the same line when this field is displayed\r\n   * in a PDF reader. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disableMultiline()\r\n   * ```\r\n   * This method will mark this text field as dirty. See\r\n   * [[PDFTextField.setText]] for more details about what this means.\r\n   */\n\n\n  PDFTextField.prototype.disableMultiline = function () {\n    this.markAsDirty();\n    this.acroField.setFlagTo(AcroTextFlags.Multiline, false);\n  };\n  /**\r\n   * Returns `true` if this is a password text field. This means that the field\r\n   * is intended for storing a secure password. See\r\n   * [[PDFTextField.enablePassword]] and [[PDFTextField.disablePassword]].\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isPassword()) console.log('Password is enabled')\r\n   * ```\r\n   * @returns Whether or not this is a password text field.\r\n   */\n\n\n  PDFTextField.prototype.isPassword = function () {\n    return this.acroField.hasFlag(AcroTextFlags.Password);\n  };\n  /**\r\n   * Indicate that this text field is intended for storing a secure password.\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enablePassword()\r\n   * ```\r\n   * Values entered into password text fields should not be displayed on the\r\n   * screen by PDF readers. Most PDF readers will display the value as\r\n   * asterisks or bullets. PDF readers should never store values entered by the\r\n   * user into password text fields. Similarly, applications should not\r\n   * write data to a password text field.\r\n   *\r\n   * **Please note that this method does not cause entered values to be\r\n   * encrypted or secured in any way! It simply sets a flag that PDF software\r\n   * and readers can access to determine the _purpose_ of this field.**\r\n   */\n\n\n  PDFTextField.prototype.enablePassword = function () {\n    this.acroField.setFlagTo(AcroTextFlags.Password, true);\n  };\n  /**\r\n   * Indicate that this text field is **not** intended for storing a secure\r\n   * password. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disablePassword()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.disablePassword = function () {\n    this.acroField.setFlagTo(AcroTextFlags.Password, false);\n  };\n  /**\r\n   * Returns `true` if the contents of this text field represent a file path.\r\n   * See [[PDFTextField.enableFileSelection]] and\r\n   * [[PDFTextField.disableFileSelection]]. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isFileSelector()) console.log('Is a file selector')\r\n   * ```\r\n   * @returns Whether or not this field should contain file paths.\r\n   */\n\n\n  PDFTextField.prototype.isFileSelector = function () {\n    return this.acroField.hasFlag(AcroTextFlags.FileSelect);\n  };\n  /**\r\n   * Indicate that this text field is intended to store a file path. The\r\n   * contents of the file stored at that path should be submitted as the value\r\n   * of the field. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enableFileSelection()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.enableFileSelection = function () {\n    this.acroField.setFlagTo(AcroTextFlags.FileSelect, true);\n  };\n  /**\r\n   * Indicate that this text field is **not** intended to store a file path.\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disableFileSelection()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.disableFileSelection = function () {\n    this.acroField.setFlagTo(AcroTextFlags.FileSelect, false);\n  };\n  /**\r\n   * Returns `true` if the text entered in this field should be spell checked\r\n   * by PDF readers. See [[PDFTextField.enableSpellChecking]] and\r\n   * [[PDFTextField.disableSpellChecking]]. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isSpellChecked()) console.log('Spell checking is enabled')\r\n   * ```\r\n   * @returns Whether or not this field should be spell checked.\r\n   */\n\n\n  PDFTextField.prototype.isSpellChecked = function () {\n    return !this.acroField.hasFlag(AcroTextFlags.DoNotSpellCheck);\n  };\n  /**\r\n   * Allow PDF readers to spell check the text entered in this field.\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enableSpellChecking()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.enableSpellChecking = function () {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, false);\n  };\n  /**\r\n   * Do not allow PDF readers to spell check the text entered in this field.\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disableSpellChecking()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.disableSpellChecking = function () {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, true);\n  };\n  /**\r\n   * Returns `true` if PDF readers should allow the user to scroll the text\r\n   * field when its contents do not fit within the field's view bounds. See\r\n   * [[PDFTextField.enableScrolling]] and [[PDFTextField.disableScrolling]].\r\n   * For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isScrollable()) console.log('Scrolling is enabled')\r\n   * ```\r\n   * @returns Whether or not the field is scrollable in PDF readers.\r\n   */\n\n\n  PDFTextField.prototype.isScrollable = function () {\n    return !this.acroField.hasFlag(AcroTextFlags.DoNotScroll);\n  };\n  /**\r\n   * Allow PDF readers to present a scroll bar to the user when the contents\r\n   * of this text field do not fit within its view bounds. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enableScrolling()\r\n   * ```\r\n   * A horizontal scroll bar should be shown for singleline fields. A vertical\r\n   * scroll bar should be shown for multiline fields.\r\n   */\n\n\n  PDFTextField.prototype.enableScrolling = function () {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, false);\n  };\n  /**\r\n   * Do not allow PDF readers to present a scroll bar to the user when the\r\n   * contents of this text field do not fit within its view bounds. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disableScrolling()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.disableScrolling = function () {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, true);\n  };\n  /**\r\n   * Returns `true` if this is a combed text field. This means that the field\r\n   * is split into `n` equal size cells with one character in each (where `n`\r\n   * is equal to the max length of the text field). The result is that all\r\n   * characters in this field are displayed an equal distance apart from one\r\n   * another. See [[PDFTextField.enableCombing]] and\r\n   * [[PDFTextField.disableCombing]]. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isCombed()) console.log('Combing is enabled')\r\n   * ```\r\n   * Note that in order for a text field to be combed, the following must be\r\n   * true (in addition to enabling combing):\r\n   * * It must not be a multiline field (see [[PDFTextField.isMultiline]])\r\n   * * It must not be a password field (see [[PDFTextField.isPassword]])\r\n   * * It must not be a file selector field (see [[PDFTextField.isFileSelector]])\r\n   * * It must have a max length defined (see [[PDFTextField.setMaxLength]])\r\n   * @returns Whether or not this field is combed.\r\n   */\n\n\n  PDFTextField.prototype.isCombed = function () {\n    return this.acroField.hasFlag(AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== undefined;\n  };\n  /**\r\n   * Split this field into `n` equal size cells with one character in each\r\n   * (where `n` is equal to the max length of the text field). This will cause\r\n   * all characters in the field to be displayed an equal distance apart from\r\n   * one another. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enableCombing()\r\n   * ```\r\n   *\r\n   * In addition to calling this method, text fields must have a max length\r\n   * defined in order to be combed (see [[PDFTextField.setMaxLength]]).\r\n   *\r\n   * This method will also call the following three methods internally:\r\n   * * [[PDFTextField.disableMultiline]]\r\n   * * [[PDFTextField.disablePassword]]\r\n   * * [[PDFTextField.disableFileSelection]]\r\n   *\r\n   * This method will mark this text field as dirty. See\r\n   * [[PDFTextField.setText]] for more details about what this means.\r\n   */\n\n\n  PDFTextField.prototype.enableCombing = function () {\n    if (this.getMaxLength() === undefined) {\n      var msg = \"PDFTextFields must have a max length in order to be combed\";\n      console.warn(msg);\n    }\n\n    this.markAsDirty();\n    this.disableMultiline();\n    this.disablePassword();\n    this.disableFileSelection();\n    this.acroField.setFlagTo(AcroTextFlags.Comb, true);\n  };\n  /**\r\n   * Turn off combing for this text field. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disableCombing()\r\n   * ```\r\n   * See [[PDFTextField.isCombed]] and [[PDFTextField.enableCombing]] for more\r\n   * information about what combing is.\r\n   *\r\n   * This method will mark this text field as dirty. See\r\n   * [[PDFTextField.setText]] for more details about what this means.\r\n   */\n\n\n  PDFTextField.prototype.disableCombing = function () {\n    this.markAsDirty();\n    this.acroField.setFlagTo(AcroTextFlags.Comb, false);\n  };\n  /**\r\n   * Returns `true` if this text field contains rich text. See\r\n   * [[PDFTextField.enableRichFormatting]] and\r\n   * [[PDFTextField.disableRichFormatting]]. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.isRichFormatted()) console.log('Rich formatting enabled')\r\n   * ```\r\n   * @returns Whether or not this field contains rich text.\r\n   */\n\n\n  PDFTextField.prototype.isRichFormatted = function () {\n    return this.acroField.hasFlag(AcroTextFlags.RichText);\n  };\n  /**\r\n   * Indicate that this field contains XFA data - or rich text. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.enableRichFormatting()\r\n   * ```\r\n   * Note that `pdf-lib` does not support reading or writing rich text fields.\r\n   * Nor do most PDF readers and writers. Rich text fields are based on XFA\r\n   * (XML Forms Architecture). Relatively few PDFs use rich text fields or XFA.\r\n   * Unlike PDF itself, XFA is not an ISO standard. XFA has been deprecated in\r\n   * PDF 2.0:\r\n   * * https://en.wikipedia.org/wiki/XFA\r\n   * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\r\n   */\n\n\n  PDFTextField.prototype.enableRichFormatting = function () {\n    this.acroField.setFlagTo(AcroTextFlags.RichText, true);\n  };\n  /**\r\n   * Indicate that this is a standard text field that does not XFA data (rich\r\n   * text). For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.disableRichFormatting()\r\n   * ```\r\n   */\n\n\n  PDFTextField.prototype.disableRichFormatting = function () {\n    this.acroField.setFlagTo(AcroTextFlags.RichText, false);\n  };\n  /**\r\n   * Show this text field on the specified page. For example:\r\n   * ```js\r\n   * const ubuntuFont = await pdfDoc.embedFont(ubuntuFontBytes)\r\n   * const page = pdfDoc.addPage()\r\n   *\r\n   * const form = pdfDoc.getForm()\r\n   * const textField = form.createTextField('best.gundam')\r\n   * textField.setText('Exia')\r\n   *\r\n   * textField.addToPage(page, {\r\n   *   x: 50,\r\n   *   y: 75,\r\n   *   width: 200,\r\n   *   height: 100,\r\n   *   textColor: rgb(1, 0, 0),\r\n   *   backgroundColor: rgb(0, 1, 0),\r\n   *   borderColor: rgb(0, 0, 1),\r\n   *   borderWidth: 2,\r\n   *   rotate: degrees(90),\r\n   *   font: ubuntuFont,\r\n   * })\r\n   * ```\r\n   * This will create a new widget for this text field.\r\n   * @param page The page to which this text field widget should be added.\r\n   * @param options The options to be used when adding this text field widget.\r\n   */\n\n\n  PDFTextField.prototype.addToPage = function (page, options) {\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    assertIs(page, 'page', [[PDFPage, 'PDFPage']]);\n    assertFieldAppearanceOptions(options);\n    if (!options) options = {};\n    if (!('textColor' in options)) options.textColor = rgb(0, 0, 0);\n    if (!('backgroundColor' in options)) options.backgroundColor = rgb(1, 1, 1);\n    if (!('borderColor' in options)) options.borderColor = rgb(0, 0, 0);\n    if (!('borderWidth' in options)) options.borderWidth = 1; // Create a widget for this text field\n\n    var widget = this.createWidget({\n      x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,\n      y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,\n      width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,\n      height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,\n      textColor: options.textColor,\n      backgroundColor: options.backgroundColor,\n      borderColor: options.borderColor,\n      borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,\n      rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),\n      hidden: options.hidden\n    });\n    var widgetRef = this.doc.context.register(widget.dict); // Add widget to this field\n\n    this.acroField.addWidget(widgetRef); // Set appearance streams for widget\n\n    var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();\n    this.updateWidgetAppearance(widget, font); // Add widget to the given page\n\n    page.node.addAnnot(widgetRef);\n  };\n  /**\r\n   * Returns `true` if this text field has been marked as dirty, or if any of\r\n   * this text field's widgets do not have an appearance stream. For example:\r\n   * ```js\r\n   * const textField = form.getTextField('some.text.field')\r\n   * if (textField.needsAppearancesUpdate()) console.log('Needs update')\r\n   * ```\r\n   * @returns Whether or not this text field needs an appearance update.\r\n   */\n\n\n  PDFTextField.prototype.needsAppearancesUpdate = function () {\n    var _a;\n\n    if (this.isDirty()) return true;\n    var widgets = this.acroField.getWidgets();\n\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream;\n      if (!hasAppearances) return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Update the appearance streams for each of this text field's widgets using\r\n   * the default appearance provider for text fields. For example:\r\n   * ```js\r\n   * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.defaultUpdateAppearances(helvetica)\r\n   * ```\r\n   * @param font The font to be used for creating the appearance streams.\r\n   */\n\n\n  PDFTextField.prototype.defaultUpdateAppearances = function (font) {\n    assertIs(font, 'font', [[PDFFont, 'PDFFont']]);\n    this.updateAppearances(font);\n  };\n  /**\r\n   * Update the appearance streams for each of this text field's widgets using\r\n   * the given appearance provider. If no `provider` is passed, the default\r\n   * appearance provider for text fields will be used. For example:\r\n   * ```js\r\n   * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\r\n   * const textField = form.getTextField('some.text.field')\r\n   * textField.updateAppearances(helvetica, (field, widget, font) => {\r\n   *   ...\r\n   *   return drawTextField(...)\r\n   * })\r\n   * ```\r\n   * @param font The font to be used for creating the appearance streams.\r\n   * @param provider Optionally, the appearance provider to be used for\r\n   *                 generating the contents of the appearance streams.\r\n   */\n\n\n  PDFTextField.prototype.updateAppearances = function (font, provider) {\n    assertIs(font, 'font', [[PDFFont, 'PDFFont']]);\n    assertOrUndefined(provider, 'provider', [Function]);\n    var widgets = this.acroField.getWidgets();\n\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      this.updateWidgetAppearance(widget, font, provider);\n    }\n\n    this.markAsClean();\n  };\n\n  PDFTextField.prototype.updateWidgetAppearance = function (widget, font, provider) {\n    var apProvider = provider !== null && provider !== void 0 ? provider : defaultTextFieldAppearanceProvider;\n    var appearances = normalizeAppearance(apProvider(this, widget, font));\n    this.updateWidgetAppearanceWithFont(widget, font, appearances);\n  };\n  /**\r\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\r\n   * > consider using the [[PDFForm.getTextField]] method, which will create an\r\n   * > instance of [[PDFTextField]] for you.\r\n   *\r\n   * Create an instance of [[PDFTextField]] from an existing acroText and ref\r\n   *\r\n   * @param acroText The underlying `PDFAcroText` for this text field.\r\n   * @param ref The unique reference for this text field.\r\n   * @param doc The document to which this text field will belong.\r\n   */\n\n\n  PDFTextField.of = function (acroText, ref, doc) {\n    return new PDFTextField(acroText, ref, doc);\n  };\n\n  return PDFTextField;\n}(PDFField);\n\nexport default PDFTextField;","map":{"version":3,"sources":["../../../src/api/form/PDFTextField.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\r\nimport PDFPage from \"../PDFPage\";\r\nimport PDFFont from \"../PDFFont\";\r\nimport PDFField, { assertFieldAppearanceOptions, } from \"./PDFField\";\r\nimport { normalizeAppearance, defaultTextFieldAppearanceProvider, } from \"./appearances\";\r\nimport { rgb } from \"../colors\";\r\nimport { degrees } from \"../rotations\";\r\nimport { RichTextFieldReadError, ExceededMaxLengthError, InvalidMaxLengthError, } from \"../errors\";\r\nimport { ImageAlignment } from \"../image/alignment\";\r\nimport { TextAlignment } from \"../text/alignment\";\r\nimport { PDFHexString, PDFStream, PDFAcroText, AcroTextFlags, } from \"../../core\";\r\nimport { assertIs, assertIsOneOf, assertOrUndefined, assertPositive, assertRangeOrUndefined, } from \"../../utils\";\r\n/**\r\n * Represents a text field of a [[PDFForm]].\r\n *\r\n * [[PDFTextField]] fields are boxes that display text entered by the user. The\r\n * purpose of a text field is to enable users to enter text or view text values\r\n * in the document prefilled by software. Users can click on a text field and\r\n * input text via their keyboard. Some text fields allow multiple lines of text\r\n * to be entered (see [[PDFTextField.isMultiline]]).\r\n */\r\nvar PDFTextField = /** @class */ (function (_super) {\r\n    __extends(PDFTextField, _super);\r\n    function PDFTextField(acroText, ref, doc) {\r\n        var _this = _super.call(this, acroText, ref, doc) || this;\r\n        assertIs(acroText, 'acroText', [[PDFAcroText, 'PDFAcroText']]);\r\n        _this.acroField = acroText;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Get the text that this field contains. This text is visible to users who\r\n     * view this field in a PDF reader.\r\n     *\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * const text = textField.getText()\r\n     * console.log('Text field contents:', text)\r\n     * ```\r\n     *\r\n     * Note that if this text field contains no underlying value, `undefined`\r\n     * will be returned. Text fields may also contain an underlying value that\r\n     * is simply an empty string (`''`). This detail is largely irrelevant for\r\n     * most applications. In general, you'll want to treat both cases the same\r\n     * way and simply consider the text field to be empty. In either case, the\r\n     * text field will appear empty to users when viewed in a PDF reader.\r\n     *\r\n     * An error will be thrown if this is a rich text field. `pdf-lib` does not\r\n     * support reading rich text fields. Nor do most PDF readers and writers.\r\n     * Rich text fields are based on XFA (XML Forms Architecture). Relatively few\r\n     * PDFs use rich text fields or XFA. Unlike PDF itself, XFA is not an ISO\r\n     * standard. XFA has been deprecated in PDF 2.0:\r\n     * * https://en.wikipedia.org/wiki/XFA\r\n     * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\r\n     *\r\n     * @returns The text contained in this text field.\r\n     */\r\n    PDFTextField.prototype.getText = function () {\r\n        var value = this.acroField.getValue();\r\n        if (!value && this.isRichFormatted()) {\r\n            throw new RichTextFieldReadError(this.getName());\r\n        }\r\n        return value === null || value === void 0 ? void 0 : value.decodeText();\r\n    };\r\n    /**\r\n     * Set the text for this field. This operation is analogous to a human user\r\n     * clicking on the text field in a PDF reader and typing in text via their\r\n     * keyboard. This method will update the underlying state of the text field\r\n     * to indicate what text has been set. PDF libraries and readers will be able\r\n     * to extract these values from the saved document and determine what text\r\n     * was set.\r\n     *\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('best.superhero.text.field')\r\n     * textField.setText('One Punch Man')\r\n     * ```\r\n     *\r\n     * This method will mark this text field as dirty, causing its appearance\r\n     * streams to be updated when either [[PDFDocument.save]] or\r\n     * [[PDFForm.updateFieldAppearances]] is called. The updated streams will\r\n     * display the text this field contains inside the widgets of this text\r\n     * field.\r\n     *\r\n     * **IMPORTANT:** The default font used to update appearance streams is\r\n     * [[StandardFonts.Helvetica]]. Note that this is a WinAnsi font. This means\r\n     * that encoding errors will be thrown if this field contains text outside\r\n     * the WinAnsi character set (the latin alphabet).\r\n     *\r\n     * Embedding a custom font and passing it to\r\n     * [[PDFForm.updateFieldAppearances]] or [[PDFTextField.updateAppearances]]\r\n     * allows you to generate appearance streams with characters outside the\r\n     * latin alphabet (assuming the custom font supports them).\r\n     *\r\n     * If this is a rich text field, it will be converted to a standard text\r\n     * field in order to set the text. `pdf-lib` does not support writing rich\r\n     * text strings. Nor do most PDF readers and writers. See\r\n     * [[PDFTextField.getText]] for more information about rich text fields and\r\n     * their deprecation in PDF 2.0.\r\n     *\r\n     * @param text The text this field should contain.\r\n     */\r\n    PDFTextField.prototype.setText = function (text) {\r\n        assertOrUndefined(text, 'text', ['string']);\r\n        var maxLength = this.getMaxLength();\r\n        if (maxLength !== undefined && text && text.length > maxLength) {\r\n            throw new ExceededMaxLengthError(text.length, maxLength, this.getName());\r\n        }\r\n        this.markAsDirty();\r\n        this.disableRichFormatting();\r\n        if (text) {\r\n            this.acroField.setValue(PDFHexString.fromText(text));\r\n        }\r\n        else {\r\n            this.acroField.removeValue();\r\n        }\r\n    };\r\n    /**\r\n     * Get the alignment for this text field. This value represents the\r\n     * justification of the text when it is displayed to the user in PDF readers.\r\n     * There are three possible alignments: left, center, and right. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * const alignment = textField.getAlignment()\r\n     * if (alignment === TextAlignment.Left) console.log('Text is left justified')\r\n     * if (alignment === TextAlignment.Center) console.log('Text is centered')\r\n     * if (alignment === TextAlignment.Right) console.log('Text is right justified')\r\n     * ```\r\n     * @returns The alignment of this text field.\r\n     */\r\n    PDFTextField.prototype.getAlignment = function () {\r\n        var quadding = this.acroField.getQuadding();\r\n        // prettier-ignore\r\n        return (quadding === 0 ? TextAlignment.Left\r\n            : quadding === 1 ? TextAlignment.Center\r\n                : quadding === 2 ? TextAlignment.Right\r\n                    : TextAlignment.Left);\r\n    };\r\n    /**\r\n     * Set the alignment for this text field. This will determine the\r\n     * justification of the text when it is displayed to the user in PDF readers.\r\n     * There are three possible alignments: left, center, and right. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     *\r\n     * // Text will be left justified when displayed\r\n     * textField.setAlignment(TextAlignment.Left)\r\n     *\r\n     * // Text will be centered when displayed\r\n     * textField.setAlignment(TextAlignment.Center)\r\n     *\r\n     * // Text will be right justified when displayed\r\n     * textField.setAlignment(TextAlignment.Right)\r\n     * ```\r\n     * This method will mark this text field as dirty. See\r\n     * [[PDFTextField.setText]] for more details about what this means.\r\n     * @param alignment The alignment for this text field.\r\n     */\r\n    PDFTextField.prototype.setAlignment = function (alignment) {\r\n        assertIsOneOf(alignment, 'alignment', TextAlignment);\r\n        this.markAsDirty();\r\n        this.acroField.setQuadding(alignment);\r\n    };\r\n    /**\r\n     * Get the maximum length of this field. This value represents the maximum\r\n     * number of characters that can be typed into this field by the user. If\r\n     * this field does not have a maximum length, `undefined` is returned.\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * const maxLength = textField.getMaxLength()\r\n     * if (maxLength === undefined) console.log('No max length')\r\n     * else console.log(`Max length is ${maxLength}`)\r\n     * ```\r\n     * @returns The maximum number of characters allowed in this field, or\r\n     *          `undefined` if no limit exists.\r\n     */\r\n    PDFTextField.prototype.getMaxLength = function () {\r\n        return this.acroField.getMaxLength();\r\n    };\r\n    /**\r\n     * Set the maximum length of this field. This limits the number of characters\r\n     * that can be typed into this field by the user. This also limits the length\r\n     * of the string that can be passed to [[PDFTextField.setText]]. This limit\r\n     * can be removed by passing `undefined` as `maxLength`. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     *\r\n     * // Allow between 0 and 5 characters to be entered\r\n     * textField.setMaxLength(5)\r\n     *\r\n     * // Allow any number of characters to be entered\r\n     * textField.setMaxLength(undefined)\r\n     * ```\r\n     * This method will mark this text field as dirty. See\r\n     * [[PDFTextField.setText]] for more details about what this means.\r\n     * @param maxLength The maximum number of characters allowed in this field, or\r\n     *                  `undefined` to remove the limit.\r\n     */\r\n    PDFTextField.prototype.setMaxLength = function (maxLength) {\r\n        assertRangeOrUndefined(maxLength, 'maxLength', 0, Number.MAX_SAFE_INTEGER);\r\n        this.markAsDirty();\r\n        if (maxLength === undefined) {\r\n            this.acroField.removeMaxLength();\r\n        }\r\n        else {\r\n            var text = this.getText();\r\n            if (text && text.length > maxLength) {\r\n                throw new InvalidMaxLengthError(text.length, maxLength, this.getName());\r\n            }\r\n            this.acroField.setMaxLength(maxLength);\r\n        }\r\n    };\r\n    /**\r\n     * Remove the maximum length for this text field. This allows any number of\r\n     * characters to be typed into this field by the user. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.removeMaxLength()\r\n     * ```\r\n     * Calling this method is equivalent to passing `undefined` to\r\n     * [[PDFTextField.setMaxLength]].\r\n     */\r\n    PDFTextField.prototype.removeMaxLength = function () {\r\n        this.markAsDirty();\r\n        this.acroField.removeMaxLength();\r\n    };\r\n    /**\r\n     * Display an image inside the bounds of this text field's widgets. For example:\r\n     * ```js\r\n     * const pngImage = await pdfDoc.embedPng(...)\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.setImage(pngImage)\r\n     * ```\r\n     * This will update the appearances streams for each of this text field's widgets.\r\n     * @param image The image that should be displayed.\r\n     */\r\n    PDFTextField.prototype.setImage = function (image) {\r\n        var fieldAlignment = this.getAlignment();\r\n        // prettier-ignore\r\n        var alignment = fieldAlignment === TextAlignment.Center ? ImageAlignment.Center\r\n            : fieldAlignment === TextAlignment.Right ? ImageAlignment.Right\r\n                : ImageAlignment.Left;\r\n        var widgets = this.acroField.getWidgets();\r\n        for (var idx = 0, len = widgets.length; idx < len; idx++) {\r\n            var widget = widgets[idx];\r\n            var streamRef = this.createImageAppearanceStream(widget, image, alignment);\r\n            this.updateWidgetAppearances(widget, { normal: streamRef });\r\n        }\r\n        this.markAsClean();\r\n    };\r\n    /**\r\n     * Set the font size for this field. Larger font sizes will result in larger\r\n     * text being displayed when PDF readers render this text field. Font sizes\r\n     * may be integer or floating point numbers. Supplying a negative font size\r\n     * will cause this method to throw an error.\r\n     *\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.setFontSize(4)\r\n     * textField.setFontSize(15.7)\r\n     * ```\r\n     *\r\n     * > This method depends upon the existence of a default appearance\r\n     * > (`/DA`) string. If this field does not have a default appearance string,\r\n     * > or that string does not contain a font size (via the `Tf` operator),\r\n     * > then this method will throw an error.\r\n     *\r\n     * @param fontSize The font size to be used when rendering text in this field.\r\n     */\r\n    PDFTextField.prototype.setFontSize = function (fontSize) {\r\n        assertPositive(fontSize, 'fontSize');\r\n        this.acroField.setFontSize(fontSize);\r\n        this.markAsDirty();\r\n    };\r\n    /**\r\n     * Returns `true` if each line of text is shown on a new line when this\r\n     * field is displayed in a PDF reader. The alternative is that all lines of\r\n     * text are merged onto a single line when displayed. See\r\n     * [[PDFTextField.enableMultiline]] and [[PDFTextField.disableMultiline]].\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isMultiline()) console.log('Multiline is enabled')\r\n     * ```\r\n     * @returns Whether or not this is a multiline text field.\r\n     */\r\n    PDFTextField.prototype.isMultiline = function () {\r\n        return this.acroField.hasFlag(AcroTextFlags.Multiline);\r\n    };\r\n    /**\r\n     * Display each line of text on a new line when this field is displayed in a\r\n     * PDF reader. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enableMultiline()\r\n     * ```\r\n     * This method will mark this text field as dirty. See\r\n     * [[PDFTextField.setText]] for more details about what this means.\r\n     */\r\n    PDFTextField.prototype.enableMultiline = function () {\r\n        this.markAsDirty();\r\n        this.acroField.setFlagTo(AcroTextFlags.Multiline, true);\r\n    };\r\n    /**\r\n     * Display each line of text on the same line when this field is displayed\r\n     * in a PDF reader. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disableMultiline()\r\n     * ```\r\n     * This method will mark this text field as dirty. See\r\n     * [[PDFTextField.setText]] for more details about what this means.\r\n     */\r\n    PDFTextField.prototype.disableMultiline = function () {\r\n        this.markAsDirty();\r\n        this.acroField.setFlagTo(AcroTextFlags.Multiline, false);\r\n    };\r\n    /**\r\n     * Returns `true` if this is a password text field. This means that the field\r\n     * is intended for storing a secure password. See\r\n     * [[PDFTextField.enablePassword]] and [[PDFTextField.disablePassword]].\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isPassword()) console.log('Password is enabled')\r\n     * ```\r\n     * @returns Whether or not this is a password text field.\r\n     */\r\n    PDFTextField.prototype.isPassword = function () {\r\n        return this.acroField.hasFlag(AcroTextFlags.Password);\r\n    };\r\n    /**\r\n     * Indicate that this text field is intended for storing a secure password.\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enablePassword()\r\n     * ```\r\n     * Values entered into password text fields should not be displayed on the\r\n     * screen by PDF readers. Most PDF readers will display the value as\r\n     * asterisks or bullets. PDF readers should never store values entered by the\r\n     * user into password text fields. Similarly, applications should not\r\n     * write data to a password text field.\r\n     *\r\n     * **Please note that this method does not cause entered values to be\r\n     * encrypted or secured in any way! It simply sets a flag that PDF software\r\n     * and readers can access to determine the _purpose_ of this field.**\r\n     */\r\n    PDFTextField.prototype.enablePassword = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.Password, true);\r\n    };\r\n    /**\r\n     * Indicate that this text field is **not** intended for storing a secure\r\n     * password. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disablePassword()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.disablePassword = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.Password, false);\r\n    };\r\n    /**\r\n     * Returns `true` if the contents of this text field represent a file path.\r\n     * See [[PDFTextField.enableFileSelection]] and\r\n     * [[PDFTextField.disableFileSelection]]. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isFileSelector()) console.log('Is a file selector')\r\n     * ```\r\n     * @returns Whether or not this field should contain file paths.\r\n     */\r\n    PDFTextField.prototype.isFileSelector = function () {\r\n        return this.acroField.hasFlag(AcroTextFlags.FileSelect);\r\n    };\r\n    /**\r\n     * Indicate that this text field is intended to store a file path. The\r\n     * contents of the file stored at that path should be submitted as the value\r\n     * of the field. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enableFileSelection()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.enableFileSelection = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.FileSelect, true);\r\n    };\r\n    /**\r\n     * Indicate that this text field is **not** intended to store a file path.\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disableFileSelection()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.disableFileSelection = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.FileSelect, false);\r\n    };\r\n    /**\r\n     * Returns `true` if the text entered in this field should be spell checked\r\n     * by PDF readers. See [[PDFTextField.enableSpellChecking]] and\r\n     * [[PDFTextField.disableSpellChecking]]. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isSpellChecked()) console.log('Spell checking is enabled')\r\n     * ```\r\n     * @returns Whether or not this field should be spell checked.\r\n     */\r\n    PDFTextField.prototype.isSpellChecked = function () {\r\n        return !this.acroField.hasFlag(AcroTextFlags.DoNotSpellCheck);\r\n    };\r\n    /**\r\n     * Allow PDF readers to spell check the text entered in this field.\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enableSpellChecking()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.enableSpellChecking = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, false);\r\n    };\r\n    /**\r\n     * Do not allow PDF readers to spell check the text entered in this field.\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disableSpellChecking()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.disableSpellChecking = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, true);\r\n    };\r\n    /**\r\n     * Returns `true` if PDF readers should allow the user to scroll the text\r\n     * field when its contents do not fit within the field's view bounds. See\r\n     * [[PDFTextField.enableScrolling]] and [[PDFTextField.disableScrolling]].\r\n     * For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isScrollable()) console.log('Scrolling is enabled')\r\n     * ```\r\n     * @returns Whether or not the field is scrollable in PDF readers.\r\n     */\r\n    PDFTextField.prototype.isScrollable = function () {\r\n        return !this.acroField.hasFlag(AcroTextFlags.DoNotScroll);\r\n    };\r\n    /**\r\n     * Allow PDF readers to present a scroll bar to the user when the contents\r\n     * of this text field do not fit within its view bounds. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enableScrolling()\r\n     * ```\r\n     * A horizontal scroll bar should be shown for singleline fields. A vertical\r\n     * scroll bar should be shown for multiline fields.\r\n     */\r\n    PDFTextField.prototype.enableScrolling = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, false);\r\n    };\r\n    /**\r\n     * Do not allow PDF readers to present a scroll bar to the user when the\r\n     * contents of this text field do not fit within its view bounds. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disableScrolling()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.disableScrolling = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, true);\r\n    };\r\n    /**\r\n     * Returns `true` if this is a combed text field. This means that the field\r\n     * is split into `n` equal size cells with one character in each (where `n`\r\n     * is equal to the max length of the text field). The result is that all\r\n     * characters in this field are displayed an equal distance apart from one\r\n     * another. See [[PDFTextField.enableCombing]] and\r\n     * [[PDFTextField.disableCombing]]. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isCombed()) console.log('Combing is enabled')\r\n     * ```\r\n     * Note that in order for a text field to be combed, the following must be\r\n     * true (in addition to enabling combing):\r\n     * * It must not be a multiline field (see [[PDFTextField.isMultiline]])\r\n     * * It must not be a password field (see [[PDFTextField.isPassword]])\r\n     * * It must not be a file selector field (see [[PDFTextField.isFileSelector]])\r\n     * * It must have a max length defined (see [[PDFTextField.setMaxLength]])\r\n     * @returns Whether or not this field is combed.\r\n     */\r\n    PDFTextField.prototype.isCombed = function () {\r\n        return (this.acroField.hasFlag(AcroTextFlags.Comb) &&\r\n            !this.isMultiline() &&\r\n            !this.isPassword() &&\r\n            !this.isFileSelector() &&\r\n            this.getMaxLength() !== undefined);\r\n    };\r\n    /**\r\n     * Split this field into `n` equal size cells with one character in each\r\n     * (where `n` is equal to the max length of the text field). This will cause\r\n     * all characters in the field to be displayed an equal distance apart from\r\n     * one another. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enableCombing()\r\n     * ```\r\n     *\r\n     * In addition to calling this method, text fields must have a max length\r\n     * defined in order to be combed (see [[PDFTextField.setMaxLength]]).\r\n     *\r\n     * This method will also call the following three methods internally:\r\n     * * [[PDFTextField.disableMultiline]]\r\n     * * [[PDFTextField.disablePassword]]\r\n     * * [[PDFTextField.disableFileSelection]]\r\n     *\r\n     * This method will mark this text field as dirty. See\r\n     * [[PDFTextField.setText]] for more details about what this means.\r\n     */\r\n    PDFTextField.prototype.enableCombing = function () {\r\n        if (this.getMaxLength() === undefined) {\r\n            var msg = \"PDFTextFields must have a max length in order to be combed\";\r\n            console.warn(msg);\r\n        }\r\n        this.markAsDirty();\r\n        this.disableMultiline();\r\n        this.disablePassword();\r\n        this.disableFileSelection();\r\n        this.acroField.setFlagTo(AcroTextFlags.Comb, true);\r\n    };\r\n    /**\r\n     * Turn off combing for this text field. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disableCombing()\r\n     * ```\r\n     * See [[PDFTextField.isCombed]] and [[PDFTextField.enableCombing]] for more\r\n     * information about what combing is.\r\n     *\r\n     * This method will mark this text field as dirty. See\r\n     * [[PDFTextField.setText]] for more details about what this means.\r\n     */\r\n    PDFTextField.prototype.disableCombing = function () {\r\n        this.markAsDirty();\r\n        this.acroField.setFlagTo(AcroTextFlags.Comb, false);\r\n    };\r\n    /**\r\n     * Returns `true` if this text field contains rich text. See\r\n     * [[PDFTextField.enableRichFormatting]] and\r\n     * [[PDFTextField.disableRichFormatting]]. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.isRichFormatted()) console.log('Rich formatting enabled')\r\n     * ```\r\n     * @returns Whether or not this field contains rich text.\r\n     */\r\n    PDFTextField.prototype.isRichFormatted = function () {\r\n        return this.acroField.hasFlag(AcroTextFlags.RichText);\r\n    };\r\n    /**\r\n     * Indicate that this field contains XFA data - or rich text. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.enableRichFormatting()\r\n     * ```\r\n     * Note that `pdf-lib` does not support reading or writing rich text fields.\r\n     * Nor do most PDF readers and writers. Rich text fields are based on XFA\r\n     * (XML Forms Architecture). Relatively few PDFs use rich text fields or XFA.\r\n     * Unlike PDF itself, XFA is not an ISO standard. XFA has been deprecated in\r\n     * PDF 2.0:\r\n     * * https://en.wikipedia.org/wiki/XFA\r\n     * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\r\n     */\r\n    PDFTextField.prototype.enableRichFormatting = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.RichText, true);\r\n    };\r\n    /**\r\n     * Indicate that this is a standard text field that does not XFA data (rich\r\n     * text). For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.disableRichFormatting()\r\n     * ```\r\n     */\r\n    PDFTextField.prototype.disableRichFormatting = function () {\r\n        this.acroField.setFlagTo(AcroTextFlags.RichText, false);\r\n    };\r\n    /**\r\n     * Show this text field on the specified page. For example:\r\n     * ```js\r\n     * const ubuntuFont = await pdfDoc.embedFont(ubuntuFontBytes)\r\n     * const page = pdfDoc.addPage()\r\n     *\r\n     * const form = pdfDoc.getForm()\r\n     * const textField = form.createTextField('best.gundam')\r\n     * textField.setText('Exia')\r\n     *\r\n     * textField.addToPage(page, {\r\n     *   x: 50,\r\n     *   y: 75,\r\n     *   width: 200,\r\n     *   height: 100,\r\n     *   textColor: rgb(1, 0, 0),\r\n     *   backgroundColor: rgb(0, 1, 0),\r\n     *   borderColor: rgb(0, 0, 1),\r\n     *   borderWidth: 2,\r\n     *   rotate: degrees(90),\r\n     *   font: ubuntuFont,\r\n     * })\r\n     * ```\r\n     * This will create a new widget for this text field.\r\n     * @param page The page to which this text field widget should be added.\r\n     * @param options The options to be used when adding this text field widget.\r\n     */\r\n    PDFTextField.prototype.addToPage = function (page, options) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        assertIs(page, 'page', [[PDFPage, 'PDFPage']]);\r\n        assertFieldAppearanceOptions(options);\r\n        if (!options)\r\n            options = {};\r\n        if (!('textColor' in options))\r\n            options.textColor = rgb(0, 0, 0);\r\n        if (!('backgroundColor' in options))\r\n            options.backgroundColor = rgb(1, 1, 1);\r\n        if (!('borderColor' in options))\r\n            options.borderColor = rgb(0, 0, 0);\r\n        if (!('borderWidth' in options))\r\n            options.borderWidth = 1;\r\n        // Create a widget for this text field\r\n        var widget = this.createWidget({\r\n            x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,\r\n            y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,\r\n            width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,\r\n            height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,\r\n            textColor: options.textColor,\r\n            backgroundColor: options.backgroundColor,\r\n            borderColor: options.borderColor,\r\n            borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,\r\n            rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : degrees(0),\r\n            hidden: options.hidden,\r\n        });\r\n        var widgetRef = this.doc.context.register(widget.dict);\r\n        // Add widget to this field\r\n        this.acroField.addWidget(widgetRef);\r\n        // Set appearance streams for widget\r\n        var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();\r\n        this.updateWidgetAppearance(widget, font);\r\n        // Add widget to the given page\r\n        page.node.addAnnot(widgetRef);\r\n    };\r\n    /**\r\n     * Returns `true` if this text field has been marked as dirty, or if any of\r\n     * this text field's widgets do not have an appearance stream. For example:\r\n     * ```js\r\n     * const textField = form.getTextField('some.text.field')\r\n     * if (textField.needsAppearancesUpdate()) console.log('Needs update')\r\n     * ```\r\n     * @returns Whether or not this text field needs an appearance update.\r\n     */\r\n    PDFTextField.prototype.needsAppearancesUpdate = function () {\r\n        var _a;\r\n        if (this.isDirty())\r\n            return true;\r\n        var widgets = this.acroField.getWidgets();\r\n        for (var idx = 0, len = widgets.length; idx < len; idx++) {\r\n            var widget = widgets[idx];\r\n            var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof PDFStream;\r\n            if (!hasAppearances)\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Update the appearance streams for each of this text field's widgets using\r\n     * the default appearance provider for text fields. For example:\r\n     * ```js\r\n     * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.defaultUpdateAppearances(helvetica)\r\n     * ```\r\n     * @param font The font to be used for creating the appearance streams.\r\n     */\r\n    PDFTextField.prototype.defaultUpdateAppearances = function (font) {\r\n        assertIs(font, 'font', [[PDFFont, 'PDFFont']]);\r\n        this.updateAppearances(font);\r\n    };\r\n    /**\r\n     * Update the appearance streams for each of this text field's widgets using\r\n     * the given appearance provider. If no `provider` is passed, the default\r\n     * appearance provider for text fields will be used. For example:\r\n     * ```js\r\n     * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\r\n     * const textField = form.getTextField('some.text.field')\r\n     * textField.updateAppearances(helvetica, (field, widget, font) => {\r\n     *   ...\r\n     *   return drawTextField(...)\r\n     * })\r\n     * ```\r\n     * @param font The font to be used for creating the appearance streams.\r\n     * @param provider Optionally, the appearance provider to be used for\r\n     *                 generating the contents of the appearance streams.\r\n     */\r\n    PDFTextField.prototype.updateAppearances = function (font, provider) {\r\n        assertIs(font, 'font', [[PDFFont, 'PDFFont']]);\r\n        assertOrUndefined(provider, 'provider', [Function]);\r\n        var widgets = this.acroField.getWidgets();\r\n        for (var idx = 0, len = widgets.length; idx < len; idx++) {\r\n            var widget = widgets[idx];\r\n            this.updateWidgetAppearance(widget, font, provider);\r\n        }\r\n        this.markAsClean();\r\n    };\r\n    PDFTextField.prototype.updateWidgetAppearance = function (widget, font, provider) {\r\n        var apProvider = provider !== null && provider !== void 0 ? provider : defaultTextFieldAppearanceProvider;\r\n        var appearances = normalizeAppearance(apProvider(this, widget, font));\r\n        this.updateWidgetAppearanceWithFont(widget, font, appearances);\r\n    };\r\n    /**\r\n     * > **NOTE:** You probably don't want to call this method directly. Instead,\r\n     * > consider using the [[PDFForm.getTextField]] method, which will create an\r\n     * > instance of [[PDFTextField]] for you.\r\n     *\r\n     * Create an instance of [[PDFTextField]] from an existing acroText and ref\r\n     *\r\n     * @param acroText The underlying `PDFAcroText` for this text field.\r\n     * @param ref The unique reference for this text field.\r\n     * @param doc The document to which this text field will belong.\r\n     */\r\n    PDFTextField.of = function (acroText, ref, doc) {\r\n        return new PDFTextField(acroText, ref, doc);\r\n    };\r\n    return PDFTextField;\r\n}(PDFField));\r\nexport default PDFTextField;\r\n//# sourceMappingURL=PDFTextField.js.map"]},"metadata":{},"sourceType":"module"}