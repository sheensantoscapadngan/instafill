{"ast":null,"code":"import { MethodNotImplementedError } from \"../errors\";\nimport Stream from \"./Stream\";\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The DecodeStream class contained in this file is a TypeScript port of the\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\n\nvar emptyBuffer = new Uint8Array(0);\n/**\n * Super class for the decoding streams\n */\n\nvar DecodeStream =\n/** @class */\nfunction () {\n  function DecodeStream(maybeMinBufferLength) {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = emptyBuffer;\n    this.minBufferLength = 512;\n\n    if (maybeMinBufferLength) {\n      // Compute the first power of two that is as big as maybeMinBufferLength.\n      while (this.minBufferLength < maybeMinBufferLength) {\n        this.minBufferLength *= 2;\n      }\n    }\n  }\n\n  Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\n    get: function () {\n      while (!this.eof && this.bufferLength === 0) {\n        this.readBlock();\n      }\n\n      return this.bufferLength === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DecodeStream.prototype.getByte = function () {\n    var pos = this.pos;\n\n    while (this.bufferLength <= pos) {\n      if (this.eof) {\n        return -1;\n      }\n\n      this.readBlock();\n    }\n\n    return this.buffer[this.pos++];\n  };\n\n  DecodeStream.prototype.getUint16 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n\n    return (b0 << 8) + b1;\n  };\n\n  DecodeStream.prototype.getInt32 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    var b2 = this.getByte();\n    var b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  };\n\n  DecodeStream.prototype.getBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n\n    var end;\n    var pos = this.pos;\n\n    if (length) {\n      this.ensureBuffer(pos + length);\n      end = pos + length;\n\n      while (!this.eof && this.bufferLength < end) {\n        this.readBlock();\n      }\n\n      var bufEnd = this.bufferLength;\n\n      if (end > bufEnd) {\n        end = bufEnd;\n      }\n    } else {\n      while (!this.eof) {\n        this.readBlock();\n      }\n\n      end = this.bufferLength;\n    }\n\n    this.pos = end;\n    var subarray = this.buffer.subarray(pos, end); // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n\n    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;\n  };\n\n  DecodeStream.prototype.peekByte = function () {\n    var peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  };\n\n  DecodeStream.prototype.peekBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n\n    var bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  };\n\n  DecodeStream.prototype.skip = function (n) {\n    if (!n) {\n      n = 1;\n    }\n\n    this.pos += n;\n  };\n\n  DecodeStream.prototype.reset = function () {\n    this.pos = 0;\n  };\n\n  DecodeStream.prototype.makeSubStream = function (start, length\n  /* dict */\n  ) {\n    var end = start + length;\n\n    while (this.bufferLength <= end && !this.eof) {\n      this.readBlock();\n    }\n\n    return new Stream(this.buffer, start, length\n    /* dict */\n    );\n  };\n\n  DecodeStream.prototype.decode = function () {\n    while (!this.eof) this.readBlock();\n\n    return this.buffer.subarray(0, this.bufferLength);\n  };\n\n  DecodeStream.prototype.readBlock = function () {\n    throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n  };\n\n  DecodeStream.prototype.ensureBuffer = function (requested) {\n    var buffer = this.buffer;\n\n    if (requested <= buffer.byteLength) {\n      return buffer;\n    }\n\n    var size = this.minBufferLength;\n\n    while (size < requested) {\n      size *= 2;\n    }\n\n    var buffer2 = new Uint8Array(size);\n    buffer2.set(buffer);\n    return this.buffer = buffer2;\n  };\n\n  return DecodeStream;\n}();\n\nexport default DecodeStream;","map":{"version":3,"sources":["../../../src/core/streams/DecodeStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MethodNotImplementedError } from \"../errors\";\nimport Stream from \"./Stream\";\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The DecodeStream class contained in this file is a TypeScript port of the\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\nvar emptyBuffer = new Uint8Array(0);\n/**\n * Super class for the decoding streams\n */\nvar DecodeStream = /** @class */ (function () {\n    function DecodeStream(maybeMinBufferLength) {\n        this.pos = 0;\n        this.bufferLength = 0;\n        this.eof = false;\n        this.buffer = emptyBuffer;\n        this.minBufferLength = 512;\n        if (maybeMinBufferLength) {\n            // Compute the first power of two that is as big as maybeMinBufferLength.\n            while (this.minBufferLength < maybeMinBufferLength) {\n                this.minBufferLength *= 2;\n            }\n        }\n    }\n    Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\n        get: function () {\n            while (!this.eof && this.bufferLength === 0) {\n                this.readBlock();\n            }\n            return this.bufferLength === 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DecodeStream.prototype.getByte = function () {\n        var pos = this.pos;\n        while (this.bufferLength <= pos) {\n            if (this.eof) {\n                return -1;\n            }\n            this.readBlock();\n        }\n        return this.buffer[this.pos++];\n    };\n    DecodeStream.prototype.getUint16 = function () {\n        var b0 = this.getByte();\n        var b1 = this.getByte();\n        if (b0 === -1 || b1 === -1) {\n            return -1;\n        }\n        return (b0 << 8) + b1;\n    };\n    DecodeStream.prototype.getInt32 = function () {\n        var b0 = this.getByte();\n        var b1 = this.getByte();\n        var b2 = this.getByte();\n        var b3 = this.getByte();\n        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n    };\n    DecodeStream.prototype.getBytes = function (length, forceClamped) {\n        if (forceClamped === void 0) { forceClamped = false; }\n        var end;\n        var pos = this.pos;\n        if (length) {\n            this.ensureBuffer(pos + length);\n            end = pos + length;\n            while (!this.eof && this.bufferLength < end) {\n                this.readBlock();\n            }\n            var bufEnd = this.bufferLength;\n            if (end > bufEnd) {\n                end = bufEnd;\n            }\n        }\n        else {\n            while (!this.eof) {\n                this.readBlock();\n            }\n            end = this.bufferLength;\n        }\n        this.pos = end;\n        var subarray = this.buffer.subarray(pos, end);\n        // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n        return forceClamped && !(subarray instanceof Uint8ClampedArray)\n            ? new Uint8ClampedArray(subarray)\n            : subarray;\n    };\n    DecodeStream.prototype.peekByte = function () {\n        var peekedByte = this.getByte();\n        this.pos--;\n        return peekedByte;\n    };\n    DecodeStream.prototype.peekBytes = function (length, forceClamped) {\n        if (forceClamped === void 0) { forceClamped = false; }\n        var bytes = this.getBytes(length, forceClamped);\n        this.pos -= bytes.length;\n        return bytes;\n    };\n    DecodeStream.prototype.skip = function (n) {\n        if (!n) {\n            n = 1;\n        }\n        this.pos += n;\n    };\n    DecodeStream.prototype.reset = function () {\n        this.pos = 0;\n    };\n    DecodeStream.prototype.makeSubStream = function (start, length /* dict */) {\n        var end = start + length;\n        while (this.bufferLength <= end && !this.eof) {\n            this.readBlock();\n        }\n        return new Stream(this.buffer, start, length /* dict */);\n    };\n    DecodeStream.prototype.decode = function () {\n        while (!this.eof)\n            this.readBlock();\n        return this.buffer.subarray(0, this.bufferLength);\n    };\n    DecodeStream.prototype.readBlock = function () {\n        throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n    };\n    DecodeStream.prototype.ensureBuffer = function (requested) {\n        var buffer = this.buffer;\n        if (requested <= buffer.byteLength) {\n            return buffer;\n        }\n        var size = this.minBufferLength;\n        while (size < requested) {\n            size *= 2;\n        }\n        var buffer2 = new Uint8Array(size);\n        buffer2.set(buffer);\n        return (this.buffer = buffer2);\n    };\n    return DecodeStream;\n}());\nexport default DecodeStream;\n//# sourceMappingURL=DecodeStream.js.map"]},"metadata":{},"sourceType":"module"}