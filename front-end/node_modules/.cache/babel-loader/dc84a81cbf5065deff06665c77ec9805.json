{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, toHexStringOfMinLength, utf16Decode, utf16Encode, pdfDocEncodingDecode, parseDate, hasUtf16BOM } from \"../../utils\";\nimport { InvalidPDFDateStringError } from \"../errors\";\n\nvar PDFHexString =\n/** @class */\nfunction (_super) {\n  __extends(PDFHexString, _super);\n\n  function PDFHexString(value) {\n    var _this = _super.call(this) || this;\n\n    _this.value = value;\n    return _this;\n  }\n\n  PDFHexString.prototype.asBytes = function () {\n    // Append a zero if the number of digits is odd. See PDF spec 7.3.4.3\n    var hex = this.value + (this.value.length % 2 === 1 ? '0' : '');\n    var hexLength = hex.length;\n    var bytes = new Uint8Array(hex.length / 2);\n    var hexOffset = 0;\n    var bytesOffset = 0; // Interpret each pair of hex digits as a single byte\n\n    while (hexOffset < hexLength) {\n      var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);\n      bytes[bytesOffset] = byte;\n      hexOffset += 2;\n      bytesOffset += 1;\n    }\n\n    return bytes;\n  };\n\n  PDFHexString.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    if (hasUtf16BOM(bytes)) return utf16Decode(bytes);\n    return pdfDocEncodingDecode(bytes);\n  };\n\n  PDFHexString.prototype.decodeDate = function () {\n    var text = this.decodeText();\n    var date = parseDate(text);\n    if (!date) throw new InvalidPDFDateStringError(text);\n    return date;\n  };\n\n  PDFHexString.prototype.asString = function () {\n    return this.value;\n  };\n\n  PDFHexString.prototype.clone = function () {\n    return PDFHexString.of(this.value);\n  };\n\n  PDFHexString.prototype.toString = function () {\n    return \"<\" + this.value + \">\";\n  };\n\n  PDFHexString.prototype.sizeInBytes = function () {\n    return this.value.length + 2;\n  };\n\n  PDFHexString.prototype.copyBytesInto = function (buffer, offset) {\n    buffer[offset++] = CharCodes.LessThan;\n    offset += copyStringIntoBuffer(this.value, buffer, offset);\n    buffer[offset++] = CharCodes.GreaterThan;\n    return this.value.length + 2;\n  };\n\n  PDFHexString.of = function (value) {\n    return new PDFHexString(value);\n  };\n\n  PDFHexString.fromText = function (value) {\n    var encoded = utf16Encode(value);\n    var hex = '';\n\n    for (var idx = 0, len = encoded.length; idx < len; idx++) {\n      hex += toHexStringOfMinLength(encoded[idx], 4);\n    }\n\n    return new PDFHexString(hex);\n  };\n\n  return PDFHexString;\n}(PDFObject);\n\nexport default PDFHexString;","map":{"version":3,"sources":["../../../src/core/objects/PDFHexString.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\r\nimport PDFObject from \"./PDFObject\";\r\nimport CharCodes from \"../syntax/CharCodes\";\r\nimport { copyStringIntoBuffer, toHexStringOfMinLength, utf16Decode, utf16Encode, pdfDocEncodingDecode, parseDate, hasUtf16BOM, } from \"../../utils\";\r\nimport { InvalidPDFDateStringError } from \"../errors\";\r\nvar PDFHexString = /** @class */ (function (_super) {\r\n    __extends(PDFHexString, _super);\r\n    function PDFHexString(value) {\r\n        var _this = _super.call(this) || this;\r\n        _this.value = value;\r\n        return _this;\r\n    }\r\n    PDFHexString.prototype.asBytes = function () {\r\n        // Append a zero if the number of digits is odd. See PDF spec 7.3.4.3\r\n        var hex = this.value + (this.value.length % 2 === 1 ? '0' : '');\r\n        var hexLength = hex.length;\r\n        var bytes = new Uint8Array(hex.length / 2);\r\n        var hexOffset = 0;\r\n        var bytesOffset = 0;\r\n        // Interpret each pair of hex digits as a single byte\r\n        while (hexOffset < hexLength) {\r\n            var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);\r\n            bytes[bytesOffset] = byte;\r\n            hexOffset += 2;\r\n            bytesOffset += 1;\r\n        }\r\n        return bytes;\r\n    };\r\n    PDFHexString.prototype.decodeText = function () {\r\n        var bytes = this.asBytes();\r\n        if (hasUtf16BOM(bytes))\r\n            return utf16Decode(bytes);\r\n        return pdfDocEncodingDecode(bytes);\r\n    };\r\n    PDFHexString.prototype.decodeDate = function () {\r\n        var text = this.decodeText();\r\n        var date = parseDate(text);\r\n        if (!date)\r\n            throw new InvalidPDFDateStringError(text);\r\n        return date;\r\n    };\r\n    PDFHexString.prototype.asString = function () {\r\n        return this.value;\r\n    };\r\n    PDFHexString.prototype.clone = function () {\r\n        return PDFHexString.of(this.value);\r\n    };\r\n    PDFHexString.prototype.toString = function () {\r\n        return \"<\" + this.value + \">\";\r\n    };\r\n    PDFHexString.prototype.sizeInBytes = function () {\r\n        return this.value.length + 2;\r\n    };\r\n    PDFHexString.prototype.copyBytesInto = function (buffer, offset) {\r\n        buffer[offset++] = CharCodes.LessThan;\r\n        offset += copyStringIntoBuffer(this.value, buffer, offset);\r\n        buffer[offset++] = CharCodes.GreaterThan;\r\n        return this.value.length + 2;\r\n    };\r\n    PDFHexString.of = function (value) { return new PDFHexString(value); };\r\n    PDFHexString.fromText = function (value) {\r\n        var encoded = utf16Encode(value);\r\n        var hex = '';\r\n        for (var idx = 0, len = encoded.length; idx < len; idx++) {\r\n            hex += toHexStringOfMinLength(encoded[idx], 4);\r\n        }\r\n        return new PDFHexString(hex);\r\n    };\r\n    return PDFHexString;\r\n}(PDFObject));\r\nexport default PDFHexString;\r\n//# sourceMappingURL=PDFHexString.js.map"]},"metadata":{},"sourceType":"module"}