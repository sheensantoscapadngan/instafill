{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFAcroField from \"./PDFAcroField\";\nimport PDFWidgetAnnotation from \"../annotation/PDFWidgetAnnotation\";\nimport { IndexOutOfBoundsError } from \"../errors\";\n\nvar PDFAcroTerminal =\n/** @class */\nfunction (_super) {\n  __extends(PDFAcroTerminal, _super);\n\n  function PDFAcroTerminal() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PDFAcroTerminal.prototype.FT = function () {\n    var nameOrRef = this.getInheritableAttribute(PDFName.of('FT'));\n    return this.dict.context.lookup(nameOrRef, PDFName);\n  };\n\n  PDFAcroTerminal.prototype.getWidgets = function () {\n    var kidDicts = this.Kids(); // This field is itself a widget\n\n    if (!kidDicts) return [PDFWidgetAnnotation.fromDict(this.dict)]; // This field's kids are its widgets\n\n    var widgets = new Array(kidDicts.size());\n\n    for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n      var dict = kidDicts.lookup(idx, PDFDict);\n      widgets[idx] = PDFWidgetAnnotation.fromDict(dict);\n    }\n\n    return widgets;\n  };\n\n  PDFAcroTerminal.prototype.addWidget = function (ref) {\n    var Kids = this.normalizedEntries().Kids;\n    Kids.push(ref);\n  };\n\n  PDFAcroTerminal.prototype.removeWidget = function (idx) {\n    var kidDicts = this.Kids();\n\n    if (!kidDicts) {\n      // This field is itself a widget\n      if (idx !== 0) throw new IndexOutOfBoundsError(idx, 0, 0);\n      this.setKids([]);\n    } else {\n      // This field's kids are its widgets\n      if (idx < 0 || idx > kidDicts.size()) {\n        throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());\n      }\n\n      kidDicts.remove(idx);\n    }\n  };\n\n  PDFAcroTerminal.prototype.normalizedEntries = function () {\n    var Kids = this.Kids(); // If this field is itself a widget (because it was only rendered once in\n    // the document, so the field and widget properties were merged) then we\n    // add itself to the `Kids` array. The alternative would be to try\n    // splitting apart the widget properties and creating a separate object\n    // for them.\n\n    if (!Kids) {\n      Kids = this.dict.context.obj([this.ref]);\n      this.dict.set(PDFName.of('Kids'), Kids);\n    }\n\n    return {\n      Kids: Kids\n    };\n  };\n\n  PDFAcroTerminal.fromDict = function (dict, ref) {\n    return new PDFAcroTerminal(dict, ref);\n  };\n\n  return PDFAcroTerminal;\n}(PDFAcroField);\n\nexport default PDFAcroTerminal;","map":{"version":3,"sources":["../../../src/core/acroform/PDFAcroTerminal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFAcroField from \"./PDFAcroField\";\nimport PDFWidgetAnnotation from \"../annotation/PDFWidgetAnnotation\";\nimport { IndexOutOfBoundsError } from \"../errors\";\nvar PDFAcroTerminal = /** @class */ (function (_super) {\n    __extends(PDFAcroTerminal, _super);\n    function PDFAcroTerminal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PDFAcroTerminal.prototype.FT = function () {\n        var nameOrRef = this.getInheritableAttribute(PDFName.of('FT'));\n        return this.dict.context.lookup(nameOrRef, PDFName);\n    };\n    PDFAcroTerminal.prototype.getWidgets = function () {\n        var kidDicts = this.Kids();\n        // This field is itself a widget\n        if (!kidDicts)\n            return [PDFWidgetAnnotation.fromDict(this.dict)];\n        // This field's kids are its widgets\n        var widgets = new Array(kidDicts.size());\n        for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n            var dict = kidDicts.lookup(idx, PDFDict);\n            widgets[idx] = PDFWidgetAnnotation.fromDict(dict);\n        }\n        return widgets;\n    };\n    PDFAcroTerminal.prototype.addWidget = function (ref) {\n        var Kids = this.normalizedEntries().Kids;\n        Kids.push(ref);\n    };\n    PDFAcroTerminal.prototype.removeWidget = function (idx) {\n        var kidDicts = this.Kids();\n        if (!kidDicts) {\n            // This field is itself a widget\n            if (idx !== 0)\n                throw new IndexOutOfBoundsError(idx, 0, 0);\n            this.setKids([]);\n        }\n        else {\n            // This field's kids are its widgets\n            if (idx < 0 || idx > kidDicts.size()) {\n                throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());\n            }\n            kidDicts.remove(idx);\n        }\n    };\n    PDFAcroTerminal.prototype.normalizedEntries = function () {\n        var Kids = this.Kids();\n        // If this field is itself a widget (because it was only rendered once in\n        // the document, so the field and widget properties were merged) then we\n        // add itself to the `Kids` array. The alternative would be to try\n        // splitting apart the widget properties and creating a separate object\n        // for them.\n        if (!Kids) {\n            Kids = this.dict.context.obj([this.ref]);\n            this.dict.set(PDFName.of('Kids'), Kids);\n        }\n        return { Kids: Kids };\n    };\n    PDFAcroTerminal.fromDict = function (dict, ref) {\n        return new PDFAcroTerminal(dict, ref);\n    };\n    return PDFAcroTerminal;\n}(PDFAcroField));\nexport default PDFAcroTerminal;\n//# sourceMappingURL=PDFAcroTerminal.js.map"]},"metadata":{},"sourceType":"module"}