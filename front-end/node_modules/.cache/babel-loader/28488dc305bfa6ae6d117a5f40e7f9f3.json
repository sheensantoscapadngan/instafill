{"ast":null,"code":"import { sortTransformProps } from './transform.js';\nimport { zeroLayout } from '../../utils/state.js';\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\n\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n  var transform = _a.transform,\n      transformKeys = _a.transformKeys;\n  var _c = _b.enableHardwareAcceleration,\n      enableHardwareAcceleration = _c === void 0 ? true : _c,\n      _d = _b.allowTransformNone,\n      allowTransformNone = _d === void 0 ? true : _d; // The transform string we're going to build into.\n\n  var transformString = \"\"; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\r\n * Build a transformOrigin style. Uses the same defaults as the browser for\r\n * undefined origins.\r\n */\n\n\nfunction buildTransformOrigin(_a) {\n  var _b = _a.originX,\n      originX = _b === void 0 ? \"50%\" : _b,\n      _c = _a.originY,\n      originY = _c === void 0 ? \"50%\" : _c,\n      _d = _a.originZ,\n      originZ = _d === void 0 ? 0 : _d;\n  return originX + \" \" + originY + \" \" + originZ;\n}\n/**\r\n * Build a transform style that takes a calculated delta between the element's current\r\n * space on screen and projects it into the desired space.\r\n */\n\n\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n      y = _a.y;\n  /**\r\n   * The translations we use to calculate are always relative to the viewport coordinate space.\r\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\r\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\r\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\r\n   */\n\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\r\n * Take the calculated delta origin and apply it as a transform string.\r\n */\n\n\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\n\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, buildTransform, buildTransformOrigin, identityProjection };","map":{"version":3,"sources":["D:/Documents/GitHub/instafill/front-end/node_modules/framer-motion/dist/es/render/html/utils/build-transform.js"],"names":["sortTransformProps","zeroLayout","translateAlias","x","y","z","transformPerspective","buildTransform","_a","_b","transformIsDefault","transformTemplate","transform","transformKeys","_c","enableHardwareAcceleration","_d","allowTransformNone","transformString","sort","transformHasZ","numTransformKeys","length","i","key","trim","buildTransformOrigin","originX","originY","originZ","buildLayoutProjectionTransform","treeScale","latestTransform","xTranslate","translate","yTranslate","rotate","rotateX","rotateY","scale","identityProjection","buildLayoutProjectionTransformOrigin","deltaFinal","origin","delta"],"mappings":"AAAA,SAASA,kBAAT,QAAmC,gBAAnC;AACA,SAASC,UAAT,QAA2B,sBAA3B;AAEA,IAAIC,cAAc,GAAG;AACjBC,EAAAA,CAAC,EAAE,YADc;AAEjBC,EAAAA,CAAC,EAAE,YAFc;AAGjBC,EAAAA,CAAC,EAAE,YAHc;AAIjBC,EAAAA,oBAAoB,EAAE;AAJL,CAArB;AAMA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,EAAxB,EAA4BC,EAA5B,EAAgCC,kBAAhC,EAAoDC,iBAApD,EAAuE;AACnE,MAAIC,SAAS,GAAGJ,EAAE,CAACI,SAAnB;AAAA,MAA8BC,aAAa,GAAGL,EAAE,CAACK,aAAjD;AACA,MAAIC,EAAE,GAAGL,EAAE,CAACM,0BAAZ;AAAA,MAAwCA,0BAA0B,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAA5F;AAAA,MAAgGE,EAAE,GAAGP,EAAE,CAACQ,kBAAxG;AAAA,MAA4HA,kBAAkB,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAAxK,CAFmE,CAGnE;;AACA,MAAIE,eAAe,GAAG,EAAtB,CAJmE,CAKnE;;AACAL,EAAAA,aAAa,CAACM,IAAd,CAAmBnB,kBAAnB,EANmE,CAOnE;AACA;;AACA,MAAIoB,aAAa,GAAG,KAApB,CATmE,CAUnE;;AACA,MAAIC,gBAAgB,GAAGR,aAAa,CAACS,MAArC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,gBAApB,EAAsCE,CAAC,EAAvC,EAA2C;AACvC,QAAIC,GAAG,GAAGX,aAAa,CAACU,CAAD,CAAvB;AACAL,IAAAA,eAAe,IAAI,CAAChB,cAAc,CAACsB,GAAD,CAAd,IAAuBA,GAAxB,IAA+B,GAA/B,GAAqCZ,SAAS,CAACY,GAAD,CAA9C,GAAsD,IAAzE;AACA,QAAIA,GAAG,KAAK,GAAZ,EACIJ,aAAa,GAAG,IAAhB;AACP;;AACD,MAAI,CAACA,aAAD,IAAkBL,0BAAtB,EAAkD;AAC9CG,IAAAA,eAAe,IAAI,eAAnB;AACH,GAFD,MAGK;AACDA,IAAAA,eAAe,GAAGA,eAAe,CAACO,IAAhB,EAAlB;AACH,GAvBkE,CAwBnE;AACA;;;AACA,MAAId,iBAAJ,EAAuB;AACnBO,IAAAA,eAAe,GAAGP,iBAAiB,CAACC,SAAD,EAAYF,kBAAkB,GAAG,EAAH,GAAQQ,eAAtC,CAAnC;AACH,GAFD,MAGK,IAAID,kBAAkB,IAAIP,kBAA1B,EAA8C;AAC/CQ,IAAAA,eAAe,GAAG,MAAlB;AACH;;AACD,SAAOA,eAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASQ,oBAAT,CAA8BlB,EAA9B,EAAkC;AAC9B,MAAIC,EAAE,GAAGD,EAAE,CAACmB,OAAZ;AAAA,MAAqBA,OAAO,GAAGlB,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAAvD;AAAA,MAA2DK,EAAE,GAAGN,EAAE,CAACoB,OAAnE;AAAA,MAA4EA,OAAO,GAAGd,EAAE,KAAK,KAAK,CAAZ,GAAgB,KAAhB,GAAwBA,EAA9G;AAAA,MAAkHE,EAAE,GAAGR,EAAE,CAACqB,OAA1H;AAAA,MAAmIA,OAAO,GAAGb,EAAE,KAAK,KAAK,CAAZ,GAAgB,CAAhB,GAAoBA,EAAjK;AACA,SAAOW,OAAO,GAAG,GAAV,GAAgBC,OAAhB,GAA0B,GAA1B,GAAgCC,OAAvC;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASC,8BAAT,CAAwCtB,EAAxC,EAA4CuB,SAA5C,EAAuDC,eAAvD,EAAwE;AACpE,MAAI7B,CAAC,GAAGK,EAAE,CAACL,CAAX;AAAA,MAAcC,CAAC,GAAGI,EAAE,CAACJ,CAArB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,MAAI6B,UAAU,GAAG9B,CAAC,CAAC+B,SAAF,GAAcH,SAAS,CAAC5B,CAAzC;AACA,MAAIgC,UAAU,GAAG/B,CAAC,CAAC8B,SAAF,GAAcH,SAAS,CAAC3B,CAAzC;AACA,MAAIQ,SAAS,GAAG,iBAAiBqB,UAAjB,GAA8B,MAA9B,GAAuCE,UAAvC,GAAoD,SAApE;;AACA,MAAIH,eAAJ,EAAqB;AACjB,QAAII,MAAM,GAAGJ,eAAe,CAACI,MAA7B;AAAA,QAAqCC,OAAO,GAAGL,eAAe,CAACK,OAA/D;AAAA,QAAwEC,OAAO,GAAGN,eAAe,CAACM,OAAlG;AACA,QAAIF,MAAJ,EACIxB,SAAS,IAAI,YAAYwB,MAAZ,GAAqB,IAAlC;AACJ,QAAIC,OAAJ,EACIzB,SAAS,IAAI,aAAayB,OAAb,GAAuB,IAApC;AACJ,QAAIC,OAAJ,EACI1B,SAAS,IAAI,aAAa0B,OAAb,GAAuB,IAApC;AACP;;AACD1B,EAAAA,SAAS,IAAI,WAAWT,CAAC,CAACoC,KAAb,GAAqB,IAArB,GAA4BnC,CAAC,CAACmC,KAA9B,GAAsC,GAAnD;AACA,SAAO,CAACP,eAAD,IAAoBpB,SAAS,KAAK4B,kBAAlC,GAAuD,EAAvD,GAA4D5B,SAAnE;AACH;AACD;AACA;AACA;;;AACA,SAAS6B,oCAAT,CAA8CjC,EAA9C,EAAkD;AAC9C,MAAIkC,UAAU,GAAGlC,EAAE,CAACkC,UAApB;AACA,SAAOA,UAAU,CAACvC,CAAX,CAAawC,MAAb,GAAsB,GAAtB,GAA4B,IAA5B,GAAmCD,UAAU,CAACtC,CAAX,CAAauC,MAAb,GAAsB,GAAzD,GAA+D,KAAtE;AACH;;AACD,IAAIH,kBAAkB,GAAGV,8BAA8B,CAAC7B,UAAU,CAAC2C,KAAZ,EAAmB3C,UAAU,CAAC8B,SAA9B,EAAyC;AAAE5B,EAAAA,CAAC,EAAE,CAAL;AAAQC,EAAAA,CAAC,EAAE;AAAX,CAAzC,CAAvD;AAEA,SAAS0B,8BAAT,EAAyCW,oCAAzC,EAA+ElC,cAA/E,EAA+FmB,oBAA/F,EAAqHc,kBAArH","sourcesContent":["import { sortTransformProps } from './transform.js';\r\nimport { zeroLayout } from '../../utils/state.js';\r\n\r\nvar translateAlias = {\r\n    x: \"translateX\",\r\n    y: \"translateY\",\r\n    z: \"translateZ\",\r\n    transformPerspective: \"perspective\",\r\n};\r\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\r\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\r\n    var transform = _a.transform, transformKeys = _a.transformKeys;\r\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\r\n    // The transform string we're going to build into.\r\n    var transformString = \"\";\r\n    // Transform keys into their default order - this will determine the output order.\r\n    transformKeys.sort(sortTransformProps);\r\n    // Track whether the defined transform has a defined z so we don't add a\r\n    // second to enable hardware acceleration\r\n    var transformHasZ = false;\r\n    // Loop over each transform and build them into transformString\r\n    var numTransformKeys = transformKeys.length;\r\n    for (var i = 0; i < numTransformKeys; i++) {\r\n        var key = transformKeys[i];\r\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\r\n        if (key === \"z\")\r\n            transformHasZ = true;\r\n    }\r\n    if (!transformHasZ && enableHardwareAcceleration) {\r\n        transformString += \"translateZ(0)\";\r\n    }\r\n    else {\r\n        transformString = transformString.trim();\r\n    }\r\n    // If we have a custom `transform` template, pass our transform values and\r\n    // generated transformString to that before returning\r\n    if (transformTemplate) {\r\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\r\n    }\r\n    else if (allowTransformNone && transformIsDefault) {\r\n        transformString = \"none\";\r\n    }\r\n    return transformString;\r\n}\r\n/**\r\n * Build a transformOrigin style. Uses the same defaults as the browser for\r\n * undefined origins.\r\n */\r\nfunction buildTransformOrigin(_a) {\r\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\r\n    return originX + \" \" + originY + \" \" + originZ;\r\n}\r\n/**\r\n * Build a transform style that takes a calculated delta between the element's current\r\n * space on screen and projects it into the desired space.\r\n */\r\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\r\n    var x = _a.x, y = _a.y;\r\n    /**\r\n     * The translations we use to calculate are always relative to the viewport coordinate space.\r\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\r\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\r\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\r\n     */\r\n    var xTranslate = x.translate / treeScale.x;\r\n    var yTranslate = y.translate / treeScale.y;\r\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\r\n    if (latestTransform) {\r\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\r\n        if (rotate)\r\n            transform += \"rotate(\" + rotate + \") \";\r\n        if (rotateX)\r\n            transform += \"rotateX(\" + rotateX + \") \";\r\n        if (rotateY)\r\n            transform += \"rotateY(\" + rotateY + \") \";\r\n    }\r\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\r\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\r\n}\r\n/**\r\n * Take the calculated delta origin and apply it as a transform string.\r\n */\r\nfunction buildLayoutProjectionTransformOrigin(_a) {\r\n    var deltaFinal = _a.deltaFinal;\r\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\r\n}\r\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\r\n\r\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, buildTransform, buildTransformOrigin, identityProjection };\r\n"]},"metadata":{},"sourceType":"module"}