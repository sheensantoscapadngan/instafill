{"ast":null,"code":"/*\n * Copyright 2012 Mozilla Foundation\n *\n * The RunLengthStream class contained in this file is a TypeScript port of the\n * JavaScript RunLengthStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\n\nvar RunLengthStream =\n/** @class */\nfunction (_super) {\n  __extends(RunLengthStream, _super);\n\n  function RunLengthStream(stream, maybeLength) {\n    var _this = _super.call(this, maybeLength) || this;\n\n    _this.stream = stream;\n    return _this;\n  }\n\n  RunLengthStream.prototype.readBlock = function () {\n    // The repeatHeader has following format. The first byte defines type of run\n    // and amount of bytes to repeat/copy: n = 0 through 127 - copy next n bytes\n    // (in addition to the second byte from the header), n = 129 through 255 -\n    // duplicate the second byte from the header (257 - n) times, n = 128 - end.\n    var repeatHeader = this.stream.getBytes(2);\n\n    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n      this.eof = true;\n      return;\n    }\n\n    var buffer;\n    var bufferLength = this.bufferLength;\n    var n = repeatHeader[0];\n\n    if (n < 128) {\n      // copy n bytes\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      buffer[bufferLength++] = repeatHeader[1];\n\n      if (n > 0) {\n        var source = this.stream.getBytes(n);\n        buffer.set(source, bufferLength);\n        bufferLength += n;\n      }\n    } else {\n      n = 257 - n;\n      var b = repeatHeader[1];\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n\n      for (var i = 0; i < n; i++) {\n        buffer[bufferLength++] = b;\n      }\n    }\n\n    this.bufferLength = bufferLength;\n  };\n\n  return RunLengthStream;\n}(DecodeStream);\n\nexport default RunLengthStream;","map":{"version":3,"sources":["../../../src/core/streams/RunLengthStream.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;AAEH,OAAO,YAAP,MAAmB,gBAAnB;;AAGA,IAAA,eAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA8B,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AAG5B,WAAA,eAAA,CAAY,MAAZ,EAAgC,WAAhC,EAAoD;AAApD,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN,KAAkB,IADpB;;AAEE,IAAA,KAAI,CAAC,MAAL,GAAc,MAAd;;AACD;;AAES,EAAA,eAAA,CAAA,SAAA,CAAA,SAAA,GAAV,YAAA;AACE;AACA;AACA;AACA;AACA,QAAM,YAAY,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAqB,CAArB,CAArB;;AACA,QAAI,CAAC,YAAD,IAAiB,YAAY,CAAC,MAAb,GAAsB,CAAvC,IAA4C,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAApE,EAAyE;AACvE,WAAK,GAAL,GAAW,IAAX;AACA;AACD;;AAED,QAAI,MAAJ;AACA,QAAI,YAAY,GAAG,KAAK,YAAxB;AACA,QAAI,CAAC,GAAG,YAAY,CAAC,CAAD,CAApB;;AACA,QAAI,CAAC,GAAG,GAAR,EAAa;AACX;AACA,MAAA,MAAM,GAAG,KAAK,YAAL,CAAkB,YAAY,GAAG,CAAf,GAAmB,CAArC,CAAT;AACA,MAAA,MAAM,CAAC,YAAY,EAAb,CAAN,GAAyB,YAAY,CAAC,CAAD,CAArC;;AACA,UAAI,CAAC,GAAG,CAAR,EAAW;AACT,YAAM,MAAM,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAqB,CAArB,CAAf;AACA,QAAA,MAAM,CAAC,GAAP,CAAW,MAAX,EAAmB,YAAnB;AACA,QAAA,YAAY,IAAI,CAAhB;AACD;AACF,KATD,MASO;AACL,MAAA,CAAC,GAAG,MAAM,CAAV;AACA,UAAM,CAAC,GAAG,YAAY,CAAC,CAAD,CAAtB;AACA,MAAA,MAAM,GAAG,KAAK,YAAL,CAAkB,YAAY,GAAG,CAAf,GAAmB,CAArC,CAAT;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AAC1B,QAAA,MAAM,CAAC,YAAY,EAAb,CAAN,GAAyB,CAAzB;AACD;AACF;;AACD,SAAK,YAAL,GAAoB,YAApB;AACD,GAhCS;;AAiCZ,SAAA,eAAA;AAAC,CAzCD,CAA8B,YAA9B,CAAA;;AA2CA,eAAe,eAAf","sourceRoot":"","sourcesContent":["/*\n * Copyright 2012 Mozilla Foundation\n *\n * The RunLengthStream class contained in this file is a TypeScript port of the\n * JavaScript RunLengthStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar RunLengthStream = /** @class */ (function (_super) {\n    __extends(RunLengthStream, _super);\n    function RunLengthStream(stream, maybeLength) {\n        var _this = _super.call(this, maybeLength) || this;\n        _this.stream = stream;\n        return _this;\n    }\n    RunLengthStream.prototype.readBlock = function () {\n        // The repeatHeader has following format. The first byte defines type of run\n        // and amount of bytes to repeat/copy: n = 0 through 127 - copy next n bytes\n        // (in addition to the second byte from the header), n = 129 through 255 -\n        // duplicate the second byte from the header (257 - n) times, n = 128 - end.\n        var repeatHeader = this.stream.getBytes(2);\n        if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n            this.eof = true;\n            return;\n        }\n        var buffer;\n        var bufferLength = this.bufferLength;\n        var n = repeatHeader[0];\n        if (n < 128) {\n            // copy n bytes\n            buffer = this.ensureBuffer(bufferLength + n + 1);\n            buffer[bufferLength++] = repeatHeader[1];\n            if (n > 0) {\n                var source = this.stream.getBytes(n);\n                buffer.set(source, bufferLength);\n                bufferLength += n;\n            }\n        }\n        else {\n            n = 257 - n;\n            var b = repeatHeader[1];\n            buffer = this.ensureBuffer(bufferLength + n + 1);\n            for (var i = 0; i < n; i++) {\n                buffer[bufferLength++] = b;\n            }\n        }\n        this.bufferLength = bufferLength;\n    };\n    return RunLengthStream;\n}(DecodeStream));\nexport default RunLengthStream;\n//# sourceMappingURL=RunLengthStream.js.map"]},"metadata":{},"sourceType":"module"}