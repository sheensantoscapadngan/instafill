{"ast":null,"code":"export var toCharCode = function (character) {\n  return character.charCodeAt(0);\n};\nexport var toCodePoint = function (character) {\n  return character.codePointAt(0);\n};\nexport var toHexStringOfMinLength = function (num, minLength) {\n  return padStart(num.toString(16), minLength, '0').toUpperCase();\n};\nexport var toHexString = function (num) {\n  return toHexStringOfMinLength(num, 2);\n};\nexport var charFromCode = function (code) {\n  return String.fromCharCode(code);\n};\nexport var charFromHexCode = function (hex) {\n  return charFromCode(parseInt(hex, 16));\n};\nexport var padStart = function (value, length, padChar) {\n  var padding = '';\n\n  for (var idx = 0, len = length - value.length; idx < len; idx++) {\n    padding += padChar;\n  }\n\n  return padding + value;\n};\nexport var copyStringIntoBuffer = function (str, buffer, offset) {\n  var length = str.length;\n\n  for (var idx = 0; idx < length; idx++) {\n    buffer[offset++] = str.charCodeAt(idx);\n  }\n\n  return length;\n};\nexport var addRandomSuffix = function (prefix, suffixLength) {\n  if (suffixLength === void 0) {\n    suffixLength = 4;\n  }\n\n  return prefix + \"-\" + Math.floor(Math.random() * Math.pow(10, suffixLength));\n};\nexport var escapeRegExp = function (str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nexport var cleanText = function (text) {\n  return text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n};\nexport var escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\nexport var newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\nexport var isNewlineChar = function (text) {\n  return /^[\\n\\f\\r\\u000B]$/.test(text);\n};\nexport var lineSplit = function (text) {\n  return text.split(/[\\n\\f\\r\\u000B]/);\n};\nexport var mergeLines = function (text) {\n  return text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n}; // JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\n\nexport var charAtIndex = function (text, index) {\n  // Get the first code unit and code unit value\n  var cuFirst = text.charCodeAt(index);\n  var cuSecond;\n  var nextIndex = index + 1;\n  var length = 1;\n\n  if ( // Check if it's the start of a surrogate pair.\n  cuFirst >= 0xd800 && cuFirst <= 0xdbff && // high surrogate\n  text.length > nextIndex // there is a next code unit\n  ) {\n      cuSecond = text.charCodeAt(nextIndex);\n      if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff) length = 2; // low surrogate\n    }\n\n  return [text.slice(index, index + length), length];\n};\nexport var charSplit = function (text) {\n  var chars = [];\n\n  for (var idx = 0, len = text.length; idx < len;) {\n    var _a = charAtIndex(text, idx),\n        c = _a[0],\n        cLen = _a[1];\n\n    chars.push(c);\n    idx += cLen;\n  }\n\n  return chars;\n};\n\nvar buildWordBreakRegex = function (wordBreaks) {\n  var newlineCharUnion = escapedNewlineChars.join('|');\n  var escapedRules = ['$'];\n\n  for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {\n    var wordBreak = wordBreaks[idx];\n\n    if (isNewlineChar(wordBreak)) {\n      throw new TypeError(\"`wordBreak` must not include \" + newlineCharUnion);\n    }\n\n    escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n  }\n\n  var breakRules = escapedRules.join('|');\n  return new RegExp(\"(\" + newlineCharUnion + \")|((.*?)(\" + breakRules + \"))\", 'gm');\n};\n\nexport var breakTextIntoLines = function (text, wordBreaks, maxWidth, computeWidthOfText) {\n  var regex = buildWordBreakRegex(wordBreaks);\n  var words = cleanText(text).match(regex);\n  var currLine = '';\n  var currWidth = 0;\n  var lines = [];\n\n  var pushCurrLine = function () {\n    if (currLine !== '') lines.push(currLine);\n    currLine = '';\n    currWidth = 0;\n  };\n\n  for (var idx = 0, len = words.length; idx < len; idx++) {\n    var word = words[idx];\n\n    if (isNewlineChar(word)) {\n      pushCurrLine();\n    } else {\n      var width = computeWidthOfText(word);\n      if (currWidth + width > maxWidth) pushCurrLine();\n      currLine += word;\n      currWidth += width;\n    }\n  }\n\n  pushCurrLine();\n  return lines;\n}; // See section \"7.9.4 Dates\" of the PDF specification\n\nvar dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\nexport var parseDate = function (dateStr) {\n  var match = dateStr.match(dateRegex);\n  if (!match) return undefined;\n  var year = match[1],\n      _a = match[2],\n      month = _a === void 0 ? '01' : _a,\n      _b = match[3],\n      day = _b === void 0 ? '01' : _b,\n      _c = match[4],\n      hours = _c === void 0 ? '00' : _c,\n      _d = match[5],\n      mins = _d === void 0 ? '00' : _d,\n      _e = match[6],\n      secs = _e === void 0 ? '00' : _e,\n      _f = match[7],\n      offsetSign = _f === void 0 ? 'Z' : _f,\n      _g = match[8],\n      offsetHours = _g === void 0 ? '00' : _g,\n      _h = match[9],\n      offsetMins = _h === void 0 ? '00' : _h; // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n\n  var tzOffset = offsetSign === 'Z' ? 'Z' : \"\" + offsetSign + offsetHours + \":\" + offsetMins;\n  var date = new Date(year + \"-\" + month + \"-\" + day + \"T\" + hours + \":\" + mins + \":\" + secs + tzOffset);\n  return date;\n};\nexport var findLastMatch = function (value, regex) {\n  var _a;\n\n  var position = 0;\n  var lastMatch;\n\n  while (position < value.length) {\n    var match = value.substring(position).match(regex);\n    if (!match) return {\n      match: lastMatch,\n      pos: position\n    };\n    lastMatch = match;\n    position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;\n  }\n\n  return {\n    match: lastMatch,\n    pos: position\n  };\n};","map":{"version":3,"sources":["../../src/utils/strings.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export var toCharCode = function (character) { return character.charCodeAt(0); };\nexport var toCodePoint = function (character) { return character.codePointAt(0); };\nexport var toHexStringOfMinLength = function (num, minLength) {\n    return padStart(num.toString(16), minLength, '0').toUpperCase();\n};\nexport var toHexString = function (num) { return toHexStringOfMinLength(num, 2); };\nexport var charFromCode = function (code) { return String.fromCharCode(code); };\nexport var charFromHexCode = function (hex) { return charFromCode(parseInt(hex, 16)); };\nexport var padStart = function (value, length, padChar) {\n    var padding = '';\n    for (var idx = 0, len = length - value.length; idx < len; idx++) {\n        padding += padChar;\n    }\n    return padding + value;\n};\nexport var copyStringIntoBuffer = function (str, buffer, offset) {\n    var length = str.length;\n    for (var idx = 0; idx < length; idx++) {\n        buffer[offset++] = str.charCodeAt(idx);\n    }\n    return length;\n};\nexport var addRandomSuffix = function (prefix, suffixLength) {\n    if (suffixLength === void 0) { suffixLength = 4; }\n    return prefix + \"-\" + Math.floor(Math.random() * Math.pow(10, suffixLength));\n};\nexport var escapeRegExp = function (str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\nexport var cleanText = function (text) {\n    return text.replace(/\\t|\\u0085|\\u2028|\\u2029/g, '    ').replace(/[\\b\\v]/g, '');\n};\nexport var escapedNewlineChars = ['\\\\n', '\\\\f', '\\\\r', '\\\\u000B'];\nexport var newlineChars = ['\\n', '\\f', '\\r', '\\u000B'];\nexport var isNewlineChar = function (text) { return /^[\\n\\f\\r\\u000B]$/.test(text); };\nexport var lineSplit = function (text) { return text.split(/[\\n\\f\\r\\u000B]/); };\nexport var mergeLines = function (text) {\n    return text.replace(/[\\n\\f\\r\\u000B]/g, ' ');\n};\n// JavaScript's String.charAt() method doesn work on strings containing UTF-16\n// characters (with high and low surrogate pairs), such as ðŸ’© (poo emoji). This\n// `charAtIndex()` function does.\n//\n// Credit: https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js#L14-L48\nexport var charAtIndex = function (text, index) {\n    // Get the first code unit and code unit value\n    var cuFirst = text.charCodeAt(index);\n    var cuSecond;\n    var nextIndex = index + 1;\n    var length = 1;\n    if (\n    // Check if it's the start of a surrogate pair.\n    cuFirst >= 0xd800 &&\n        cuFirst <= 0xdbff && // high surrogate\n        text.length > nextIndex // there is a next code unit\n    ) {\n        cuSecond = text.charCodeAt(nextIndex);\n        if (cuSecond >= 0xdc00 && cuSecond <= 0xdfff)\n            length = 2; // low surrogate\n    }\n    return [text.slice(index, index + length), length];\n};\nexport var charSplit = function (text) {\n    var chars = [];\n    for (var idx = 0, len = text.length; idx < len;) {\n        var _a = charAtIndex(text, idx), c = _a[0], cLen = _a[1];\n        chars.push(c);\n        idx += cLen;\n    }\n    return chars;\n};\nvar buildWordBreakRegex = function (wordBreaks) {\n    var newlineCharUnion = escapedNewlineChars.join('|');\n    var escapedRules = ['$'];\n    for (var idx = 0, len = wordBreaks.length; idx < len; idx++) {\n        var wordBreak = wordBreaks[idx];\n        if (isNewlineChar(wordBreak)) {\n            throw new TypeError(\"`wordBreak` must not include \" + newlineCharUnion);\n        }\n        escapedRules.push(wordBreak === '' ? '.' : escapeRegExp(wordBreak));\n    }\n    var breakRules = escapedRules.join('|');\n    return new RegExp(\"(\" + newlineCharUnion + \")|((.*?)(\" + breakRules + \"))\", 'gm');\n};\nexport var breakTextIntoLines = function (text, wordBreaks, maxWidth, computeWidthOfText) {\n    var regex = buildWordBreakRegex(wordBreaks);\n    var words = cleanText(text).match(regex);\n    var currLine = '';\n    var currWidth = 0;\n    var lines = [];\n    var pushCurrLine = function () {\n        if (currLine !== '')\n            lines.push(currLine);\n        currLine = '';\n        currWidth = 0;\n    };\n    for (var idx = 0, len = words.length; idx < len; idx++) {\n        var word = words[idx];\n        if (isNewlineChar(word)) {\n            pushCurrLine();\n        }\n        else {\n            var width = computeWidthOfText(word);\n            if (currWidth + width > maxWidth)\n                pushCurrLine();\n            currLine += word;\n            currWidth += width;\n        }\n    }\n    pushCurrLine();\n    return lines;\n};\n// See section \"7.9.4 Dates\" of the PDF specification\nvar dateRegex = /^D:(\\d\\d\\d\\d)(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?(\\d\\d)?([+\\-Z])?(\\d\\d)?'?(\\d\\d)?'?$/;\nexport var parseDate = function (dateStr) {\n    var match = dateStr.match(dateRegex);\n    if (!match)\n        return undefined;\n    var year = match[1], _a = match[2], month = _a === void 0 ? '01' : _a, _b = match[3], day = _b === void 0 ? '01' : _b, _c = match[4], hours = _c === void 0 ? '00' : _c, _d = match[5], mins = _d === void 0 ? '00' : _d, _e = match[6], secs = _e === void 0 ? '00' : _e, _f = match[7], offsetSign = _f === void 0 ? 'Z' : _f, _g = match[8], offsetHours = _g === void 0 ? '00' : _g, _h = match[9], offsetMins = _h === void 0 ? '00' : _h;\n    // http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n    var tzOffset = offsetSign === 'Z' ? 'Z' : \"\" + offsetSign + offsetHours + \":\" + offsetMins;\n    var date = new Date(year + \"-\" + month + \"-\" + day + \"T\" + hours + \":\" + mins + \":\" + secs + tzOffset);\n    return date;\n};\nexport var findLastMatch = function (value, regex) {\n    var _a;\n    var position = 0;\n    var lastMatch;\n    while (position < value.length) {\n        var match = value.substring(position).match(regex);\n        if (!match)\n            return { match: lastMatch, pos: position };\n        lastMatch = match;\n        position += ((_a = match.index) !== null && _a !== void 0 ? _a : 0) + match[0].length;\n    }\n    return { match: lastMatch, pos: position };\n};\n//# sourceMappingURL=strings.js.map"]},"metadata":{},"sourceType":"module"}