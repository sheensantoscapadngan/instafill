{"ast":null,"code":"import { __assign } from 'tslib';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { getFrameData } from 'framesync';\nimport { motionValue } from '../../../value/index.js';\nimport { animate } from '../../../animation/animate.js';\n\nfunction createCrossfader() {\n  /**\r\n   * The current state of the crossfade as a value between 0 and 1\r\n   */\n  var progress = motionValue(1);\n  var options = {\n    lead: undefined,\n    follow: undefined,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n  var leadState = {};\n  var followState = {};\n  /**\r\n   *\r\n   */\n\n  var isActive = false;\n  /**\r\n   *\r\n   */\n\n  var finalCrossfadeFrame = null;\n  /**\r\n   * Framestamp of the last frame we updated values at.\r\n   */\n\n  var prevUpdate = 0;\n\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead,\n        follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    return animate(progress, target, __assign(__assign({}, transition), {\n      onUpdate: function () {\n        lead && lead.scheduleRender();\n        follow && follow.scheduleRender();\n      },\n      onComplete: function () {\n        isActive = false;\n        /**\r\n         * If the crossfade animation is no longer active, flag a frame\r\n         * that we're still allowed to crossfade\r\n         */\n\n        finalCrossfadeFrame = getFrameData().timestamp;\n      }\n    }));\n  }\n\n  function updateCrossfade() {\n    var _a, _b;\n    /**\r\n     * We only want to compute the crossfade once per frame, so we\r\n     * compare the previous update framestamp with the current frame\r\n     * and early return if they're the same.\r\n     */\n\n\n    var timestamp = getFrameData().timestamp;\n    var lead = options.lead,\n        follow = options.follow;\n    if (timestamp === prevUpdate || !lead) return;\n    prevUpdate = timestamp;\n    /**\r\n     * Merge each component's latest values into our crossfaded state\r\n     * before crossfading.\r\n     */\n\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress.get();\n    /**\r\n     * Crossfade the opacity between the two components. This will result\r\n     * in a different opacity for each component.\r\n     */\n\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = mix(0, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n\n  return {\n    isActive: function () {\n      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function (transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function (transition) {\n      progress.set(options.follow ? 1 - progress.get() : 0);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function () {\n      return progress.set(1);\n    },\n    stop: function () {\n      return progress.stop();\n    },\n    getCrossfadeState: function (element) {\n      updateCrossfade();\n\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function (newOptions) {\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function () {\n      return leadState;\n    }\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\n\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  /**\r\n   * Mix border radius\r\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\r\n     * Currently we're only crossfading between numerical border radius.\r\n     * It would be possible to crossfade between percentages for a little\r\n     * extra bundle size.\r\n     */\n\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = mix(followRadius, leadRadius, p);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  /**\r\n   * Mix rotation\r\n   */\n\n\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  /**\r\n   * We only want to mix the background color if there's a follow element\r\n   * that we're not crossfading opacity between. For instance with switch\r\n   * AnimateSharedLayout animations, this helps the illusion of a continuous\r\n   * element being animated but also cuts down on the number of paints triggered\r\n   * for elements where opacity is doing that work for us.\r\n   */\n\n\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    /**\r\n     * This isn't ideal performance-wise as mixColor is creating a new function every frame.\r\n     * We could probably create a mixer that runs at the start of the animation but\r\n     * the idea behind the crossfader is that it runs dynamically between two potentially\r\n     * changing targets (ie opacity or borderRadius may be animating independently via variants)\r\n     */\n    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  var _a;\n\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nexport { createCrossfader };","map":{"version":3,"sources":["D:/Documents/GitHub/instafill/front-end/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js"],"names":["__assign","mix","progress","linear","mixColor","circOut","getFrameData","motionValue","animate","createCrossfader","options","lead","undefined","follow","crossfadeOpacity","preserveFollowOpacity","leadState","followState","isActive","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","target","transition","onUpdate","scheduleRender","onComplete","timestamp","updateCrossfade","_a","_b","latestLeadValues","getLatestValues","Object","assign","latestFollowValues","prevValues","p","get","leadTargetOpacity","opacity","followTargetOpacity","easeCrossfadeIn","easeCrossfadeOut","mixValues","Boolean","fromLead","toLead","set","reset","stop","getCrossfadeState","element","setOptions","newOptions","compress","min","max","easing","borders","numBorders","length","hasFollowElement","i","borderLabel","followRadius","getRadius","leadRadius","radius","rotate","backgroundColor","values","radiusName","borderRadius"],"mappings":"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","sourcesContent":["import { __assign } from 'tslib';\r\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\r\nimport { getFrameData } from 'framesync';\r\nimport { motionValue } from '../../../value/index.js';\r\nimport { animate } from '../../../animation/animate.js';\r\n\r\nfunction createCrossfader() {\r\n    /**\r\n     * The current state of the crossfade as a value between 0 and 1\r\n     */\r\n    var progress = motionValue(1);\r\n    var options = {\r\n        lead: undefined,\r\n        follow: undefined,\r\n        crossfadeOpacity: false,\r\n        preserveFollowOpacity: false,\r\n    };\r\n    var leadState = {};\r\n    var followState = {};\r\n    /**\r\n     *\r\n     */\r\n    var isActive = false;\r\n    /**\r\n     *\r\n     */\r\n    var finalCrossfadeFrame = null;\r\n    /**\r\n     * Framestamp of the last frame we updated values at.\r\n     */\r\n    var prevUpdate = 0;\r\n    function startCrossfadeAnimation(target, transition) {\r\n        var lead = options.lead, follow = options.follow;\r\n        isActive = true;\r\n        finalCrossfadeFrame = null;\r\n        return animate(progress, target, __assign(__assign({}, transition), { onUpdate: function () {\r\n                lead && lead.scheduleRender();\r\n                follow && follow.scheduleRender();\r\n            }, onComplete: function () {\r\n                isActive = false;\r\n                /**\r\n                 * If the crossfade animation is no longer active, flag a frame\r\n                 * that we're still allowed to crossfade\r\n                 */\r\n                finalCrossfadeFrame = getFrameData().timestamp;\r\n            } }));\r\n    }\r\n    function updateCrossfade() {\r\n        var _a, _b;\r\n        /**\r\n         * We only want to compute the crossfade once per frame, so we\r\n         * compare the previous update framestamp with the current frame\r\n         * and early return if they're the same.\r\n         */\r\n        var timestamp = getFrameData().timestamp;\r\n        var lead = options.lead, follow = options.follow;\r\n        if (timestamp === prevUpdate || !lead)\r\n            return;\r\n        prevUpdate = timestamp;\r\n        /**\r\n         * Merge each component's latest values into our crossfaded state\r\n         * before crossfading.\r\n         */\r\n        var latestLeadValues = lead.getLatestValues();\r\n        Object.assign(leadState, latestLeadValues);\r\n        var latestFollowValues = follow\r\n            ? follow.getLatestValues()\r\n            : options.prevValues;\r\n        Object.assign(followState, latestFollowValues);\r\n        var p = progress.get();\r\n        /**\r\n         * Crossfade the opacity between the two components. This will result\r\n         * in a different opacity for each component.\r\n         */\r\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\r\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\r\n        if (options.crossfadeOpacity && follow) {\r\n            leadState.opacity = mix(0, leadTargetOpacity, easeCrossfadeIn(p));\r\n            followState.opacity = options.preserveFollowOpacity\r\n                ? followTargetOpacity\r\n                : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\r\n        }\r\n        else if (!follow) {\r\n            leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\r\n        }\r\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\r\n    }\r\n    return {\r\n        isActive: function () {\r\n            return leadState &&\r\n                (isActive || getFrameData().timestamp === finalCrossfadeFrame);\r\n        },\r\n        fromLead: function (transition) {\r\n            return startCrossfadeAnimation(0, transition);\r\n        },\r\n        toLead: function (transition) {\r\n            progress.set(options.follow ? 1 - progress.get() : 0);\r\n            return startCrossfadeAnimation(1, transition);\r\n        },\r\n        reset: function () { return progress.set(1); },\r\n        stop: function () { return progress.stop(); },\r\n        getCrossfadeState: function (element) {\r\n            updateCrossfade();\r\n            if (element === options.lead) {\r\n                return leadState;\r\n            }\r\n            else if (element === options.follow) {\r\n                return followState;\r\n            }\r\n        },\r\n        setOptions: function (newOptions) {\r\n            options = newOptions;\r\n            leadState = {};\r\n            followState = {};\r\n        },\r\n        getLatestValues: function () {\r\n            return leadState;\r\n        },\r\n    };\r\n}\r\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\r\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\r\nfunction compress(min, max, easing) {\r\n    return function (p) {\r\n        // Could replace ifs with clamp\r\n        if (p < min)\r\n            return 0;\r\n        if (p > max)\r\n            return 1;\r\n        return easing(progress(min, max, p));\r\n    };\r\n}\r\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\r\nvar numBorders = borders.length;\r\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\r\n    /**\r\n     * Mix border radius\r\n     */\r\n    for (var i = 0; i < numBorders; i++) {\r\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\r\n        var followRadius = getRadius(latestFollowValues, borderLabel);\r\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\r\n        if (followRadius === undefined && leadRadius === undefined)\r\n            continue;\r\n        followRadius || (followRadius = 0);\r\n        leadRadius || (leadRadius = 0);\r\n        /**\r\n         * Currently we're only crossfading between numerical border radius.\r\n         * It would be possible to crossfade between percentages for a little\r\n         * extra bundle size.\r\n         */\r\n        if (typeof followRadius === \"number\" &&\r\n            typeof leadRadius === \"number\") {\r\n            var radius = mix(followRadius, leadRadius, p);\r\n            leadState[borderLabel] = followState[borderLabel] = radius;\r\n        }\r\n    }\r\n    /**\r\n     * Mix rotation\r\n     */\r\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\r\n        var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\r\n        leadState.rotate = followState.rotate = rotate;\r\n    }\r\n    /**\r\n     * We only want to mix the background color if there's a follow element\r\n     * that we're not crossfading opacity between. For instance with switch\r\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\r\n     * element being animated but also cuts down on the number of paints triggered\r\n     * for elements where opacity is doing that work for us.\r\n     */\r\n    if (!hasFollowElement &&\r\n        latestLeadValues.backgroundColor &&\r\n        latestFollowValues.backgroundColor) {\r\n        /**\r\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\r\n         * We could probably create a mixer that runs at the start of the animation but\r\n         * the idea behind the crossfader is that it runs dynamically between two potentially\r\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\r\n         */\r\n        leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\r\n    }\r\n}\r\nfunction getRadius(values, radiusName) {\r\n    var _a;\r\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\r\n}\r\n\r\nexport { createCrossfader };\r\n"]},"metadata":{},"sourceType":"module"}