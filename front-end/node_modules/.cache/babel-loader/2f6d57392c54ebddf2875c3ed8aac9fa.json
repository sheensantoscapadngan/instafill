{"ast":null,"code":"import { createElement, Component } from 'react';\nimport { __extends, __assign } from 'tslib';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { Presence } from './types.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { layoutStack } from './utils/stack.js';\nimport { resetRotate } from './utils/rotate.js';\n/**\r\n * @public\r\n */\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * A list of all the children in the shared layout\r\n     */\n\n\n    _this.children = new Set();\n    /**\r\n     * As animate components with a defined `layoutId` are added/removed to the tree,\r\n     * we store them in order. When one is added, it will animate out from the\r\n     * previous one, and when it's removed, it'll animate to the previous one.\r\n     */\n\n    _this.stacks = new Map();\n    /**\r\n     * Track whether the component has mounted. If it hasn't, the presence of added children\r\n     * are set to Present, whereas if it has they're considered Entering\r\n     */\n\n    _this.hasMounted = false;\n    /**\r\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\r\n     * and schedule one.\r\n     */\n\n    _this.updateScheduled = false;\n    /**\r\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\r\n     */\n\n    _this.renderScheduled = false;\n    /**\r\n     * The methods provided to all children in the shared layout tree.\r\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\r\n     * Reset update and render scheduled status\r\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\r\n     * Update presence metadata based on the latest AnimatePresence status.\r\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\r\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\r\n     * Create a handler which we can use to flush the children animations\r\n     */\n\n    var handler = {\n      measureLayout: function (child) {\n        return child.updateLayoutMeasurement();\n      },\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\r\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\r\n     * This requires some co-ordination across components to stop layout thrashing\r\n     * and ensure measurements are taken at the correct time.\r\n     *\r\n     * Here we use that same mechanism of schedule/flush.\r\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\r\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\r\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\r\n     * Flag we've scheduled an update\r\n     */\n\n    this.updateScheduled = true;\n    /**\r\n     * Write: Reset rotation transforms so bounding boxes can be accurately measured.\r\n     */\n\n    this.children.forEach(function (child) {\n      return resetRotate(child);\n    });\n    /**\r\n     * Read: Snapshot children\r\n     */\n\n    this.children.forEach(function (child) {\n      return child.snapshotViewportBox();\n    });\n    /**\r\n     * Every child keeps a local snapshot, but we also want to record\r\n     * snapshots of the visible children as, if they're are being removed\r\n     * in this render, we can still access them.\r\n     *\r\n     * TODO: What would be better here is doing a single loop where we\r\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\r\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\r\n     * Force a rerender by setting state if we aren't already going to render.\r\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\r\n   * Return a stack of animate children based on the provided layoutId.\r\n   * Will create a stack if none currently exists with that layoutId.\r\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(Component);\n\nexport { AnimateSharedLayout };","map":{"version":3,"sources":["D:/programming stuff i dont save on oneDrive/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js"],"names":["createElement","Component","__extends","__assign","MotionContext","Presence","createBatcher","SharedLayoutContext","layoutStack","resetRotate","AnimateSharedLayout","_super","_this","apply","arguments","children","Set","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","syncUpdate","force","scheduleUpdate","forceUpdate","register","child","addChild","remove","removeChild","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","presence","Exiting","Entering","Present","updateStacks","handler","measureLayout","updateLayoutMeasurement","layoutReady","getLayoutId","undefined","stack","getStack","animate","notifyLayoutReady","parent","context","visualElement","add","flush","clearSnapshot","updateLeadAndFollow","snapshotViewportBox","updateSnapshot","addToStack","delete","removeFromStack","id","has","set","get","render","Provider","value","contextType"],"mappings":"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","sourcesContent":["import { createElement, Component } from 'react';\r\nimport { __extends, __assign } from 'tslib';\r\nimport { MotionContext } from '../../context/MotionContext/index.js';\r\nimport { Presence } from './types.js';\r\nimport { createBatcher } from './utils/batcher.js';\r\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\r\nimport { layoutStack } from './utils/stack.js';\r\nimport { resetRotate } from './utils/rotate.js';\r\n\r\n/**\r\n * @public\r\n */\r\nvar AnimateSharedLayout = /** @class */ (function (_super) {\r\n    __extends(AnimateSharedLayout, _super);\r\n    function AnimateSharedLayout() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * A list of all the children in the shared layout\r\n         */\r\n        _this.children = new Set();\r\n        /**\r\n         * As animate components with a defined `layoutId` are added/removed to the tree,\r\n         * we store them in order. When one is added, it will animate out from the\r\n         * previous one, and when it's removed, it'll animate to the previous one.\r\n         */\r\n        _this.stacks = new Map();\r\n        /**\r\n         * Track whether the component has mounted. If it hasn't, the presence of added children\r\n         * are set to Present, whereas if it has they're considered Entering\r\n         */\r\n        _this.hasMounted = false;\r\n        /**\r\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\r\n         * and schedule one.\r\n         */\r\n        _this.updateScheduled = false;\r\n        /**\r\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\r\n         */\r\n        _this.renderScheduled = false;\r\n        /**\r\n         * The methods provided to all children in the shared layout tree.\r\n         */\r\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\r\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\r\n                // all children subscribed to the SharedLayout context.\r\n                _this.syncContext = __assign({}, _this.syncContext);\r\n                _this.scheduleUpdate(true);\r\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\r\n        return _this;\r\n    }\r\n    AnimateSharedLayout.prototype.componentDidMount = function () {\r\n        this.hasMounted = true;\r\n    };\r\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\r\n        this.startLayoutAnimation();\r\n    };\r\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\r\n        this.renderScheduled = true;\r\n        return true;\r\n    };\r\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\r\n        var _this = this;\r\n        /**\r\n         * Reset update and render scheduled status\r\n         */\r\n        this.renderScheduled = this.updateScheduled = false;\r\n        var type = this.props.type;\r\n        /**\r\n         * Update presence metadata based on the latest AnimatePresence status.\r\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\r\n         */\r\n        this.children.forEach(function (child) {\r\n            if (!child.isPresent) {\r\n                child.presence = Presence.Exiting;\r\n            }\r\n            else if (child.presence !== Presence.Entering) {\r\n                child.presence =\r\n                    child.presence === Presence.Exiting\r\n                        ? Presence.Entering\r\n                        : Presence.Present;\r\n            }\r\n        });\r\n        this.updateStacks();\r\n        /**\r\n         * Create a handler which we can use to flush the children animations\r\n         */\r\n        var handler = {\r\n            measureLayout: function (child) { return child.updateLayoutMeasurement(); },\r\n            layoutReady: function (child) {\r\n                if (child.getLayoutId() !== undefined) {\r\n                    var stack = _this.getStack(child);\r\n                    stack.animate(child, type === \"crossfade\");\r\n                }\r\n                else {\r\n                    child.notifyLayoutReady();\r\n                }\r\n            },\r\n            parent: this.context.visualElement,\r\n        };\r\n        /**\r\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\r\n         * This requires some co-ordination across components to stop layout thrashing\r\n         * and ensure measurements are taken at the correct time.\r\n         *\r\n         * Here we use that same mechanism of schedule/flush.\r\n         */\r\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\r\n        this.syncContext.flush(handler);\r\n        /**\r\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\r\n         */\r\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\r\n    };\r\n    AnimateSharedLayout.prototype.updateStacks = function () {\r\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\r\n    };\r\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\r\n        if (force === void 0) { force = false; }\r\n        if (!(force || !this.updateScheduled))\r\n            return;\r\n        /**\r\n         * Flag we've scheduled an update\r\n         */\r\n        this.updateScheduled = true;\r\n        /**\r\n         * Write: Reset rotation transforms so bounding boxes can be accurately measured.\r\n         */\r\n        this.children.forEach(function (child) { return resetRotate(child); });\r\n        /**\r\n         * Read: Snapshot children\r\n         */\r\n        this.children.forEach(function (child) { return child.snapshotViewportBox(); });\r\n        /**\r\n         * Every child keeps a local snapshot, but we also want to record\r\n         * snapshots of the visible children as, if they're are being removed\r\n         * in this render, we can still access them.\r\n         *\r\n         * TODO: What would be better here is doing a single loop where we\r\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\r\n         */\r\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\r\n        /**\r\n         * Force a rerender by setting state if we aren't already going to render.\r\n         */\r\n        if (force || !this.renderScheduled) {\r\n            this.renderScheduled = true;\r\n            this.forceUpdate();\r\n        }\r\n    };\r\n    AnimateSharedLayout.prototype.addChild = function (child) {\r\n        this.children.add(child);\r\n        this.addToStack(child);\r\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\r\n    };\r\n    AnimateSharedLayout.prototype.removeChild = function (child) {\r\n        this.scheduleUpdate();\r\n        this.children.delete(child);\r\n        this.removeFromStack(child);\r\n    };\r\n    AnimateSharedLayout.prototype.addToStack = function (child) {\r\n        var stack = this.getStack(child);\r\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\r\n    };\r\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\r\n        var stack = this.getStack(child);\r\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\r\n    };\r\n    /**\r\n     * Return a stack of animate children based on the provided layoutId.\r\n     * Will create a stack if none currently exists with that layoutId.\r\n     */\r\n    AnimateSharedLayout.prototype.getStack = function (child) {\r\n        var id = child.getLayoutId();\r\n        if (id === undefined)\r\n            return;\r\n        // Create stack if it doesn't already exist\r\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\r\n        return this.stacks.get(id);\r\n    };\r\n    AnimateSharedLayout.prototype.render = function () {\r\n        return (createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\r\n    };\r\n    AnimateSharedLayout.contextType = MotionContext;\r\n    return AnimateSharedLayout;\r\n}(Component));\r\n\r\nexport { AnimateSharedLayout };\r\n"]},"metadata":{},"sourceType":"module"}