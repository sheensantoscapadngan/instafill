{"ast":null,"code":"import { MethodNotImplementedError } from \"../errors\";\nimport Stream from \"./Stream\";\n/*\r\n * Copyright 2012 Mozilla Foundation\r\n *\r\n * The DecodeStream class contained in this file is a TypeScript port of the\r\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\r\n * under the Apache 2.0 open source license.\r\n */\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\n\nvar emptyBuffer = new Uint8Array(0);\n/**\r\n * Super class for the decoding streams\r\n */\n\nvar DecodeStream =\n/** @class */\nfunction () {\n  function DecodeStream(maybeMinBufferLength) {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = emptyBuffer;\n    this.minBufferLength = 512;\n\n    if (maybeMinBufferLength) {\n      // Compute the first power of two that is as big as maybeMinBufferLength.\n      while (this.minBufferLength < maybeMinBufferLength) {\n        this.minBufferLength *= 2;\n      }\n    }\n  }\n\n  Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\n    get: function () {\n      while (!this.eof && this.bufferLength === 0) {\n        this.readBlock();\n      }\n\n      return this.bufferLength === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DecodeStream.prototype.getByte = function () {\n    var pos = this.pos;\n\n    while (this.bufferLength <= pos) {\n      if (this.eof) {\n        return -1;\n      }\n\n      this.readBlock();\n    }\n\n    return this.buffer[this.pos++];\n  };\n\n  DecodeStream.prototype.getUint16 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n\n    return (b0 << 8) + b1;\n  };\n\n  DecodeStream.prototype.getInt32 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    var b2 = this.getByte();\n    var b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  };\n\n  DecodeStream.prototype.getBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n\n    var end;\n    var pos = this.pos;\n\n    if (length) {\n      this.ensureBuffer(pos + length);\n      end = pos + length;\n\n      while (!this.eof && this.bufferLength < end) {\n        this.readBlock();\n      }\n\n      var bufEnd = this.bufferLength;\n\n      if (end > bufEnd) {\n        end = bufEnd;\n      }\n    } else {\n      while (!this.eof) {\n        this.readBlock();\n      }\n\n      end = this.bufferLength;\n    }\n\n    this.pos = end;\n    var subarray = this.buffer.subarray(pos, end); // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n\n    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;\n  };\n\n  DecodeStream.prototype.peekByte = function () {\n    var peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  };\n\n  DecodeStream.prototype.peekBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n\n    var bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  };\n\n  DecodeStream.prototype.skip = function (n) {\n    if (!n) {\n      n = 1;\n    }\n\n    this.pos += n;\n  };\n\n  DecodeStream.prototype.reset = function () {\n    this.pos = 0;\n  };\n\n  DecodeStream.prototype.makeSubStream = function (start, length\n  /* dict */\n  ) {\n    var end = start + length;\n\n    while (this.bufferLength <= end && !this.eof) {\n      this.readBlock();\n    }\n\n    return new Stream(this.buffer, start, length\n    /* dict */\n    );\n  };\n\n  DecodeStream.prototype.decode = function () {\n    while (!this.eof) this.readBlock();\n\n    return this.buffer.subarray(0, this.bufferLength);\n  };\n\n  DecodeStream.prototype.readBlock = function () {\n    throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n  };\n\n  DecodeStream.prototype.ensureBuffer = function (requested) {\n    var buffer = this.buffer;\n\n    if (requested <= buffer.byteLength) {\n      return buffer;\n    }\n\n    var size = this.minBufferLength;\n\n    while (size < requested) {\n      size *= 2;\n    }\n\n    var buffer2 = new Uint8Array(size);\n    buffer2.set(buffer);\n    return this.buffer = buffer2;\n  };\n\n  return DecodeStream;\n}();\n\nexport default DecodeStream;","map":{"version":3,"sources":["../../../src/core/streams/DecodeStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MethodNotImplementedError } from \"../errors\";\r\nimport Stream from \"./Stream\";\r\n/*\r\n * Copyright 2012 Mozilla Foundation\r\n *\r\n * The DecodeStream class contained in this file is a TypeScript port of the\r\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\r\n * under the Apache 2.0 open source license.\r\n */\r\n// Lots of DecodeStreams are created whose buffers are never used.  For these\r\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\r\n// having special cases that would be required if we used |null| for an empty\r\n// buffer.\r\nvar emptyBuffer = new Uint8Array(0);\r\n/**\r\n * Super class for the decoding streams\r\n */\r\nvar DecodeStream = /** @class */ (function () {\r\n    function DecodeStream(maybeMinBufferLength) {\r\n        this.pos = 0;\r\n        this.bufferLength = 0;\r\n        this.eof = false;\r\n        this.buffer = emptyBuffer;\r\n        this.minBufferLength = 512;\r\n        if (maybeMinBufferLength) {\r\n            // Compute the first power of two that is as big as maybeMinBufferLength.\r\n            while (this.minBufferLength < maybeMinBufferLength) {\r\n                this.minBufferLength *= 2;\r\n            }\r\n        }\r\n    }\r\n    Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\r\n        get: function () {\r\n            while (!this.eof && this.bufferLength === 0) {\r\n                this.readBlock();\r\n            }\r\n            return this.bufferLength === 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    DecodeStream.prototype.getByte = function () {\r\n        var pos = this.pos;\r\n        while (this.bufferLength <= pos) {\r\n            if (this.eof) {\r\n                return -1;\r\n            }\r\n            this.readBlock();\r\n        }\r\n        return this.buffer[this.pos++];\r\n    };\r\n    DecodeStream.prototype.getUint16 = function () {\r\n        var b0 = this.getByte();\r\n        var b1 = this.getByte();\r\n        if (b0 === -1 || b1 === -1) {\r\n            return -1;\r\n        }\r\n        return (b0 << 8) + b1;\r\n    };\r\n    DecodeStream.prototype.getInt32 = function () {\r\n        var b0 = this.getByte();\r\n        var b1 = this.getByte();\r\n        var b2 = this.getByte();\r\n        var b3 = this.getByte();\r\n        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\r\n    };\r\n    DecodeStream.prototype.getBytes = function (length, forceClamped) {\r\n        if (forceClamped === void 0) { forceClamped = false; }\r\n        var end;\r\n        var pos = this.pos;\r\n        if (length) {\r\n            this.ensureBuffer(pos + length);\r\n            end = pos + length;\r\n            while (!this.eof && this.bufferLength < end) {\r\n                this.readBlock();\r\n            }\r\n            var bufEnd = this.bufferLength;\r\n            if (end > bufEnd) {\r\n                end = bufEnd;\r\n            }\r\n        }\r\n        else {\r\n            while (!this.eof) {\r\n                this.readBlock();\r\n            }\r\n            end = this.bufferLength;\r\n        }\r\n        this.pos = end;\r\n        var subarray = this.buffer.subarray(pos, end);\r\n        // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\r\n        return forceClamped && !(subarray instanceof Uint8ClampedArray)\r\n            ? new Uint8ClampedArray(subarray)\r\n            : subarray;\r\n    };\r\n    DecodeStream.prototype.peekByte = function () {\r\n        var peekedByte = this.getByte();\r\n        this.pos--;\r\n        return peekedByte;\r\n    };\r\n    DecodeStream.prototype.peekBytes = function (length, forceClamped) {\r\n        if (forceClamped === void 0) { forceClamped = false; }\r\n        var bytes = this.getBytes(length, forceClamped);\r\n        this.pos -= bytes.length;\r\n        return bytes;\r\n    };\r\n    DecodeStream.prototype.skip = function (n) {\r\n        if (!n) {\r\n            n = 1;\r\n        }\r\n        this.pos += n;\r\n    };\r\n    DecodeStream.prototype.reset = function () {\r\n        this.pos = 0;\r\n    };\r\n    DecodeStream.prototype.makeSubStream = function (start, length /* dict */) {\r\n        var end = start + length;\r\n        while (this.bufferLength <= end && !this.eof) {\r\n            this.readBlock();\r\n        }\r\n        return new Stream(this.buffer, start, length /* dict */);\r\n    };\r\n    DecodeStream.prototype.decode = function () {\r\n        while (!this.eof)\r\n            this.readBlock();\r\n        return this.buffer.subarray(0, this.bufferLength);\r\n    };\r\n    DecodeStream.prototype.readBlock = function () {\r\n        throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\r\n    };\r\n    DecodeStream.prototype.ensureBuffer = function (requested) {\r\n        var buffer = this.buffer;\r\n        if (requested <= buffer.byteLength) {\r\n            return buffer;\r\n        }\r\n        var size = this.minBufferLength;\r\n        while (size < requested) {\r\n            size *= 2;\r\n        }\r\n        var buffer2 = new Uint8Array(size);\r\n        buffer2.set(buffer);\r\n        return (this.buffer = buffer2);\r\n    };\r\n    return DecodeStream;\r\n}());\r\nexport default DecodeStream;\r\n//# sourceMappingURL=DecodeStream.js.map"]},"metadata":{},"sourceType":"module"}