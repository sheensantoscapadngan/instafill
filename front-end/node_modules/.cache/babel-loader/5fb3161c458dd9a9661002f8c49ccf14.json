{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\"; // TODO: Throw error if eof is reached before finishing object parse...\n\nvar PDFObjectParser =\n/** @class */\nfunction (_super) {\n  __extends(PDFObjectParser, _super);\n\n  function PDFObjectParser(byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n\n    var _this = _super.call(this, byteStream, capNumbers) || this;\n\n    _this.context = context;\n    return _this;\n  } // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n\n\n  PDFObjectParser.prototype.parseObject = function () {\n    this.skipWhitespaceAndComments();\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n    var byte = this.bytes.peek();\n\n    if (byte === CharCodes.LessThan && this.bytes.peekAhead(1) === CharCodes.LessThan) {\n      return this.parseDictOrStream();\n    }\n\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  };\n\n  PDFObjectParser.prototype.parseNumberOrRef = function () {\n    var firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n    var lookaheadStart = this.bytes.offset();\n\n    if (IsDigit[this.bytes.peek()]) {\n      var secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  }; // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n\n\n  PDFObjectParser.prototype.parseHexString = function () {\n    var value = '';\n    this.bytes.assertNext(CharCodes.LessThan);\n\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    return PDFHexString.of(value);\n  };\n\n  PDFObjectParser.prototype.parseString = function () {\n    var nestingLvl = 0;\n    var isEscaped = false;\n    var value = '';\n\n    while (!this.bytes.done()) {\n      var byte = this.bytes.next();\n      value += charFromCode(byte); // Check for unescaped parenthesis\n\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      } // Track whether current character is being escaped or not\n\n\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      } // Once (if) the unescaped parenthesis balance out, return their contents\n\n\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  }; // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n\n\n  PDFObjectParser.prototype.parseName = function () {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n    var name = '';\n\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n\n    return PDFName.of(name);\n  };\n\n  PDFObjectParser.prototype.parseArray = function () {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n    var pdfArray = PDFArray.withContext(this.context);\n\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      var element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  };\n\n  PDFObjectParser.prototype.parseDict = function () {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n    var dict = new Map();\n\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan && this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n      var key = this.parseName();\n      var value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    var Type = dict.get(PDFName.of('Type'));\n\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  };\n\n  PDFObjectParser.prototype.parseDictOrStream = function () {\n    var startPos = this.bytes.position();\n    var dict = this.parseDict();\n    this.skipWhitespaceAndComments();\n\n    if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {\n      return dict;\n    }\n\n    var start = this.bytes.offset();\n    var end;\n    var Length = dict.get(PDFName.of('Length'));\n\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n\n    var contents = this.bytes.slice(start, end);\n    return PDFRawStream.of(dict, contents);\n  };\n\n  PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n    // Move to end of stream, while handling nested streams\n    var nestingLvl = 1;\n    var end = this.bytes.offset();\n\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n\n      if (nestingLvl === 0) break;\n    }\n\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n    return end;\n  };\n\n  PDFObjectParser.forBytes = function (bytes, context, capNumbers) {\n    return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n  };\n\n  PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n\n    return new PDFObjectParser(byteStream, context, capNumbers);\n  };\n\n  return PDFObjectParser;\n}(BaseParser);\n\nexport default PDFObjectParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFObjectParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError, } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */ (function (_super) {\n    __extends(PDFObjectParser, _super);\n    function PDFObjectParser(byteStream, context, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        var _this = _super.call(this, byteStream, capNumbers) || this;\n        _this.context = context;\n        return _this;\n    }\n    // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n    PDFObjectParser.prototype.parseObject = function () {\n        this.skipWhitespaceAndComments();\n        if (this.matchKeyword(Keywords.true))\n            return PDFBool.True;\n        if (this.matchKeyword(Keywords.false))\n            return PDFBool.False;\n        if (this.matchKeyword(Keywords.null))\n            return PDFNull;\n        var byte = this.bytes.peek();\n        if (byte === CharCodes.LessThan &&\n            this.bytes.peekAhead(1) === CharCodes.LessThan) {\n            return this.parseDictOrStream();\n        }\n        if (byte === CharCodes.LessThan)\n            return this.parseHexString();\n        if (byte === CharCodes.LeftParen)\n            return this.parseString();\n        if (byte === CharCodes.ForwardSlash)\n            return this.parseName();\n        if (byte === CharCodes.LeftSquareBracket)\n            return this.parseArray();\n        if (IsNumeric[byte])\n            return this.parseNumberOrRef();\n        throw new PDFObjectParsingError(this.bytes.position(), byte);\n    };\n    PDFObjectParser.prototype.parseNumberOrRef = function () {\n        var firstNum = this.parseRawNumber();\n        this.skipWhitespaceAndComments();\n        var lookaheadStart = this.bytes.offset();\n        if (IsDigit[this.bytes.peek()]) {\n            var secondNum = this.parseRawNumber();\n            this.skipWhitespaceAndComments();\n            if (this.bytes.peek() === CharCodes.R) {\n                this.bytes.assertNext(CharCodes.R);\n                return PDFRef.of(firstNum, secondNum);\n            }\n        }\n        this.bytes.moveTo(lookaheadStart);\n        return PDFNumber.of(firstNum);\n    };\n    // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n    PDFObjectParser.prototype.parseHexString = function () {\n        var value = '';\n        this.bytes.assertNext(CharCodes.LessThan);\n        while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n            value += charFromCode(this.bytes.next());\n        }\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        return PDFHexString.of(value);\n    };\n    PDFObjectParser.prototype.parseString = function () {\n        var nestingLvl = 0;\n        var isEscaped = false;\n        var value = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.next();\n            value += charFromCode(byte);\n            // Check for unescaped parenthesis\n            if (!isEscaped) {\n                if (byte === CharCodes.LeftParen)\n                    nestingLvl += 1;\n                if (byte === CharCodes.RightParen)\n                    nestingLvl -= 1;\n            }\n            // Track whether current character is being escaped or not\n            if (byte === CharCodes.BackSlash) {\n                isEscaped = !isEscaped;\n            }\n            else if (isEscaped) {\n                isEscaped = false;\n            }\n            // Once (if) the unescaped parenthesis balance out, return their contents\n            if (nestingLvl === 0) {\n                // Remove the outer parens so they aren't part of the contents\n                return PDFString.of(value.substring(1, value.length - 1));\n            }\n        }\n        throw new UnbalancedParenthesisError(this.bytes.position());\n    };\n    // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n    // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n    PDFObjectParser.prototype.parseName = function () {\n        this.bytes.assertNext(CharCodes.ForwardSlash);\n        var name = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (IsWhitespace[byte] || IsDelimiter[byte])\n                break;\n            name += charFromCode(byte);\n            this.bytes.next();\n        }\n        return PDFName.of(name);\n    };\n    PDFObjectParser.prototype.parseArray = function () {\n        this.bytes.assertNext(CharCodes.LeftSquareBracket);\n        this.skipWhitespaceAndComments();\n        var pdfArray = PDFArray.withContext(this.context);\n        while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n            var element = this.parseObject();\n            pdfArray.push(element);\n            this.skipWhitespaceAndComments();\n        }\n        this.bytes.assertNext(CharCodes.RightSquareBracket);\n        return pdfArray;\n    };\n    PDFObjectParser.prototype.parseDict = function () {\n        this.bytes.assertNext(CharCodes.LessThan);\n        this.bytes.assertNext(CharCodes.LessThan);\n        this.skipWhitespaceAndComments();\n        var dict = new Map();\n        while (!this.bytes.done() &&\n            this.bytes.peek() !== CharCodes.GreaterThan &&\n            this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n            var key = this.parseName();\n            var value = this.parseObject();\n            dict.set(key, value);\n            this.skipWhitespaceAndComments();\n        }\n        this.skipWhitespaceAndComments();\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        var Type = dict.get(PDFName.of('Type'));\n        if (Type === PDFName.of('Catalog')) {\n            return PDFCatalog.fromMapWithContext(dict, this.context);\n        }\n        else if (Type === PDFName.of('Pages')) {\n            return PDFPageTree.fromMapWithContext(dict, this.context);\n        }\n        else if (Type === PDFName.of('Page')) {\n            return PDFPageLeaf.fromMapWithContext(dict, this.context);\n        }\n        else {\n            return PDFDict.fromMapWithContext(dict, this.context);\n        }\n    };\n    PDFObjectParser.prototype.parseDictOrStream = function () {\n        var startPos = this.bytes.position();\n        var dict = this.parseDict();\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.streamEOF1) &&\n            !this.matchKeyword(Keywords.streamEOF2) &&\n            !this.matchKeyword(Keywords.streamEOF3) &&\n            !this.matchKeyword(Keywords.streamEOF4) &&\n            !this.matchKeyword(Keywords.stream)) {\n            return dict;\n        }\n        var start = this.bytes.offset();\n        var end;\n        var Length = dict.get(PDFName.of('Length'));\n        if (Length instanceof PDFNumber) {\n            end = start + Length.asNumber();\n            this.bytes.moveTo(end);\n            this.skipWhitespaceAndComments();\n            if (!this.matchKeyword(Keywords.endstream)) {\n                this.bytes.moveTo(start);\n                end = this.findEndOfStreamFallback(startPos);\n            }\n        }\n        else {\n            end = this.findEndOfStreamFallback(startPos);\n        }\n        var contents = this.bytes.slice(start, end);\n        return PDFRawStream.of(dict, contents);\n    };\n    PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n        // Move to end of stream, while handling nested streams\n        var nestingLvl = 1;\n        var end = this.bytes.offset();\n        while (!this.bytes.done()) {\n            end = this.bytes.offset();\n            if (this.matchKeyword(Keywords.stream)) {\n                nestingLvl += 1;\n            }\n            else if (this.matchKeyword(Keywords.EOF1endstream) ||\n                this.matchKeyword(Keywords.EOF2endstream) ||\n                this.matchKeyword(Keywords.EOF3endstream) ||\n                this.matchKeyword(Keywords.endstream)) {\n                nestingLvl -= 1;\n            }\n            else {\n                this.bytes.next();\n            }\n            if (nestingLvl === 0)\n                break;\n        }\n        if (nestingLvl !== 0)\n            throw new PDFStreamParsingError(startPos);\n        return end;\n    };\n    PDFObjectParser.forBytes = function (bytes, context, capNumbers) { return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers); };\n    PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        return new PDFObjectParser(byteStream, context, capNumbers);\n    };\n    return PDFObjectParser;\n}(BaseParser));\nexport default PDFObjectParser;\n//# sourceMappingURL=PDFObjectParser.js.map"]},"metadata":{},"sourceType":"module"}