{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFTrailerDict from \"../document/PDFTrailerDict\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, waitForTick } from \"../../utils\";\n\nvar PDFWriter =\n/** @class */\nfunction () {\n  function PDFWriter(context, objectsPerTick) {\n    var _this = this;\n\n    this.parsedObjects = 0;\n\n    this.shouldWaitForTick = function (n) {\n      _this.parsedObjects += n;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n\n    this.context = context;\n    this.objectsPerTick = objectsPerTick;\n  }\n\n  PDFWriter.prototype.serializeToBuffer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.computeBufferSize()];\n\n          case 1:\n            _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;\n            offset = 0;\n            buffer = new Uint8Array(size);\n            offset += header.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            idx = 0, len = indirectObjects.length;\n            _c.label = 2;\n\n          case 2:\n            if (!(idx < len)) return [3\n            /*break*/\n            , 5];\n            _b = indirectObjects[idx], ref = _b[0], object = _b[1];\n            objectNumber = String(ref.objectNumber);\n            offset += copyStringIntoBuffer(objectNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            generationNumber = String(ref.generationNumber);\n            offset += copyStringIntoBuffer(generationNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            offset += object.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.e;\n            buffer[offset++] = CharCodes.n;\n            buffer[offset++] = CharCodes.d;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            n = object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\n            if (!this.shouldWaitForTick(n)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , waitForTick()];\n\n          case 3:\n            _c.sent();\n\n            _c.label = 4;\n\n          case 4:\n            idx++;\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            if (xref) {\n              offset += xref.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n            }\n\n            if (trailerDict) {\n              offset += trailerDict.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n              buffer[offset++] = CharCodes.Newline;\n            }\n\n            offset += trailer.copyBytesInto(buffer, offset);\n            return [2\n            /*return*/\n            , buffer];\n        }\n      });\n    });\n  };\n\n  PDFWriter.prototype.computeIndirectObjectSize = function (_a) {\n    var ref = _a[0],\n        object = _a[1];\n    var refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\n\n    var objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\n\n    return refSize + objectSize;\n  };\n\n  PDFWriter.prototype.createTrailerDict = function () {\n    return this.context.obj({\n      Size: this.context.largestObjectNumber + 1,\n      Root: this.context.trailerInfo.Root,\n      Encrypt: this.context.trailerInfo.Encrypt,\n      Info: this.context.trailerInfo.Info,\n      ID: this.context.trailerInfo.ID\n    });\n  };\n\n  PDFWriter.prototype.computeBufferSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            header = PDFHeader.forVersion(1, 7);\n            size = header.sizeInBytes() + 2;\n            xref = PDFCrossRefSection.create();\n            indirectObjects = this.context.enumerateIndirectObjects();\n            idx = 0, len = indirectObjects.length;\n            _a.label = 1;\n\n          case 1:\n            if (!(idx < len)) return [3\n            /*break*/\n            , 4];\n            indirectObject = indirectObjects[idx];\n            ref = indirectObject[0];\n            xref.addEntry(ref, size);\n            size += this.computeIndirectObjectSize(indirectObject);\n            if (!this.shouldWaitForTick(1)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , waitForTick()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            idx++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            xrefOffset = size;\n            size += xref.sizeInBytes() + 1; // '\\n'\n\n            trailerDict = PDFTrailerDict.of(this.createTrailerDict());\n            size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\n\n            trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n            size += trailer.sizeInBytes();\n            return [2\n            /*return*/\n            , {\n              size: size,\n              header: header,\n              indirectObjects: indirectObjects,\n              xref: xref,\n              trailerDict: trailerDict,\n              trailer: trailer\n            }];\n        }\n      });\n    });\n  };\n\n  PDFWriter.forContext = function (context, objectsPerTick) {\n    return new PDFWriter(context, objectsPerTick);\n  };\n\n  return PDFWriter;\n}();\n\nexport default PDFWriter;","map":{"version":3,"sources":["../../../src/core/writers/PDFWriter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFTrailerDict from \"../document/PDFTrailerDict\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, waitForTick } from \"../../utils\";\nvar PDFWriter = /** @class */ (function () {\n    function PDFWriter(context, objectsPerTick) {\n        var _this = this;\n        this.parsedObjects = 0;\n        this.shouldWaitForTick = function (n) {\n            _this.parsedObjects += n;\n            return _this.parsedObjects % _this.objectsPerTick === 0;\n        };\n        this.context = context;\n        this.objectsPerTick = objectsPerTick;\n    }\n    PDFWriter.prototype.serializeToBuffer = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.computeBufferSize()];\n                    case 1:\n                        _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;\n                        offset = 0;\n                        buffer = new Uint8Array(size);\n                        offset += header.copyBytesInto(buffer, offset);\n                        buffer[offset++] = CharCodes.Newline;\n                        buffer[offset++] = CharCodes.Newline;\n                        idx = 0, len = indirectObjects.length;\n                        _c.label = 2;\n                    case 2:\n                        if (!(idx < len)) return [3 /*break*/, 5];\n                        _b = indirectObjects[idx], ref = _b[0], object = _b[1];\n                        objectNumber = String(ref.objectNumber);\n                        offset += copyStringIntoBuffer(objectNumber, buffer, offset);\n                        buffer[offset++] = CharCodes.Space;\n                        generationNumber = String(ref.generationNumber);\n                        offset += copyStringIntoBuffer(generationNumber, buffer, offset);\n                        buffer[offset++] = CharCodes.Space;\n                        buffer[offset++] = CharCodes.o;\n                        buffer[offset++] = CharCodes.b;\n                        buffer[offset++] = CharCodes.j;\n                        buffer[offset++] = CharCodes.Newline;\n                        offset += object.copyBytesInto(buffer, offset);\n                        buffer[offset++] = CharCodes.Newline;\n                        buffer[offset++] = CharCodes.e;\n                        buffer[offset++] = CharCodes.n;\n                        buffer[offset++] = CharCodes.d;\n                        buffer[offset++] = CharCodes.o;\n                        buffer[offset++] = CharCodes.b;\n                        buffer[offset++] = CharCodes.j;\n                        buffer[offset++] = CharCodes.Newline;\n                        buffer[offset++] = CharCodes.Newline;\n                        n = object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\n                        if (!this.shouldWaitForTick(n)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, waitForTick()];\n                    case 3:\n                        _c.sent();\n                        _c.label = 4;\n                    case 4:\n                        idx++;\n                        return [3 /*break*/, 2];\n                    case 5:\n                        if (xref) {\n                            offset += xref.copyBytesInto(buffer, offset);\n                            buffer[offset++] = CharCodes.Newline;\n                        }\n                        if (trailerDict) {\n                            offset += trailerDict.copyBytesInto(buffer, offset);\n                            buffer[offset++] = CharCodes.Newline;\n                            buffer[offset++] = CharCodes.Newline;\n                        }\n                        offset += trailer.copyBytesInto(buffer, offset);\n                        return [2 /*return*/, buffer];\n                }\n            });\n        });\n    };\n    PDFWriter.prototype.computeIndirectObjectSize = function (_a) {\n        var ref = _a[0], object = _a[1];\n        var refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\n        var objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\n        return refSize + objectSize;\n    };\n    PDFWriter.prototype.createTrailerDict = function () {\n        return this.context.obj({\n            Size: this.context.largestObjectNumber + 1,\n            Root: this.context.trailerInfo.Root,\n            Encrypt: this.context.trailerInfo.Encrypt,\n            Info: this.context.trailerInfo.Info,\n            ID: this.context.trailerInfo.ID,\n        });\n    };\n    PDFWriter.prototype.computeBufferSize = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        header = PDFHeader.forVersion(1, 7);\n                        size = header.sizeInBytes() + 2;\n                        xref = PDFCrossRefSection.create();\n                        indirectObjects = this.context.enumerateIndirectObjects();\n                        idx = 0, len = indirectObjects.length;\n                        _a.label = 1;\n                    case 1:\n                        if (!(idx < len)) return [3 /*break*/, 4];\n                        indirectObject = indirectObjects[idx];\n                        ref = indirectObject[0];\n                        xref.addEntry(ref, size);\n                        size += this.computeIndirectObjectSize(indirectObject);\n                        if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, waitForTick()];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        idx++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        xrefOffset = size;\n                        size += xref.sizeInBytes() + 1; // '\\n'\n                        trailerDict = PDFTrailerDict.of(this.createTrailerDict());\n                        size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\n                        trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n                        size += trailer.sizeInBytes();\n                        return [2 /*return*/, { size: size, header: header, indirectObjects: indirectObjects, xref: xref, trailerDict: trailerDict, trailer: trailer }];\n                }\n            });\n        });\n    };\n    PDFWriter.forContext = function (context, objectsPerTick) {\n        return new PDFWriter(context, objectsPerTick);\n    };\n    return PDFWriter;\n}());\nexport default PDFWriter;\n//# sourceMappingURL=PDFWriter.js.map"]},"metadata":{},"sourceType":"module"}