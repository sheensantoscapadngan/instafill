{"ast":null,"code":"import { __assign, __spread } from 'tslib';\nimport { Presence } from '../components/AnimateSharedLayout/types.js';\nimport { checkIfControllingVariants, isVariantLabel } from './utils/variants.js';\nimport { pipe } from 'popmotion';\nimport sync, { cancelSync } from 'framesync';\nimport { copyAxisBox } from '../utils/geometry/index.js';\nimport { eachAxis } from '../utils/each-axis.js';\nimport { updateBoxDelta } from '../utils/geometry/delta-calc.js';\nimport { motionValue } from '../value/index.js';\nimport { variantPriorityOrder } from './utils/animation-state.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { createLayoutState, createProjectionState } from './utils/state.js';\nimport { buildLayoutProjectionTransform } from './html/utils/build-transform.js';\nimport { removeBoxTransforms, applyBoxTransforms } from '../utils/geometry/delta-apply.js';\nimport { createLifecycles } from './utils/lifecycles.js';\nimport { updateMotionValuesFromProps } from './utils/motion-values.js';\nimport { updateLayoutDeltas } from './utils/projection.js';\n\nvar visualElement = function (_a) {\n  var _b = _a.treeType,\n      treeType = _b === void 0 ? \"\" : _b,\n      build = _a.build,\n      getBaseTarget = _a.getBaseTarget,\n      makeTargetAnimatable = _a.makeTargetAnimatable,\n      measureViewportBox = _a.measureViewportBox,\n      renderInstance = _a.render,\n      readValueFromInstance = _a.readValueFromInstance,\n      resetTransform = _a.resetTransform,\n      restoreTransform = _a.restoreTransform,\n      removeValueFromRenderState = _a.removeValueFromRenderState,\n      sortNodePosition = _a.sortNodePosition,\n      scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n        props = _a.props,\n        presenceId = _a.presenceId,\n        blockInitialAnimation = _a.blockInitialAnimation,\n        visualState = _a.visualState;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var latestValues = visualState.latestValues,\n        renderState = visualState.renderState;\n    /**\r\n     * The instance of the render-specific node that will be hydrated by the\r\n     * exposed React ref. So for example, this visual element can host a\r\n     * HTMLElement, plain object, or Three.js object. The functions provided\r\n     * in VisualElementConfig allow us to interface with this instance.\r\n     */\n\n    var instance;\n    /**\r\n     * A set of all children of this visual element. We use this to traverse\r\n     * the tree when updating layout projections.\r\n     */\n\n    var children = new Set();\n    /**\r\n     * Manages the subscriptions for a visual element's lifecycle, for instance\r\n     * onRender and onViewportBoxUpdate.\r\n     */\n\n    var lifecycles = createLifecycles();\n    /**\r\n     *\r\n     */\n\n    var projection = createProjectionState();\n    /**\r\n     * This is a reference to the visual state of the \"lead\" visual element.\r\n     * Usually, this will be this visual element. But if it shares a layoutId\r\n     * with other visual elements, only one of them will be designated lead by\r\n     * AnimateSharedLayout. All the other visual elements will take on the visual\r\n     * appearance of the lead while they crossfade to it.\r\n     */\n\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    /**\r\n     * The latest layout measurements and calculated projections. This\r\n     * is seperate from the target projection data in visualState as\r\n     * many visual elements might point to the same piece of visualState as\r\n     * a target, whereas they might each have different layouts and thus\r\n     * projection calculations needed to project into the same viewport box.\r\n     */\n\n    var layoutState = createLayoutState();\n    /**\r\n     *\r\n     */\n\n    var crossfader;\n    /**\r\n     * Keep track of whether the viewport box has been updated since the\r\n     * last time the layout projection was re-calculated.\r\n     */\n\n    var hasViewportBoxUpdated = false;\n    /**\r\n     * A map of all motion values attached to this visual element. Motion\r\n     * values are source of truth for any given animated value. A motion\r\n     * value might be provided externally by the component via props.\r\n     */\n\n    var values = new Map();\n    /**\r\n     * A map of every subscription that binds the provided or generated\r\n     * motion values onChange listeners to this visual element.\r\n     */\n\n    var valueSubscriptions = new Map();\n    /**\r\n     * A reference to the previously-provided motion values as returned\r\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n     * if any motion values need to be removed after props are updated.\r\n     */\n\n    var prevMotionValues = {};\n    /**\r\n     * x/y motion values that track the progress of initiated layout\r\n     * animations.\r\n     *\r\n     * TODO: Target for removal\r\n     */\n\n    var projectionTargetProgress;\n    /**\r\n     * When values are removed from all animation props we need to search\r\n     * for a fallback value to animate to. These values are tracked in baseTarget.\r\n     */\n\n    var baseTarget = __assign({}, latestValues); // Internal methods ========================\n\n    /**\r\n     * On mount, this will be hydrated with a callback to disconnect\r\n     * this visual element from its parent on unmount.\r\n     */\n\n\n    var removeFromMotionTree;\n    var removeFromVariantTree;\n    /**\r\n     *\r\n     */\n\n    function isProjecting() {\n      return projection.isEnabled && layoutState.isHydrated;\n    }\n    /**\r\n     *\r\n     */\n\n\n    function render() {\n      if (!instance) return;\n\n      if (isProjecting()) {\n        /**\r\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n         * This is the final box that we will then project into by calculating a transform delta and\r\n         * applying it to the corrected box.\r\n         */\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        /**\r\n         * Update the delta between the corrected box and the final target box, after\r\n         * user-set transforms are applied to it. This will be used by the renderer to\r\n         * create a transform style that will reproject the element from its actual layout\r\n         * into the desired bounding box.\r\n         */\n\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues) valuesToRender = crossfadedValues;\n      }\n\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n\n    function updateLayoutProjection() {\n      var delta = layoutState.delta,\n          treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.x;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n\n      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction\n      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n\n      layoutState.deltaTransform = deltaTransform;\n    }\n    /**\r\n     *\r\n     */\n\n\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync.update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\r\n     * Any motion values that are provided to the element when created\r\n     * aren't yet bound to the element, as this would technically be impure.\r\n     * However, we iterate through the motion values and set them to the\r\n     * initial values for this component.\r\n     *\r\n     * TODO: This is impure and we should look at changing this to run on mount.\r\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\r\n     * more a reflection of the test.\r\n     */\n\n\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\r\n     * Determine what role this visual element should take in the variant tree.\r\n     */\n\n\n    var isControllingVariants = checkIfControllingVariants(props);\n    var definesInitialVariant = isVariantLabel(props.initial);\n    var isVariantNode = Boolean(definesInitialVariant || isControllingVariants || props.variants);\n\n    var element = __assign(__assign({\n      treeType: treeType,\n\n      /**\r\n       * This is a mirror of the internal instance prop, which keeps\r\n       * VisualElement type-compatible with React's RefObject.\r\n       */\n      current: null,\n\n      /**\r\n       * The depth of this visual element within the visual element tree.\r\n       */\n      depth: parent ? parent.depth + 1 : 0,\n\n      /**\r\n       * An ancestor path back to the root visual element. This is used\r\n       * by layout projection to quickly recurse back up the tree.\r\n       */\n      path: parent ? __spread(parent.path, [parent]) : [],\n\n      /**\r\n       *\r\n       */\n      presenceId: presenceId,\n      projection: projection,\n\n      /**\r\n       * If this component is part of the variant tree, it should track\r\n       * any children that are also part of the tree. This is essentially\r\n       * a shadow tree to simplify logic around how to stagger over children.\r\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n\n      /**\r\n       * Whether this instance is visible. This can be changed imperatively\r\n       * by AnimateSharedLayout, is analogous to CSS's visibility in that\r\n       * hidden elements should take up layout, and needs enacting by the configured\r\n       * render function.\r\n       */\n      isVisible: undefined,\n\n      /**\r\n       * Normally, if a component is controlled by a parent's variants, it can\r\n       * rely on that ancestor to trigger animations further down the tree.\r\n       * However, if a component is created after its parent is mounted, the parent\r\n       * won't trigger that mount animation so the child needs to.\r\n       *\r\n       * TODO: This might be better replaced with a method isParentMounted\r\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n\n      /**\r\n       * This can be set by AnimatePresence to force components that mount\r\n       * at the same time as it to mount as if they have initial={false} set.\r\n       */\n      blockInitialAnimation: blockInitialAnimation,\n\n      /**\r\n       * A boolean that can be used to determine whether to respect hover events.\r\n       * For layout measurements we often have to reposition the instance by\r\n       * removing its transform. This can trigger hover events, which is\r\n       * undesired.\r\n       */\n      isHoverEventsEnabled: true,\n\n      /**\r\n       * Determine whether this component has mounted yet. This is mostly used\r\n       * by variant children to determine whether they need to trigger their\r\n       * own animations on mount.\r\n       */\n      isMounted: function () {\n        return Boolean(instance);\n      },\n      mount: function (newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n        removeFromMotionTree = parent === null || parent === void 0 ? void 0 : parent.addChild(element);\n\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n      },\n\n      /**\r\n       *\r\n       */\n      unmount: function () {\n        cancelSync.update(update);\n        cancelSync.render(render);\n        cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        element.stopLayoutAnimation();\n        removeFromMotionTree === null || removeFromMotionTree === void 0 ? void 0 : removeFromMotionTree();\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n\n      /**\r\n       * Add a child visual element to our set of children.\r\n       */\n      addChild: function (child) {\n        children.add(child);\n        return function () {\n          return children.delete(child);\n        };\n      },\n\n      /**\r\n       * Add a child visual element to our set of children.\r\n       */\n      addVariantChild: function (child) {\n        var _a;\n\n        var closestVariantNode = element.getClosestVariantNode();\n\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function (other) {\n        /**\r\n         * If these nodes aren't even of the same type we can't compare their depth.\r\n         */\n        if (!sortNodePosition || treeType !== other.treeType) return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n\n      /**\r\n       * Returns the closest variant node in the tree starting from\r\n       * this visual element.\r\n       */\n      getClosestVariantNode: function () {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n\n      /**\r\n       * A method that schedules an update to layout projections throughout\r\n       * the tree. We inherit from the parent so there's only ever one\r\n       * job scheduled on the next frame - that of the root visual element.\r\n       */\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function () {\n        return sync.preRender(element.updateLayoutProjection, false, true);\n      },\n\n      /**\r\n       * Expose the latest layoutId prop.\r\n       */\n      getLayoutId: function () {\n        return props.layoutId;\n      },\n\n      /**\r\n       * Returns the current instance.\r\n       */\n      getInstance: function () {\n        return instance;\n      },\n\n      /**\r\n       * Get/set the latest static values.\r\n       */\n      getStaticValue: function (key) {\n        return latestValues[key];\n      },\n      setStaticValue: function (key, value) {\n        return latestValues[key] = value;\n      },\n\n      /**\r\n       * Returns the latest motion value state. Currently only used to take\r\n       * a snapshot of the visual element - perhaps this can return the whole\r\n       * visual state\r\n       */\n      getLatestValues: function () {\n        return latestValues;\n      },\n\n      /**\r\n       * Set the visiblity of the visual element. If it's changed, schedule\r\n       * a render to reflect these changes.\r\n       */\n      setVisibility: function (visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n\n      /**\r\n       * Make a target animatable by Popmotion. For instance, if we're\r\n       * trying to animate width from 100px to 100vw we need to measure 100vw\r\n       * in pixels to determine what we really need to animate to. This is also\r\n       * pluggable to support Framer's custom value types like Color,\r\n       * and CSS variables.\r\n       */\n      makeTargetAnimatable: function (target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n\n      /**\r\n       * Temporarily suspend hover events while we remove transforms in order to measure the layout.\r\n       *\r\n       * This seems like an odd bit of scheduling but what we're doing is saying after\r\n       * the next render, wait 10 milliseconds before reenabling hover events. Waiting until\r\n       * the next frame results in missed, valid hover events. But triggering on the postRender\r\n       * frame is too soon to avoid triggering events with layout measurements.\r\n       *\r\n       * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\r\n       */\n      suspendHoverEvents: function () {\n        element.isHoverEventsEnabled = false;\n        sync.postRender(function () {\n          return setTimeout(function () {\n            return element.isHoverEventsEnabled = true;\n          }, 10);\n        });\n      },\n      // Motion values ========================\n\n      /**\r\n       * Add a motion value and bind it to this visual element.\r\n       */\n      addValue: function (key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n\n      /**\r\n       * Remove a motion value and unbind any active subscriptions.\r\n       */\n      removeValue: function (key) {\n        var _a;\n\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n\n      /**\r\n       * Check whether we have a motion value for this key\r\n       */\n      hasValue: function (key) {\n        return values.has(key);\n      },\n\n      /**\r\n       * Get a motion value for this key. If called with a default\r\n       * value, we'll create one if none exists.\r\n       */\n      getValue: function (key, defaultValue) {\n        var value = values.get(key);\n\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n\n        return value;\n      },\n\n      /**\r\n       * Iterate over our motion values.\r\n       */\n      forEachValue: function (callback) {\n        return values.forEach(callback);\n      },\n\n      /**\r\n       * If we're trying to animate to a previously unencountered value,\r\n       * we need to check for it in our state and as a last resort read it\r\n       * directly from the instance (which might have performance implications).\r\n       */\n      readValue: function (key) {\n        var _a;\n\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n\n      /**\r\n       * Set the base target to later animate back to. This is currently\r\n       * only hydrated on creation and when we first read a value.\r\n       */\n      setBaseTarget: function (key, value) {\n        baseTarget[key] = value;\n      },\n\n      /**\r\n       * Find the base target for a value thats been removed from all animation\r\n       * props.\r\n       */\n      getBaseTarget: function (key) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key);\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\r\n       * Build the renderer state based on the latest visual state.\r\n       */\n      build: function () {\n        triggerBuild();\n        return renderState;\n      },\n\n      /**\r\n       * Schedule a render on the next animation frame.\r\n       */\n      scheduleRender: function () {\n        sync.render(render, false, true);\n      },\n\n      /**\r\n       * Synchronously fire render. It's prefered that we batch renders but\r\n       * in many circumstances, like layout measurement, we need to run this\r\n       * synchronously. However in those instances other measures should be taken\r\n       * to batch reads/writes.\r\n       */\n      syncRender: render,\n\n      /**\r\n       * Update the provided props. Ensure any newly-added motion values are\r\n       * added to our map, old ones removed, and listeners updated.\r\n       */\n      setProps: function (newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function () {\n        return props;\n      },\n      // Variants ==============================\n\n      /**\r\n       * Returns the variant definition with a given name.\r\n       */\n      getVariant: function (name) {\n        var _a;\n\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n\n      /**\r\n       * Returns the defined default transition on this component.\r\n       */\n      getDefaultTransition: function () {\n        return props.transition;\n      },\n\n      /**\r\n       * Used by child variant nodes to get the closest ancestor variant props.\r\n       */\n      getVariantContext: function (startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n\n          return context_1;\n        }\n\n        var context = {};\n\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n\n        return context;\n      },\n      // Layout projection ==============================\n\n      /**\r\n       * Enable layout projection for this visual element. Won't actually\r\n       * occur until we also have hydrated layout measurements.\r\n       */\n      enableLayoutProjection: function () {\n        projection.isEnabled = true;\n      },\n\n      /**\r\n       * Lock the projection target, for instance when dragging, so\r\n       * nothing else can try and animate it.\r\n       */\n      lockProjectionTarget: function () {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function () {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n\n      /**\r\n       * Record the viewport box as it was before an expected mutation/re-render\r\n       */\n      snapshotViewportBox: function () {\n        // TODO: Store this snapshot in LayoutState\n        element.prevViewportBox = element.measureViewportBox(false);\n        /**\r\n         * Update targetBox to match the prevViewportBox. This is just to ensure\r\n         * that targetBox is affected by scroll in the same way as the measured box\r\n         */\n\n        element.rebaseProjectionTarget(false, element.prevViewportBox);\n      },\n      getLayoutState: function () {\n        return layoutState;\n      },\n      setCrossfader: function (newCrossfader) {\n        crossfader = newCrossfader;\n      },\n\n      /**\r\n       * Start a layout animation on a given axis.\r\n       * TODO: This could be better.\r\n       */\n      startLayoutAnimation: function (axis, transition) {\n        var progress = element.getProjectionAnimationProgress()[axis];\n        var _a = projection.target[axis],\n            min = _a.min,\n            max = _a.max;\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n\n        progress.onChange(function (v) {\n          return element.setProjectionTargetAxis(axis, v, v + length);\n        });\n        return element.animateMotionValue(axis, progress, 0, transition);\n      },\n\n      /**\r\n       * Stop layout animations.\r\n       */\n      stopLayoutAnimation: function () {\n        eachAxis(function (axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n\n      /**\r\n       * Measure the current viewport box with or without transforms.\r\n       * Only measures axis-aligned boxes, rotate and skew must be manually\r\n       * removed with a re-render to work.\r\n       */\n      measureViewportBox: function (withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n\n        var viewportBox = measureViewportBox(instance, options);\n        if (!withTransform) removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n\n      /**\r\n       * Update the layoutState by measuring the DOM layout. This\r\n       * should be called after resetting any layout-affecting transforms.\r\n       */\n      updateLayoutMeasurement: function () {\n        element.notifyBeforeLayoutMeasure(layoutState.layout);\n        layoutState.isHydrated = true;\n        layoutState.layout = element.measureViewportBox();\n        layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n        element.notifyLayoutMeasure(layoutState.layout, element.prevViewportBox || layoutState.layout);\n        sync.update(function () {\n          return element.rebaseProjectionTarget();\n        });\n      },\n\n      /**\r\n       * Get the motion values tracking the layout animations on each\r\n       * axis. Lazy init if not already created.\r\n       */\n      getProjectionAnimationProgress: function () {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n\n      /**\r\n       * Update the projection of a single axis. Schedule an update to\r\n       * the tree layout projection.\r\n       */\n      setProjectionTargetAxis: function (axis, min, max) {\n        var target = projection.target[axis];\n        target.min = min;\n        target.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n\n      /**\r\n       * Rebase the projection target on top of the provided viewport box\r\n       * or the measured layout. This ensures that non-animating elements\r\n       * don't fall out of sync differences in measurements vs projections\r\n       * after a page scroll or other relayout.\r\n       */\n      rebaseProjectionTarget: function (force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n\n        var _a = element.getProjectionAnimationProgress(),\n            x = _a.x,\n            y = _a.y;\n\n        var shouldRebase = !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n\n        if (force || shouldRebase) {\n          eachAxis(function (axis) {\n            var _a = box[axis],\n                min = _a.min,\n                max = _a.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n\n      /**\r\n       * Notify the visual element that its layout is up-to-date.\r\n       * Currently Animate.tsx uses this to check whether a layout animation\r\n       * needs to be performed.\r\n       */\n      notifyLayoutReady: function (config) {\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n\n      /**\r\n       * Temporarily reset the transform of the instance.\r\n       */\n      resetTransform: function () {\n        return resetTransform(element, instance, props);\n      },\n\n      /**\r\n       * Perform the callback after temporarily unapplying the transform\r\n       * upwards through the tree.\r\n       */\n      withoutTransform: function (callback) {\n        var isEnabled = projection.isEnabled;\n        isEnabled && element.resetTransform();\n        parent ? parent.withoutTransform(callback) : callback();\n        isEnabled && restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection: function () {\n        isProjecting() && updateLayoutProjection();\n        children.forEach(fireUpdateLayoutProjection);\n      },\n\n      /**\r\n       *\r\n       */\n      pointTo: function (newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        /**\r\n         * Subscribe to lead component's layout animations\r\n         */\n\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n          var _a;\n\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n          }\n        }));\n      },\n      // TODO: Clean this up\n      isPresent: true,\n      presence: Presence.Entering\n    });\n\n    return element;\n  };\n};\n\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\n\nvar variantProps = __spread([\"initial\"], variantPriorityOrder);\n\nvar numVariantProps = variantProps.length;\nexport { visualElement };","map":{"version":3,"sources":["C:/Users/GAMER/OneDrive/Desktop/programming stuff/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/render/index.js"],"names":["__assign","__spread","Presence","checkIfControllingVariants","isVariantLabel","pipe","sync","cancelSync","copyAxisBox","eachAxis","updateBoxDelta","motionValue","variantPriorityOrder","isMotionValue","createLayoutState","createProjectionState","buildLayoutProjectionTransform","removeBoxTransforms","applyBoxTransforms","createLifecycles","updateMotionValuesFromProps","updateLayoutDeltas","visualElement","_a","_b","treeType","build","getBaseTarget","makeTargetAnimatable","measureViewportBox","renderInstance","render","readValueFromInstance","resetTransform","restoreTransform","removeValueFromRenderState","sortNodePosition","scrapeMotionValuesFromProps","options","parent","props","presenceId","blockInitialAnimation","visualState","latestValues","renderState","instance","children","Set","lifecycles","projection","leadProjection","leadLatestValues","unsubscribeFromLeadVisualElement","layoutState","crossfader","hasViewportBoxUpdated","values","Map","valueSubscriptions","prevMotionValues","projectionTargetProgress","baseTarget","removeFromMotionTree","removeFromVariantTree","isProjecting","isEnabled","isHydrated","targetFinal","target","deltaFinal","layoutCorrected","triggerBuild","valuesToRender","isActive","crossfadedValues","getCrossfadeState","element","update","notifyUpdate","updateLayoutProjection","delta","treeScale","prevTreeScaleX","x","prevTreeScaleY","prevDeltaTransform","deltaTransform","path","notifyViewportBoxUpdate","y","scheduleRender","bindToMotionValue","key","value","removeOnChange","onChange","latestValue","onUpdate","removeOnRenderRequest","onRenderRequest","set","initialMotionValues","undefined","isControllingVariants","definesInitialVariant","initial","isVariantNode","Boolean","variants","current","depth","variantChildren","isVisible","manuallyAnimateOnMount","isMounted","isHoverEventsEnabled","mount","newInstance","pointTo","addChild","addVariantChild","unmount","preRender","forEach","remove","stopLayoutAnimation","clearAllListeners","child","add","delete","closestVariantNode","getClosestVariantNode","other","getInstance","scheduleUpdateLayoutProjection","getLayoutId","layoutId","getStaticValue","setStaticValue","getLatestValues","setVisibility","visibility","canMutate","suspendHoverEvents","postRender","setTimeout","addValue","hasValue","removeValue","get","has","getValue","defaultValue","forEachValue","callback","readValue","setBaseTarget","syncRender","setProps","newProps","updatePropListeners","getProps","getVariant","name","getDefaultTransition","transition","getVariantContext","startAtParent","context_1","context","i","numVariantProps","name_1","variantProps","prop","enableLayoutProjection","lockProjectionTarget","isTargetLocked","unlockProjectionTarget","snapshotViewportBox","prevViewportBox","rebaseProjectionTarget","getLayoutState","setCrossfader","newCrossfader","startLayoutAnimation","axis","progress","getProjectionAnimationProgress","min","max","length","clearListeners","v","setProjectionTargetAxis","animateMotionValue","stop","withTransform","viewportBox","updateLayoutMeasurement","notifyBeforeLayoutMeasure","layout","notifyLayoutMeasure","notifySetAxisTarget","force","box","shouldRebase","isAnimating","notifyLayoutReady","config","notifyLayoutUpdate","withoutTransform","fireUpdateLayoutProjection","newLead","onSetAxisTarget","onLayoutAnimationComplete","isPresent","presence","Present","layoutSafeToRemove","call","Entering"],"mappings":"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","sourcesContent":["import { __assign, __spread } from 'tslib';\r\nimport { Presence } from '../components/AnimateSharedLayout/types.js';\r\nimport { checkIfControllingVariants, isVariantLabel } from './utils/variants.js';\r\nimport { pipe } from 'popmotion';\r\nimport sync, { cancelSync } from 'framesync';\r\nimport { copyAxisBox } from '../utils/geometry/index.js';\r\nimport { eachAxis } from '../utils/each-axis.js';\r\nimport { updateBoxDelta } from '../utils/geometry/delta-calc.js';\r\nimport { motionValue } from '../value/index.js';\r\nimport { variantPriorityOrder } from './utils/animation-state.js';\r\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\r\nimport { createLayoutState, createProjectionState } from './utils/state.js';\r\nimport { buildLayoutProjectionTransform } from './html/utils/build-transform.js';\r\nimport { removeBoxTransforms, applyBoxTransforms } from '../utils/geometry/delta-apply.js';\r\nimport { createLifecycles } from './utils/lifecycles.js';\r\nimport { updateMotionValuesFromProps } from './utils/motion-values.js';\r\nimport { updateLayoutDeltas } from './utils/projection.js';\r\n\r\nvar visualElement = function (_a) {\r\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\r\n    return function (_a, options) {\r\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\r\n        if (options === void 0) { options = {}; }\r\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\r\n        /**\r\n         * The instance of the render-specific node that will be hydrated by the\r\n         * exposed React ref. So for example, this visual element can host a\r\n         * HTMLElement, plain object, or Three.js object. The functions provided\r\n         * in VisualElementConfig allow us to interface with this instance.\r\n         */\r\n        var instance;\r\n        /**\r\n         * A set of all children of this visual element. We use this to traverse\r\n         * the tree when updating layout projections.\r\n         */\r\n        var children = new Set();\r\n        /**\r\n         * Manages the subscriptions for a visual element's lifecycle, for instance\r\n         * onRender and onViewportBoxUpdate.\r\n         */\r\n        var lifecycles = createLifecycles();\r\n        /**\r\n         *\r\n         */\r\n        var projection = createProjectionState();\r\n        /**\r\n         * This is a reference to the visual state of the \"lead\" visual element.\r\n         * Usually, this will be this visual element. But if it shares a layoutId\r\n         * with other visual elements, only one of them will be designated lead by\r\n         * AnimateSharedLayout. All the other visual elements will take on the visual\r\n         * appearance of the lead while they crossfade to it.\r\n         */\r\n        var leadProjection = projection;\r\n        var leadLatestValues = latestValues;\r\n        var unsubscribeFromLeadVisualElement;\r\n        /**\r\n         * The latest layout measurements and calculated projections. This\r\n         * is seperate from the target projection data in visualState as\r\n         * many visual elements might point to the same piece of visualState as\r\n         * a target, whereas they might each have different layouts and thus\r\n         * projection calculations needed to project into the same viewport box.\r\n         */\r\n        var layoutState = createLayoutState();\r\n        /**\r\n         *\r\n         */\r\n        var crossfader;\r\n        /**\r\n         * Keep track of whether the viewport box has been updated since the\r\n         * last time the layout projection was re-calculated.\r\n         */\r\n        var hasViewportBoxUpdated = false;\r\n        /**\r\n         * A map of all motion values attached to this visual element. Motion\r\n         * values are source of truth for any given animated value. A motion\r\n         * value might be provided externally by the component via props.\r\n         */\r\n        var values = new Map();\r\n        /**\r\n         * A map of every subscription that binds the provided or generated\r\n         * motion values onChange listeners to this visual element.\r\n         */\r\n        var valueSubscriptions = new Map();\r\n        /**\r\n         * A reference to the previously-provided motion values as returned\r\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n         * if any motion values need to be removed after props are updated.\r\n         */\r\n        var prevMotionValues = {};\r\n        /**\r\n         * x/y motion values that track the progress of initiated layout\r\n         * animations.\r\n         *\r\n         * TODO: Target for removal\r\n         */\r\n        var projectionTargetProgress;\r\n        /**\r\n         * When values are removed from all animation props we need to search\r\n         * for a fallback value to animate to. These values are tracked in baseTarget.\r\n         */\r\n        var baseTarget = __assign({}, latestValues);\r\n        // Internal methods ========================\r\n        /**\r\n         * On mount, this will be hydrated with a callback to disconnect\r\n         * this visual element from its parent on unmount.\r\n         */\r\n        var removeFromMotionTree;\r\n        var removeFromVariantTree;\r\n        /**\r\n         *\r\n         */\r\n        function isProjecting() {\r\n            return projection.isEnabled && layoutState.isHydrated;\r\n        }\r\n        /**\r\n         *\r\n         */\r\n        function render() {\r\n            if (!instance)\r\n                return;\r\n            if (isProjecting()) {\r\n                /**\r\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n                 * This is the final box that we will then project into by calculating a transform delta and\r\n                 * applying it to the corrected box.\r\n                 */\r\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\r\n                /**\r\n                 * Update the delta between the corrected box and the final target box, after\r\n                 * user-set transforms are applied to it. This will be used by the renderer to\r\n                 * create a transform style that will reproject the element from its actual layout\r\n                 * into the desired bounding box.\r\n                 */\r\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\r\n            }\r\n            triggerBuild();\r\n            renderInstance(instance, renderState);\r\n        }\r\n        function triggerBuild() {\r\n            var valuesToRender = latestValues;\r\n            if (crossfader && crossfader.isActive()) {\r\n                var crossfadedValues = crossfader.getCrossfadeState(element);\r\n                if (crossfadedValues)\r\n                    valuesToRender = crossfadedValues;\r\n            }\r\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\r\n        }\r\n        function update() {\r\n            lifecycles.notifyUpdate(latestValues);\r\n        }\r\n        function updateLayoutProjection() {\r\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\r\n            var prevTreeScaleX = treeScale.x;\r\n            var prevTreeScaleY = treeScale.x;\r\n            var prevDeltaTransform = layoutState.deltaTransform;\r\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\r\n            hasViewportBoxUpdated &&\r\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\r\n            hasViewportBoxUpdated = false;\r\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\r\n            if (deltaTransform !== prevDeltaTransform ||\r\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\r\n                prevTreeScaleX !== treeScale.x ||\r\n                prevTreeScaleY !== treeScale.y) {\r\n                element.scheduleRender();\r\n            }\r\n            layoutState.deltaTransform = deltaTransform;\r\n        }\r\n        /**\r\n         *\r\n         */\r\n        function bindToMotionValue(key, value) {\r\n            var removeOnChange = value.onChange(function (latestValue) {\r\n                latestValues[key] = latestValue;\r\n                props.onUpdate && sync.update(update, false, true);\r\n            });\r\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\r\n            valueSubscriptions.set(key, function () {\r\n                removeOnChange();\r\n                removeOnRenderRequest();\r\n            });\r\n        }\r\n        /**\r\n         * Any motion values that are provided to the element when created\r\n         * aren't yet bound to the element, as this would technically be impure.\r\n         * However, we iterate through the motion values and set them to the\r\n         * initial values for this component.\r\n         *\r\n         * TODO: This is impure and we should look at changing this to run on mount.\r\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\r\n         * more a reflection of the test.\r\n         */\r\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\r\n        for (var key in initialMotionValues) {\r\n            var value = initialMotionValues[key];\r\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\r\n                value.set(latestValues[key], false);\r\n            }\r\n        }\r\n        /**\r\n         * Determine what role this visual element should take in the variant tree.\r\n         */\r\n        var isControllingVariants = checkIfControllingVariants(props);\r\n        var definesInitialVariant = isVariantLabel(props.initial);\r\n        var isVariantNode = Boolean(definesInitialVariant || isControllingVariants || props.variants);\r\n        var element = __assign(__assign({ treeType: treeType, \r\n            /**\r\n             * This is a mirror of the internal instance prop, which keeps\r\n             * VisualElement type-compatible with React's RefObject.\r\n             */\r\n            current: null, \r\n            /**\r\n             * The depth of this visual element within the visual element tree.\r\n             */\r\n            depth: parent ? parent.depth + 1 : 0, \r\n            /**\r\n             * An ancestor path back to the root visual element. This is used\r\n             * by layout projection to quickly recurse back up the tree.\r\n             */\r\n            path: parent ? __spread(parent.path, [parent]) : [], \r\n            /**\r\n             *\r\n             */\r\n            presenceId: presenceId,\r\n            projection: projection, \r\n            /**\r\n             * If this component is part of the variant tree, it should track\r\n             * any children that are also part of the tree. This is essentially\r\n             * a shadow tree to simplify logic around how to stagger over children.\r\n             */\r\n            variantChildren: isVariantNode ? new Set() : undefined, \r\n            /**\r\n             * Whether this instance is visible. This can be changed imperatively\r\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\r\n             * hidden elements should take up layout, and needs enacting by the configured\r\n             * render function.\r\n             */\r\n            isVisible: undefined, \r\n            /**\r\n             * Normally, if a component is controlled by a parent's variants, it can\r\n             * rely on that ancestor to trigger animations further down the tree.\r\n             * However, if a component is created after its parent is mounted, the parent\r\n             * won't trigger that mount animation so the child needs to.\r\n             *\r\n             * TODO: This might be better replaced with a method isParentMounted\r\n             */\r\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \r\n            /**\r\n             * This can be set by AnimatePresence to force components that mount\r\n             * at the same time as it to mount as if they have initial={false} set.\r\n             */\r\n            blockInitialAnimation: blockInitialAnimation, \r\n            /**\r\n             * A boolean that can be used to determine whether to respect hover events.\r\n             * For layout measurements we often have to reposition the instance by\r\n             * removing its transform. This can trigger hover events, which is\r\n             * undesired.\r\n             */\r\n            isHoverEventsEnabled: true, \r\n            /**\r\n             * Determine whether this component has mounted yet. This is mostly used\r\n             * by variant children to determine whether they need to trigger their\r\n             * own animations on mount.\r\n             */\r\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\r\n                instance = element.current = newInstance;\r\n                element.pointTo(element);\r\n                removeFromMotionTree = parent === null || parent === void 0 ? void 0 : parent.addChild(element);\r\n                if (isVariantNode && parent && !isControllingVariants) {\r\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\r\n                }\r\n            },\r\n            /**\r\n             *\r\n             */\r\n            unmount: function () {\r\n                cancelSync.update(update);\r\n                cancelSync.render(render);\r\n                cancelSync.preRender(element.updateLayoutProjection);\r\n                valueSubscriptions.forEach(function (remove) { return remove(); });\r\n                element.stopLayoutAnimation();\r\n                removeFromMotionTree === null || removeFromMotionTree === void 0 ? void 0 : removeFromMotionTree();\r\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\r\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\r\n                lifecycles.clearAllListeners();\r\n            },\r\n            /**\r\n             * Add a child visual element to our set of children.\r\n             */\r\n            addChild: function (child) {\r\n                children.add(child);\r\n                return function () { return children.delete(child); };\r\n            },\r\n            /**\r\n             * Add a child visual element to our set of children.\r\n             */\r\n            addVariantChild: function (child) {\r\n                var _a;\r\n                var closestVariantNode = element.getClosestVariantNode();\r\n                if (closestVariantNode) {\r\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\r\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\r\n                }\r\n            },\r\n            sortNodePosition: function (other) {\r\n                /**\r\n                 * If these nodes aren't even of the same type we can't compare their depth.\r\n                 */\r\n                if (!sortNodePosition || treeType !== other.treeType)\r\n                    return 0;\r\n                return sortNodePosition(element.getInstance(), other.getInstance());\r\n            }, \r\n            /**\r\n             * Returns the closest variant node in the tree starting from\r\n             * this visual element.\r\n             */\r\n            getClosestVariantNode: function () {\r\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\r\n            }, \r\n            /**\r\n             * A method that schedules an update to layout projections throughout\r\n             * the tree. We inherit from the parent so there's only ever one\r\n             * job scheduled on the next frame - that of the root visual element.\r\n             */\r\n            scheduleUpdateLayoutProjection: parent\r\n                ? parent.scheduleUpdateLayoutProjection\r\n                : function () { return sync.preRender(element.updateLayoutProjection, false, true); }, \r\n            /**\r\n             * Expose the latest layoutId prop.\r\n             */\r\n            getLayoutId: function () { return props.layoutId; }, \r\n            /**\r\n             * Returns the current instance.\r\n             */\r\n            getInstance: function () { return instance; }, \r\n            /**\r\n             * Get/set the latest static values.\r\n             */\r\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \r\n            /**\r\n             * Returns the latest motion value state. Currently only used to take\r\n             * a snapshot of the visual element - perhaps this can return the whole\r\n             * visual state\r\n             */\r\n            getLatestValues: function () { return latestValues; }, \r\n            /**\r\n             * Set the visiblity of the visual element. If it's changed, schedule\r\n             * a render to reflect these changes.\r\n             */\r\n            setVisibility: function (visibility) {\r\n                if (element.isVisible === visibility)\r\n                    return;\r\n                element.isVisible = visibility;\r\n                element.scheduleRender();\r\n            },\r\n            /**\r\n             * Make a target animatable by Popmotion. For instance, if we're\r\n             * trying to animate width from 100px to 100vw we need to measure 100vw\r\n             * in pixels to determine what we really need to animate to. This is also\r\n             * pluggable to support Framer's custom value types like Color,\r\n             * and CSS variables.\r\n             */\r\n            makeTargetAnimatable: function (target, canMutate) {\r\n                if (canMutate === void 0) { canMutate = true; }\r\n                return makeTargetAnimatable(element, target, props, canMutate);\r\n            },\r\n            /**\r\n             * Temporarily suspend hover events while we remove transforms in order to measure the layout.\r\n             *\r\n             * This seems like an odd bit of scheduling but what we're doing is saying after\r\n             * the next render, wait 10 milliseconds before reenabling hover events. Waiting until\r\n             * the next frame results in missed, valid hover events. But triggering on the postRender\r\n             * frame is too soon to avoid triggering events with layout measurements.\r\n             *\r\n             * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\r\n             */\r\n            suspendHoverEvents: function () {\r\n                element.isHoverEventsEnabled = false;\r\n                sync.postRender(function () {\r\n                    return setTimeout(function () { return (element.isHoverEventsEnabled = true); }, 10);\r\n                });\r\n            },\r\n            // Motion values ========================\r\n            /**\r\n             * Add a motion value and bind it to this visual element.\r\n             */\r\n            addValue: function (key, value) {\r\n                // Remove existing value if it exists\r\n                if (element.hasValue(key))\r\n                    element.removeValue(key);\r\n                values.set(key, value);\r\n                latestValues[key] = value.get();\r\n                bindToMotionValue(key, value);\r\n            },\r\n            /**\r\n             * Remove a motion value and unbind any active subscriptions.\r\n             */\r\n            removeValue: function (key) {\r\n                var _a;\r\n                values.delete(key);\r\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\r\n                valueSubscriptions.delete(key);\r\n                delete latestValues[key];\r\n                removeValueFromRenderState(key, renderState);\r\n            }, \r\n            /**\r\n             * Check whether we have a motion value for this key\r\n             */\r\n            hasValue: function (key) { return values.has(key); }, \r\n            /**\r\n             * Get a motion value for this key. If called with a default\r\n             * value, we'll create one if none exists.\r\n             */\r\n            getValue: function (key, defaultValue) {\r\n                var value = values.get(key);\r\n                if (value === undefined && defaultValue !== undefined) {\r\n                    value = motionValue(defaultValue);\r\n                    element.addValue(key, value);\r\n                }\r\n                return value;\r\n            }, \r\n            /**\r\n             * Iterate over our motion values.\r\n             */\r\n            forEachValue: function (callback) { return values.forEach(callback); }, \r\n            /**\r\n             * If we're trying to animate to a previously unencountered value,\r\n             * we need to check for it in our state and as a last resort read it\r\n             * directly from the instance (which might have performance implications).\r\n             */\r\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \r\n            /**\r\n             * Set the base target to later animate back to. This is currently\r\n             * only hydrated on creation and when we first read a value.\r\n             */\r\n            setBaseTarget: function (key, value) {\r\n                baseTarget[key] = value;\r\n            },\r\n            /**\r\n             * Find the base target for a value thats been removed from all animation\r\n             * props.\r\n             */\r\n            getBaseTarget: function (key) {\r\n                if (getBaseTarget) {\r\n                    var target = getBaseTarget(props, key);\r\n                    if (target !== undefined && !isMotionValue(target))\r\n                        return target;\r\n                }\r\n                return baseTarget[key];\r\n            } }, lifecycles), { \r\n            /**\r\n             * Build the renderer state based on the latest visual state.\r\n             */\r\n            build: function () {\r\n                triggerBuild();\r\n                return renderState;\r\n            },\r\n            /**\r\n             * Schedule a render on the next animation frame.\r\n             */\r\n            scheduleRender: function () {\r\n                sync.render(render, false, true);\r\n            }, \r\n            /**\r\n             * Synchronously fire render. It's prefered that we batch renders but\r\n             * in many circumstances, like layout measurement, we need to run this\r\n             * synchronously. However in those instances other measures should be taken\r\n             * to batch reads/writes.\r\n             */\r\n            syncRender: render, \r\n            /**\r\n             * Update the provided props. Ensure any newly-added motion values are\r\n             * added to our map, old ones removed, and listeners updated.\r\n             */\r\n            setProps: function (newProps) {\r\n                props = newProps;\r\n                lifecycles.updatePropListeners(newProps);\r\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\r\n            }, getProps: function () { return props; }, \r\n            // Variants ==============================\r\n            /**\r\n             * Returns the variant definition with a given name.\r\n             */\r\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \r\n            /**\r\n             * Returns the defined default transition on this component.\r\n             */\r\n            getDefaultTransition: function () { return props.transition; }, \r\n            /**\r\n             * Used by child variant nodes to get the closest ancestor variant props.\r\n             */\r\n            getVariantContext: function (startAtParent) {\r\n                if (startAtParent === void 0) { startAtParent = false; }\r\n                if (startAtParent)\r\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\r\n                if (!isControllingVariants) {\r\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\r\n                    if (props.initial !== undefined) {\r\n                        context_1.initial = props.initial;\r\n                    }\r\n                    return context_1;\r\n                }\r\n                var context = {};\r\n                for (var i = 0; i < numVariantProps; i++) {\r\n                    var name_1 = variantProps[i];\r\n                    var prop = props[name_1];\r\n                    if (isVariantLabel(prop) || prop === false) {\r\n                        context[name_1] = prop;\r\n                    }\r\n                }\r\n                return context;\r\n            },\r\n            // Layout projection ==============================\r\n            /**\r\n             * Enable layout projection for this visual element. Won't actually\r\n             * occur until we also have hydrated layout measurements.\r\n             */\r\n            enableLayoutProjection: function () {\r\n                projection.isEnabled = true;\r\n            },\r\n            /**\r\n             * Lock the projection target, for instance when dragging, so\r\n             * nothing else can try and animate it.\r\n             */\r\n            lockProjectionTarget: function () {\r\n                projection.isTargetLocked = true;\r\n            },\r\n            unlockProjectionTarget: function () {\r\n                element.stopLayoutAnimation();\r\n                projection.isTargetLocked = false;\r\n            },\r\n            /**\r\n             * Record the viewport box as it was before an expected mutation/re-render\r\n             */\r\n            snapshotViewportBox: function () {\r\n                // TODO: Store this snapshot in LayoutState\r\n                element.prevViewportBox = element.measureViewportBox(false);\r\n                /**\r\n                 * Update targetBox to match the prevViewportBox. This is just to ensure\r\n                 * that targetBox is affected by scroll in the same way as the measured box\r\n                 */\r\n                element.rebaseProjectionTarget(false, element.prevViewportBox);\r\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\r\n                crossfader = newCrossfader;\r\n            },\r\n            /**\r\n             * Start a layout animation on a given axis.\r\n             * TODO: This could be better.\r\n             */\r\n            startLayoutAnimation: function (axis, transition) {\r\n                var progress = element.getProjectionAnimationProgress()[axis];\r\n                var _a = projection.target[axis], min = _a.min, max = _a.max;\r\n                var length = max - min;\r\n                progress.clearListeners();\r\n                progress.set(min);\r\n                progress.set(min); // Set twice to hard-reset velocity\r\n                progress.onChange(function (v) {\r\n                    return element.setProjectionTargetAxis(axis, v, v + length);\r\n                });\r\n                return element.animateMotionValue(axis, progress, 0, transition);\r\n            },\r\n            /**\r\n             * Stop layout animations.\r\n             */\r\n            stopLayoutAnimation: function () {\r\n                eachAxis(function (axis) {\r\n                    return element.getProjectionAnimationProgress()[axis].stop();\r\n                });\r\n            },\r\n            /**\r\n             * Measure the current viewport box with or without transforms.\r\n             * Only measures axis-aligned boxes, rotate and skew must be manually\r\n             * removed with a re-render to work.\r\n             */\r\n            measureViewportBox: function (withTransform) {\r\n                if (withTransform === void 0) { withTransform = true; }\r\n                var viewportBox = measureViewportBox(instance, options);\r\n                if (!withTransform)\r\n                    removeBoxTransforms(viewportBox, latestValues);\r\n                return viewportBox;\r\n            },\r\n            /**\r\n             * Update the layoutState by measuring the DOM layout. This\r\n             * should be called after resetting any layout-affecting transforms.\r\n             */\r\n            updateLayoutMeasurement: function () {\r\n                element.notifyBeforeLayoutMeasure(layoutState.layout);\r\n                layoutState.isHydrated = true;\r\n                layoutState.layout = element.measureViewportBox();\r\n                layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\r\n                element.notifyLayoutMeasure(layoutState.layout, element.prevViewportBox || layoutState.layout);\r\n                sync.update(function () { return element.rebaseProjectionTarget(); });\r\n            },\r\n            /**\r\n             * Get the motion values tracking the layout animations on each\r\n             * axis. Lazy init if not already created.\r\n             */\r\n            getProjectionAnimationProgress: function () {\r\n                projectionTargetProgress || (projectionTargetProgress = {\r\n                    x: motionValue(0),\r\n                    y: motionValue(0),\r\n                });\r\n                return projectionTargetProgress;\r\n            },\r\n            /**\r\n             * Update the projection of a single axis. Schedule an update to\r\n             * the tree layout projection.\r\n             */\r\n            setProjectionTargetAxis: function (axis, min, max) {\r\n                var target = projection.target[axis];\r\n                target.min = min;\r\n                target.max = max;\r\n                // Flag that we want to fire the onViewportBoxUpdate event handler\r\n                hasViewportBoxUpdated = true;\r\n                lifecycles.notifySetAxisTarget();\r\n            },\r\n            /**\r\n             * Rebase the projection target on top of the provided viewport box\r\n             * or the measured layout. This ensures that non-animating elements\r\n             * don't fall out of sync differences in measurements vs projections\r\n             * after a page scroll or other relayout.\r\n             */\r\n            rebaseProjectionTarget: function (force, box) {\r\n                if (box === void 0) { box = layoutState.layout; }\r\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\r\n                var shouldRebase = !projection.isTargetLocked &&\r\n                    !x.isAnimating() &&\r\n                    !y.isAnimating();\r\n                if (force || shouldRebase) {\r\n                    eachAxis(function (axis) {\r\n                        var _a = box[axis], min = _a.min, max = _a.max;\r\n                        element.setProjectionTargetAxis(axis, min, max);\r\n                    });\r\n                }\r\n            },\r\n            /**\r\n             * Notify the visual element that its layout is up-to-date.\r\n             * Currently Animate.tsx uses this to check whether a layout animation\r\n             * needs to be performed.\r\n             */\r\n            notifyLayoutReady: function (config) {\r\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\r\n            }, \r\n            /**\r\n             * Temporarily reset the transform of the instance.\r\n             */\r\n            resetTransform: function () { return resetTransform(element, instance, props); }, \r\n            /**\r\n             * Perform the callback after temporarily unapplying the transform\r\n             * upwards through the tree.\r\n             */\r\n            withoutTransform: function (callback) {\r\n                var isEnabled = projection.isEnabled;\r\n                isEnabled && element.resetTransform();\r\n                parent ? parent.withoutTransform(callback) : callback();\r\n                isEnabled && restoreTransform(instance, renderState);\r\n            },\r\n            updateLayoutProjection: function () {\r\n                isProjecting() && updateLayoutProjection();\r\n                children.forEach(fireUpdateLayoutProjection);\r\n            },\r\n            /**\r\n             *\r\n             */\r\n            pointTo: function (newLead) {\r\n                leadProjection = newLead.projection;\r\n                leadLatestValues = newLead.getLatestValues();\r\n                /**\r\n                 * Subscribe to lead component's layout animations\r\n                 */\r\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\r\n                unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\r\n                    var _a;\r\n                    if (element.isPresent) {\r\n                        element.presence = Presence.Present;\r\n                    }\r\n                    else {\r\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\r\n                    }\r\n                }));\r\n            }, \r\n            // TODO: Clean this up\r\n            isPresent: true, presence: Presence.Entering });\r\n        return element;\r\n    };\r\n};\r\nfunction fireUpdateLayoutProjection(child) {\r\n    child.updateLayoutProjection();\r\n}\r\nvar variantProps = __spread([\"initial\"], variantPriorityOrder);\r\nvar numVariantProps = variantProps.length;\r\n\r\nexport { visualElement };\r\n"]},"metadata":{},"sourceType":"module"}