{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { ReparseError } from \"../errors\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport { waitForTick } from \"../../utils\";\n\nvar PDFObjectStreamParser =\n/** @class */\nfunction (_super) {\n  __extends(PDFObjectStreamParser, _super);\n\n  function PDFObjectStreamParser(rawStream, shouldWaitForTick) {\n    var _this = _super.call(this, ByteStream.fromPDFRawStream(rawStream), rawStream.dict.context) || this;\n\n    var dict = rawStream.dict;\n    _this.alreadyParsed = false;\n\n    _this.shouldWaitForTick = shouldWaitForTick || function () {\n      return false;\n    };\n\n    _this.firstOffset = dict.lookup(PDFName.of('First'), PDFNumber).asNumber();\n    _this.objectCount = dict.lookup(PDFName.of('N'), PDFNumber).asNumber();\n    return _this;\n  }\n\n  PDFObjectStreamParser.prototype.parseIntoContext = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var offsetsAndObjectNumbers, idx, len, _a, objectNumber, offset, object, ref;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFObjectStreamParser', 'parseIntoContext');\n            }\n\n            this.alreadyParsed = true;\n            offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();\n            idx = 0, len = offsetsAndObjectNumbers.length;\n            _b.label = 1;\n\n          case 1:\n            if (!(idx < len)) return [3\n            /*break*/\n            , 4];\n            _a = offsetsAndObjectNumbers[idx], objectNumber = _a.objectNumber, offset = _a.offset;\n            this.bytes.moveTo(this.firstOffset + offset);\n            object = this.parseObject();\n            ref = PDFRef.of(objectNumber, 0);\n            this.context.assign(ref, object);\n            if (!this.shouldWaitForTick()) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , waitForTick()];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            idx++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  PDFObjectStreamParser.prototype.parseOffsetsAndObjectNumbers = function () {\n    var offsetsAndObjectNumbers = [];\n\n    for (var idx = 0, len = this.objectCount; idx < len; idx++) {\n      this.skipWhitespaceAndComments();\n      var objectNumber = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var offset = this.parseRawInt();\n      offsetsAndObjectNumbers.push({\n        objectNumber: objectNumber,\n        offset: offset\n      });\n    }\n\n    return offsetsAndObjectNumbers;\n  };\n\n  PDFObjectStreamParser.forStream = function (rawStream, shouldWaitForTick) {\n    return new PDFObjectStreamParser(rawStream, shouldWaitForTick);\n  };\n\n  return PDFObjectStreamParser;\n}(PDFObjectParser);\n\nexport default PDFObjectStreamParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFObjectStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\nimport { ReparseError } from \"../errors\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport { waitForTick } from \"../../utils\";\nvar PDFObjectStreamParser = /** @class */ (function (_super) {\n    __extends(PDFObjectStreamParser, _super);\n    function PDFObjectStreamParser(rawStream, shouldWaitForTick) {\n        var _this = _super.call(this, ByteStream.fromPDFRawStream(rawStream), rawStream.dict.context) || this;\n        var dict = rawStream.dict;\n        _this.alreadyParsed = false;\n        _this.shouldWaitForTick = shouldWaitForTick || (function () { return false; });\n        _this.firstOffset = dict.lookup(PDFName.of('First'), PDFNumber).asNumber();\n        _this.objectCount = dict.lookup(PDFName.of('N'), PDFNumber).asNumber();\n        return _this;\n    }\n    PDFObjectStreamParser.prototype.parseIntoContext = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var offsetsAndObjectNumbers, idx, len, _a, objectNumber, offset, object, ref;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (this.alreadyParsed) {\n                            throw new ReparseError('PDFObjectStreamParser', 'parseIntoContext');\n                        }\n                        this.alreadyParsed = true;\n                        offsetsAndObjectNumbers = this.parseOffsetsAndObjectNumbers();\n                        idx = 0, len = offsetsAndObjectNumbers.length;\n                        _b.label = 1;\n                    case 1:\n                        if (!(idx < len)) return [3 /*break*/, 4];\n                        _a = offsetsAndObjectNumbers[idx], objectNumber = _a.objectNumber, offset = _a.offset;\n                        this.bytes.moveTo(this.firstOffset + offset);\n                        object = this.parseObject();\n                        ref = PDFRef.of(objectNumber, 0);\n                        this.context.assign(ref, object);\n                        if (!this.shouldWaitForTick()) return [3 /*break*/, 3];\n                        return [4 /*yield*/, waitForTick()];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        idx++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PDFObjectStreamParser.prototype.parseOffsetsAndObjectNumbers = function () {\n        var offsetsAndObjectNumbers = [];\n        for (var idx = 0, len = this.objectCount; idx < len; idx++) {\n            this.skipWhitespaceAndComments();\n            var objectNumber = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var offset = this.parseRawInt();\n            offsetsAndObjectNumbers.push({ objectNumber: objectNumber, offset: offset });\n        }\n        return offsetsAndObjectNumbers;\n    };\n    PDFObjectStreamParser.forStream = function (rawStream, shouldWaitForTick) { return new PDFObjectStreamParser(rawStream, shouldWaitForTick); };\n    return PDFObjectStreamParser;\n}(PDFObjectParser));\nexport default PDFObjectStreamParser;\n//# sourceMappingURL=PDFObjectStreamParser.js.map"]},"metadata":{},"sourceType":"module"}