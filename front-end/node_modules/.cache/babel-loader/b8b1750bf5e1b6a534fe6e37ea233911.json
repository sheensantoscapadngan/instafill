{"ast":null,"code":"import { useEffect } from 'react';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.js';\nimport { isAnimationControls } from '../../animation/animation-controls.js';\nimport { createAnimationState } from '../../render/utils/animation-state.js';\nvar AnimationState = makeRenderlessComponent(function (props) {\n  var visualElement = props.visualElement,\n      animate = props.animate;\n  /**\r\n   * We dynamically generate the AnimationState manager as it contains a reference\r\n   * to the underlying animation library. We only want to load that if we load this,\r\n   * so people can optionally code split it out using the `m` component.\r\n   */\n\n  visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n  /**\r\n   * Subscribe any provided AnimationControls to the component's VisualElement\r\n   */\n\n  if (isAnimationControls(animate)) {\n    useEffect(function () {\n      return animate.subscribe(visualElement);\n    }, [animate]);\n  }\n});\n/**\r\n * @public\r\n */\n\nvar Animation = {\n  key: \"animation\",\n  shouldRender: function () {\n    return true;\n  },\n  getComponent: function (_a) {\n    var animate = _a.animate,\n        whileHover = _a.whileHover,\n        whileFocus = _a.whileFocus,\n        whileTap = _a.whileTap,\n        whileDrag = _a.whileDrag,\n        exit = _a.exit,\n        variants = _a.variants;\n    return animate || whileHover || whileFocus || whileTap || whileDrag || exit || variants ? AnimationState : undefined;\n  }\n};\nexport { Animation };","map":{"version":3,"sources":["D:/programming stuff i dont save on oneDrive/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/motion/features/animation.js"],"names":["useEffect","makeRenderlessComponent","isAnimationControls","createAnimationState","AnimationState","props","visualElement","animate","animationState","subscribe","Animation","key","shouldRender","getComponent","_a","whileHover","whileFocus","whileTap","whileDrag","exit","variants","undefined"],"mappings":"AAAA,SAASA,SAAT,QAA0B,OAA1B;AACA,SAASC,uBAAT,QAAwC,uCAAxC;AACA,SAASC,mBAAT,QAAoC,uCAApC;AACA,SAASC,oBAAT,QAAqC,uCAArC;AAEA,IAAIC,cAAc,GAAGH,uBAAuB,CAAC,UAAUI,KAAV,EAAiB;AAC1D,MAAIC,aAAa,GAAGD,KAAK,CAACC,aAA1B;AAAA,MAAyCC,OAAO,GAAGF,KAAK,CAACE,OAAzD;AACA;AACJ;AACA;AACA;AACA;;AACID,EAAAA,aAAa,CAACE,cAAd,KAAiCF,aAAa,CAACE,cAAd,GAA+BL,oBAAoB,CAACG,aAAD,CAApF;AACA;AACJ;AACA;;AACI,MAAIJ,mBAAmB,CAACK,OAAD,CAAvB,EAAkC;AAC9BP,IAAAA,SAAS,CAAC,YAAY;AAAE,aAAOO,OAAO,CAACE,SAAR,CAAkBH,aAAlB,CAAP;AAA0C,KAAzD,EAA2D,CAACC,OAAD,CAA3D,CAAT;AACH;AACJ,CAd2C,CAA5C;AAeA;AACA;AACA;;AACA,IAAIG,SAAS,GAAG;AACZC,EAAAA,GAAG,EAAE,WADO;AAEZC,EAAAA,YAAY,EAAE,YAAY;AAAE,WAAO,IAAP;AAAc,GAF9B;AAGZC,EAAAA,YAAY,EAAE,UAAUC,EAAV,EAAc;AACxB,QAAIP,OAAO,GAAGO,EAAE,CAACP,OAAjB;AAAA,QAA0BQ,UAAU,GAAGD,EAAE,CAACC,UAA1C;AAAA,QAAsDC,UAAU,GAAGF,EAAE,CAACE,UAAtE;AAAA,QAAkFC,QAAQ,GAAGH,EAAE,CAACG,QAAhG;AAAA,QAA0GC,SAAS,GAAGJ,EAAE,CAACI,SAAzH;AAAA,QAAoIC,IAAI,GAAGL,EAAE,CAACK,IAA9I;AAAA,QAAoJC,QAAQ,GAAGN,EAAE,CAACM,QAAlK;AACA,WAAOb,OAAO,IACVQ,UADG,IAEHC,UAFG,IAGHC,QAHG,IAIHC,SAJG,IAKHC,IALG,IAMHC,QANG,GAODhB,cAPC,GAQDiB,SARN;AASH;AAdW,CAAhB;AAiBA,SAASX,SAAT","sourcesContent":["import { useEffect } from 'react';\r\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.js';\r\nimport { isAnimationControls } from '../../animation/animation-controls.js';\r\nimport { createAnimationState } from '../../render/utils/animation-state.js';\r\n\r\nvar AnimationState = makeRenderlessComponent(function (props) {\r\n    var visualElement = props.visualElement, animate = props.animate;\r\n    /**\r\n     * We dynamically generate the AnimationState manager as it contains a reference\r\n     * to the underlying animation library. We only want to load that if we load this,\r\n     * so people can optionally code split it out using the `m` component.\r\n     */\r\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\r\n    /**\r\n     * Subscribe any provided AnimationControls to the component's VisualElement\r\n     */\r\n    if (isAnimationControls(animate)) {\r\n        useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\r\n    }\r\n});\r\n/**\r\n * @public\r\n */\r\nvar Animation = {\r\n    key: \"animation\",\r\n    shouldRender: function () { return true; },\r\n    getComponent: function (_a) {\r\n        var animate = _a.animate, whileHover = _a.whileHover, whileFocus = _a.whileFocus, whileTap = _a.whileTap, whileDrag = _a.whileDrag, exit = _a.exit, variants = _a.variants;\r\n        return animate ||\r\n            whileHover ||\r\n            whileFocus ||\r\n            whileTap ||\r\n            whileDrag ||\r\n            exit ||\r\n            variants\r\n            ? AnimationState\r\n            : undefined;\r\n    },\r\n};\r\n\r\nexport { Animation };\r\n"]},"metadata":{},"sourceType":"module"}