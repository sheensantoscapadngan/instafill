{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\n\nvar PDFParser =\n/** @class */\nfunction (_super) {\n  __extends(PDFParser, _super);\n\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n\n    var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n\n  PDFParser.prototype.parseDocument = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFParser', 'parseDocument');\n            }\n\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n\n          case 1:\n            if (!!this.bytes.done()) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.parseDocumentSection()];\n\n          case 2:\n            _a.sent();\n\n            offset = this.bytes.offset();\n\n            if (offset === prevOffset) {\n              throw new StalledParserError(this.bytes.position());\n            }\n\n            prevOffset = offset;\n            return [3\n            /*break*/\n            , 1];\n\n          case 3:\n            this.maybeRecoverRoot();\n\n            if (this.context.lookup(PDFRef.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef.of(0));\n            }\n\n            return [2\n            /*return*/\n            , this.context];\n        }\n      });\n    });\n  };\n\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function (obj) {\n      return obj instanceof PDFDict && obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n    };\n\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n            ref = _a[0],\n            object = _a[1];\n\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n\n      this.bytes.next();\n    }\n\n    throw new MissingPDFHeaderError(this.bytes.position());\n  };\n\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n\n    return PDFRef.of(objectNumber, generationNumber);\n  };\n\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n\n  PDFParser.prototype.parseIndirectObject = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments(); // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n\n            this.matchKeyword(Keywords.endobj);\n            if (!(object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            if (object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n              PDFXRefStreamParser.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , ref];\n        }\n      });\n    });\n  }; // TODO: Improve and clean this up\n\n\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n\n      if (!failed) break;\n      this.bytes.next();\n    }\n\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords.endobj.length;\n    var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n\n          case 1:\n            if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3\n            /*break*/\n            , 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.parseIndirectObject()];\n\n          case 3:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_1 = _a.sent(); // TODO: Add tracing/logging mechanism to track when this happens!\n\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            this.skipWhitespaceAndComments(); // TODO: Can this be done only when needed, to avoid harming performance?\n\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , waitForTick()];\n\n          case 6:\n            _a.sent();\n\n            _a.label = 7;\n\n          case 7:\n            return [3\n            /*break*/\n            , 1];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection.createEmpty();\n\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        var ref = PDFRef.of(objectNumber, secondInt);\n\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n\n      this.skipWhitespaceAndComments();\n    }\n\n    return xref;\n  };\n\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID\n    };\n  };\n\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  };\n\n  PDFParser.prototype.parseDocumentSection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parseIndirectObjects()];\n\n          case 1:\n            _a.sent();\n\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer(); // TODO: Can this be done only when needed, to avoid harming performance?\n\n            this.skipJibberish();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n\n\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n\n      this.bytes.next();\n    }\n  };\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n\n\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n\n  return PDFParser;\n}(PDFObjectParser);\n\nexport default PDFParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError, } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */ (function (_super) {\n    __extends(PDFParser, _super);\n    function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n        if (objectsPerTick === void 0) { objectsPerTick = Infinity; }\n        if (throwOnInvalidObject === void 0) { throwOnInvalidObject = false; }\n        if (capNumbers === void 0) { capNumbers = false; }\n        var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n        _this.alreadyParsed = false;\n        _this.parsedObjects = 0;\n        _this.shouldWaitForTick = function () {\n            _this.parsedObjects += 1;\n            return _this.parsedObjects % _this.objectsPerTick === 0;\n        };\n        _this.objectsPerTick = objectsPerTick;\n        _this.throwOnInvalidObject = throwOnInvalidObject;\n        return _this;\n    }\n    PDFParser.prototype.parseDocument = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var prevOffset, offset;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.alreadyParsed) {\n                            throw new ReparseError('PDFParser', 'parseDocument');\n                        }\n                        this.alreadyParsed = true;\n                        this.context.header = this.parseHeader();\n                        _a.label = 1;\n                    case 1:\n                        if (!!this.bytes.done()) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.parseDocumentSection()];\n                    case 2:\n                        _a.sent();\n                        offset = this.bytes.offset();\n                        if (offset === prevOffset) {\n                            throw new StalledParserError(this.bytes.position());\n                        }\n                        prevOffset = offset;\n                        return [3 /*break*/, 1];\n                    case 3:\n                        this.maybeRecoverRoot();\n                        if (this.context.lookup(PDFRef.of(0))) {\n                            console.warn('Removing parsed object: 0 0 R');\n                            this.context.delete(PDFRef.of(0));\n                        }\n                        return [2 /*return*/, this.context];\n                }\n            });\n        });\n    };\n    PDFParser.prototype.maybeRecoverRoot = function () {\n        var isValidCatalog = function (obj) {\n            return obj instanceof PDFDict &&\n                obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n        };\n        var catalog = this.context.lookup(this.context.trailerInfo.Root);\n        if (!isValidCatalog(catalog)) {\n            var indirectObjects = this.context.enumerateIndirectObjects();\n            for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n                var _a = indirectObjects[idx], ref = _a[0], object = _a[1];\n                if (isValidCatalog(object)) {\n                    this.context.trailerInfo.Root = ref;\n                }\n            }\n        }\n    };\n    PDFParser.prototype.parseHeader = function () {\n        while (!this.bytes.done()) {\n            if (this.matchKeyword(Keywords.header)) {\n                var major = this.parseRawInt();\n                this.bytes.assertNext(CharCodes.Period);\n                var minor = this.parseRawInt();\n                var header = PDFHeader.forVersion(major, minor);\n                this.skipBinaryHeaderComment();\n                return header;\n            }\n            this.bytes.next();\n        }\n        throw new MissingPDFHeaderError(this.bytes.position());\n    };\n    PDFParser.prototype.parseIndirectObjectHeader = function () {\n        this.skipWhitespaceAndComments();\n        var objectNumber = this.parseRawInt();\n        this.skipWhitespaceAndComments();\n        var generationNumber = this.parseRawInt();\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.obj)) {\n            throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n        }\n        return PDFRef.of(objectNumber, generationNumber);\n    };\n    PDFParser.prototype.matchIndirectObjectHeader = function () {\n        var initialOffset = this.bytes.offset();\n        try {\n            this.parseIndirectObjectHeader();\n            return true;\n        }\n        catch (e) {\n            this.bytes.moveTo(initialOffset);\n            return false;\n        }\n    };\n    PDFParser.prototype.parseIndirectObject = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var ref, object;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ref = this.parseIndirectObjectHeader();\n                        this.skipWhitespaceAndComments();\n                        object = this.parseObject();\n                        this.skipWhitespaceAndComments();\n                        // if (!this.matchKeyword(Keywords.endobj)) {\n                        // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n                        // }\n                        // TODO: Log a warning if this fails...\n                        this.matchKeyword(Keywords.endobj);\n                        if (!(object instanceof PDFRawStream &&\n                            object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (object instanceof PDFRawStream &&\n                            object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n                            PDFXRefStreamParser.forStream(object).parseIntoContext();\n                        }\n                        else {\n                            this.context.assign(ref, object);\n                        }\n                        _a.label = 3;\n                    case 3: return [2 /*return*/, ref];\n                }\n            });\n        });\n    };\n    // TODO: Improve and clean this up\n    PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n        var startPos = this.bytes.position();\n        var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n        if (this.throwOnInvalidObject)\n            throw new Error(msg);\n        console.warn(msg);\n        var ref = this.parseIndirectObjectHeader();\n        console.warn(\"Invalid object ref: \" + ref);\n        this.skipWhitespaceAndComments();\n        var start = this.bytes.offset();\n        var failed = true;\n        while (!this.bytes.done()) {\n            if (this.matchKeyword(Keywords.endobj)) {\n                failed = false;\n            }\n            if (!failed)\n                break;\n            this.bytes.next();\n        }\n        if (failed)\n            throw new PDFInvalidObjectParsingError(startPos);\n        var end = this.bytes.offset() - Keywords.endobj.length;\n        var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n        this.context.assign(ref, object);\n        return ref;\n    };\n    PDFParser.prototype.parseIndirectObjects = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialOffset, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.skipWhitespaceAndComments();\n                        _a.label = 1;\n                    case 1:\n                        if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n                        initialOffset = this.bytes.offset();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.parseIndirectObject()];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _a.sent();\n                        // TODO: Add tracing/logging mechanism to track when this happens!\n                        this.bytes.moveTo(initialOffset);\n                        this.tryToParseInvalidIndirectObject();\n                        return [3 /*break*/, 5];\n                    case 5:\n                        this.skipWhitespaceAndComments();\n                        // TODO: Can this be done only when needed, to avoid harming performance?\n                        this.skipJibberish();\n                        if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n                        return [4 /*yield*/, waitForTick()];\n                    case 6:\n                        _a.sent();\n                        _a.label = 7;\n                    case 7: return [3 /*break*/, 1];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PDFParser.prototype.maybeParseCrossRefSection = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.xref))\n            return;\n        this.skipWhitespaceAndComments();\n        var objectNumber = -1;\n        var xref = PDFCrossRefSection.createEmpty();\n        while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n            var firstInt = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var secondInt = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var byte = this.bytes.peek();\n            if (byte === CharCodes.n || byte === CharCodes.f) {\n                var ref = PDFRef.of(objectNumber, secondInt);\n                if (this.bytes.next() === CharCodes.n) {\n                    xref.addEntry(ref, firstInt);\n                }\n                else {\n                    // this.context.delete(ref);\n                    xref.addDeletedEntry(ref, firstInt);\n                }\n                objectNumber += 1;\n            }\n            else {\n                objectNumber = firstInt;\n            }\n            this.skipWhitespaceAndComments();\n        }\n        return xref;\n    };\n    PDFParser.prototype.maybeParseTrailerDict = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.trailer))\n            return;\n        this.skipWhitespaceAndComments();\n        var dict = this.parseDict();\n        var context = this.context;\n        context.trailerInfo = {\n            Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n            Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n            Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n            ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID,\n        };\n    };\n    PDFParser.prototype.maybeParseTrailer = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.startxref))\n            return;\n        this.skipWhitespaceAndComments();\n        var offset = this.parseRawInt();\n        this.skipWhitespace();\n        this.matchKeyword(Keywords.eof);\n        this.skipWhitespaceAndComments();\n        this.matchKeyword(Keywords.eof);\n        this.skipWhitespaceAndComments();\n        return PDFTrailer.forLastCrossRefSectionOffset(offset);\n    };\n    PDFParser.prototype.parseDocumentSection = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.parseIndirectObjects()];\n                    case 1:\n                        _a.sent();\n                        this.maybeParseCrossRefSection();\n                        this.maybeParseTrailerDict();\n                        this.maybeParseTrailer();\n                        // TODO: Can this be done only when needed, to avoid harming performance?\n                        this.skipJibberish();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This operation is not necessary for valid PDF files. But some invalid PDFs\n     * contain jibberish in between indirect objects. This method is designed to\n     * skip past that jibberish, should it exist, until it reaches the next\n     * indirect object header, an xref table section, or the file trailer.\n     */\n    PDFParser.prototype.skipJibberish = function () {\n        this.skipWhitespaceAndComments();\n        while (!this.bytes.done()) {\n            var initialOffset = this.bytes.offset();\n            var byte = this.bytes.peek();\n            var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n            if (isAlphaNumeric) {\n                if (this.matchKeyword(Keywords.xref) ||\n                    this.matchKeyword(Keywords.trailer) ||\n                    this.matchKeyword(Keywords.startxref) ||\n                    this.matchIndirectObjectHeader()) {\n                    this.bytes.moveTo(initialOffset);\n                    break;\n                }\n            }\n            this.bytes.next();\n        }\n    };\n    /**\n     * Skips the binary comment following a PDF header. The specification\n     * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n     * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n     *\n     * This would imply that to strip out this binary comment, we could check for\n     * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n     * are 128 or greater. This works for many documents that properly comply with\n     * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n     * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n     * these headers correctly, we just throw out all bytes leading up to the\n     * first indirect object header.\n     */\n    PDFParser.prototype.skipBinaryHeaderComment = function () {\n        this.skipWhitespaceAndComments();\n        try {\n            var initialOffset = this.bytes.offset();\n            this.parseIndirectObjectHeader();\n            this.bytes.moveTo(initialOffset);\n        }\n        catch (e) {\n            this.bytes.next();\n            this.skipWhitespaceAndComments();\n        }\n    };\n    PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n        return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n    };\n    return PDFParser;\n}(PDFObjectParser));\nexport default PDFParser;\n//# sourceMappingURL=PDFParser.js.map"]},"metadata":{},"sourceType":"module"}