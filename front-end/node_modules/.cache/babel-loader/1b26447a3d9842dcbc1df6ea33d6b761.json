{"ast":null,"code":"import { forwardRef, useContext, createElement, Fragment } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { useFeatures } from './features/use-features.js';\nimport { MotionContext } from '../context/MotionContext/index.js';\nimport { useVisualElement } from './utils/use-visual-element.js';\nimport { useMotionRef } from './utils/use-motion-ref.js';\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\nfunction createMotionComponent(_a) {\n  var defaultFeatures = _a.defaultFeatures,\n      createVisualElement = _a.createVisualElement,\n      useRender = _a.useRender,\n      useVisualState = _a.useVisualState;\n\n  function MotionComponent(props, externalRef) {\n    /**\n     * If we're rendering in a static environment, we only visually update the component\n     * as a result of a React-rerender rather than interactions or animations. This\n     * means we don't need to load additional memory structures like VisualElement,\n     * or any gesture/animation features.\n     */\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\n     * Create the tree context. This is memoized and will only trigger renders\n     * when the current tree variant changes in static mode.\n     */\n\n    var context = useCreateMotionContext(props, isStatic);\n    /**\n     *\n     */\n\n    var visualState = useVisualState(props, isStatic);\n\n    if (!isStatic && typeof window !== \"undefined\") {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(isStatic, visualState, createVisualElement, props);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       *\n       * TODO: The intention is to move these away from a React-centric to a\n       * VisualElement-centric lifecycle scheme.\n       */\n\n      features = useFeatures(defaultFeatures, context.visualElement, props);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n\n\n    return createElement(Fragment, null, createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n\n  return forwardRef(MotionComponent);\n}\n\nexport { createMotionComponent };","map":{"version":3,"sources":["F:/github_repos/instafill/front-end/node_modules/framer-motion/dist/es/motion/index.js"],"names":["forwardRef","useContext","createElement","Fragment","MotionConfigContext","useFeatures","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","createMotionComponent","_a","defaultFeatures","createVisualElement","useRender","useVisualState","MotionComponent","props","externalRef","isStatic","features","context","visualState","window","visualElement","Provider","value"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,UAArB,EAAiCC,aAAjC,EAAgDC,QAAhD,QAAgE,OAAhE;AACA,SAASC,mBAAT,QAAoC,mCAApC;AACA,SAASC,WAAT,QAA4B,4BAA5B;AACA,SAASC,aAAT,QAA8B,mCAA9B;AACA,SAASC,gBAAT,QAAiC,+BAAjC;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,sBAAT,QAAuC,oCAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,qBAAT,CAA+BC,EAA/B,EAAmC;AAC/B,MAAIC,eAAe,GAAGD,EAAE,CAACC,eAAzB;AAAA,MAA0CC,mBAAmB,GAAGF,EAAE,CAACE,mBAAnE;AAAA,MAAwFC,SAAS,GAAGH,EAAE,CAACG,SAAvG;AAAA,MAAkHC,cAAc,GAAGJ,EAAE,CAACI,cAAtI;;AACA,WAASC,eAAT,CAAyBC,KAAzB,EAAgCC,WAAhC,EAA6C;AACzC;AACR;AACA;AACA;AACA;AACA;AACQ,QAAIC,QAAQ,GAAGlB,UAAU,CAACG,mBAAD,CAAV,CAAgCe,QAA/C;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA;AACR;AACA;AACA;;AACQ,QAAIC,OAAO,GAAGZ,sBAAsB,CAACQ,KAAD,EAAQE,QAAR,CAApC;AACA;AACR;AACA;;AACQ,QAAIG,WAAW,GAAGP,cAAc,CAACE,KAAD,EAAQE,QAAR,CAAhC;;AACA,QAAI,CAACA,QAAD,IAAa,OAAOI,MAAP,KAAkB,WAAnC,EAAgD;AAC5C;AACZ;AACA;AACA;AACA;AACA;AACYF,MAAAA,OAAO,CAACG,aAAR,GAAwBjB,gBAAgB,CAACY,QAAD,EAAWG,WAAX,EAAwBT,mBAAxB,EAA6CI,KAA7C,CAAxC;AACA;AACZ;AACA;AACA;AACA;AACA;AACA;;AACYG,MAAAA,QAAQ,GAAGf,WAAW,CAACO,eAAD,EAAkBS,OAAO,CAACG,aAA1B,EAAyCP,KAAzC,CAAtB;AACH;AACD;AACR;AACA;AACA;;;AACQ,WAAQf,aAAa,CAACC,QAAD,EAAW,IAAX,EACjBD,aAAa,CAACI,aAAa,CAACmB,QAAf,EAAyB;AAAEC,MAAAA,KAAK,EAAEL;AAAT,KAAzB,EAA6CP,SAAS,CAACG,KAAD,EAAQT,YAAY,CAACc,WAAD,EAAcD,OAAO,CAACG,aAAtB,EAAqCN,WAArC,CAApB,EAAuEI,WAAvE,EAAoFH,QAApF,CAAtD,CADI,EAEjBC,QAFiB,CAArB;AAGH;;AACD,SAAOpB,UAAU,CAACgB,eAAD,CAAjB;AACH;;AAED,SAASN,qBAAT","sourcesContent":["import { forwardRef, useContext, createElement, Fragment } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.js';\nimport { useFeatures } from './features/use-features.js';\nimport { MotionContext } from '../context/MotionContext/index.js';\nimport { useVisualElement } from './utils/use-visual-element.js';\nimport { useMotionRef } from './utils/use-motion-ref.js';\nimport { useCreateMotionContext } from '../context/MotionContext/create.js';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var defaultFeatures = _a.defaultFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState;\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var isStatic = useContext(MotionConfigContext).isStatic;\n        var features = null;\n        /**\n         * Create the tree context. This is memoized and will only trigger renders\n         * when the current tree variant changes in static mode.\n         */\n        var context = useCreateMotionContext(props, isStatic);\n        /**\n         *\n         */\n        var visualState = useVisualState(props, isStatic);\n        if (!isStatic && typeof window !== \"undefined\") {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(isStatic, visualState, createVisualElement, props);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             *\n             * TODO: The intention is to move these away from a React-centric to a\n             * VisualElement-centric lifecycle scheme.\n             */\n            features = useFeatures(defaultFeatures, context.visualElement, props);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (createElement(Fragment, null,\n            createElement(MotionContext.Provider, { value: context }, useRender(props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\n            features));\n    }\n    return forwardRef(MotionComponent);\n}\n\nexport { createMotionComponent };\n"]},"metadata":{},"sourceType":"module"}