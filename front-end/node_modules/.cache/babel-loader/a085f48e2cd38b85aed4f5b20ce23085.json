{"ast":null,"code":"import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\n\nvar computeFontSize = function (lines, font, bounds) {\n  var fontSize = MIN_FONT_SIZE;\n\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = lines.length; idx < len; idx++) {\n      var line = lines[idx];\n      var tooLong = font.widthOfTextAtSize(line, fontSize) > bounds.width;\n      if (tooLong) return fontSize - 1;\n    }\n\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lines.length * lineHeight;\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = charSplit(line);\n\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nvar lastIndexOfWhitespace = function (line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n\n  return undefined;\n};\n\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n  var _a;\n\n  var lastWhitespaceIdx = input.length;\n\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  } // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n\n\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\n\nexport var layoutMultilineText = function (text, _a) {\n  var alignment = _a.alignment,\n      fontSize = _a.fontSize,\n      font = _a.font,\n      bounds = _a.bounds;\n  var lines = lineSplit(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    // fontSize = computeFontSize(lines, font, bounds);\n    // This is hardcoded to make it easier to perform automatic line-wrapping.\n    //\n    // TODO: Update `computeFontSize` to support automatic line-wrapping and\n    //       automatic font size calculation.\n    fontSize = 12;\n  }\n\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n          line = _b.line,\n          encoded = _b.encoded,\n          width = _b.width,\n          remainder = _b.remainder; // prettier-ignore\n\n\n      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      }); // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutCombedText = function (text, _a) {\n  var fontSize = _a.fontSize,\n      font = _a.font,\n      bounds = _a.bounds,\n      cellCount = _a.cellCount;\n  var line = mergeLines(cleanText(text));\n\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n\n  while (cellOffset < cellCount) {\n    var _b = charAtIndex(line, charOffset),\n        char = _b[0],\n        charLength = _b[1];\n\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutSinglelineText = function (text, _a) {\n  var alignment = _a.alignment,\n      fontSize = _a.fontSize,\n      font = _a.font,\n      bounds = _a.bounds;\n  var line = mergeLines(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  }); // prettier-ignore\n\n  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};","map":{"version":3,"sources":["../../../src/api/text/layout.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit, } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds) {\n    var fontSize = MIN_FONT_SIZE;\n    while (fontSize < MAX_FONT_SIZE) {\n        for (var idx = 0, len = lines.length; idx < len; idx++) {\n            var line = lines[idx];\n            var tooLong = font.widthOfTextAtSize(line, fontSize) > bounds.width;\n            if (tooLong)\n                return fontSize - 1;\n        }\n        var height = font.heightAtSize(fontSize);\n        var lineHeight = height + height * 0.2;\n        var totalHeight = lines.length * lineHeight;\n        if (totalHeight > Math.abs(bounds.height))\n            return fontSize - 1;\n        fontSize += 1;\n    }\n    return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n    var cellWidth = bounds.width / cellCount;\n    var cellHeight = bounds.height;\n    var fontSize = MIN_FONT_SIZE;\n    var chars = charSplit(line);\n    while (fontSize < MAX_FONT_SIZE) {\n        for (var idx = 0, len = chars.length; idx < len; idx++) {\n            var c = chars[idx];\n            var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n            if (tooLong)\n                return fontSize - 1;\n        }\n        var height = font.heightAtSize(fontSize, { descender: false });\n        if (height > cellHeight)\n            return fontSize - 1;\n        fontSize += 1;\n    }\n    return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n    for (var idx = line.length; idx > 0; idx--) {\n        if (/\\s/.test(line[idx]))\n            return idx;\n    }\n    return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n    var _a;\n    var lastWhitespaceIdx = input.length;\n    while (lastWhitespaceIdx > 0) {\n        var line = input.substring(0, lastWhitespaceIdx);\n        var encoded = font.encodeText(line);\n        var width = font.widthOfTextAtSize(line, fontSize);\n        if (width < maxWidth) {\n            var remainder = input.substring(lastWhitespaceIdx) || undefined;\n            return { line: line, encoded: encoded, width: width, remainder: remainder };\n        }\n        lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n    }\n    // We were unable to split the input enough to get a chunk that would fit\n    // within the specified `maxWidth` so we'll just return everything\n    return {\n        line: input,\n        encoded: font.encodeText(input),\n        width: font.widthOfTextAtSize(input, fontSize),\n        remainder: undefined,\n    };\n};\nexport var layoutMultilineText = function (text, _a) {\n    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;\n    var lines = lineSplit(cleanText(text));\n    if (fontSize === undefined || fontSize === 0) {\n        // fontSize = computeFontSize(lines, font, bounds);\n        // This is hardcoded to make it easier to perform automatic line-wrapping.\n        //\n        // TODO: Update `computeFontSize` to support automatic line-wrapping and\n        //       automatic font size calculation.\n        fontSize = 12;\n    }\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var textLines = [];\n    var minX = bounds.x;\n    var minY = bounds.y;\n    var maxX = bounds.x + bounds.width;\n    var maxY = bounds.y + bounds.height;\n    var y = bounds.y + bounds.height;\n    for (var idx = 0, len = lines.length; idx < len; idx++) {\n        var prevRemainder = lines[idx];\n        while (prevRemainder !== undefined) {\n            var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;\n            // prettier-ignore\n            var x = (alignment === TextAlignment.Left ? bounds.x\n                : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n                    : alignment === TextAlignment.Right ? bounds.x + bounds.width - width\n                        : bounds.x);\n            y -= lineHeight;\n            if (x < minX)\n                minX = x;\n            if (y < minY)\n                minY = y;\n            if (x + width > maxX)\n                maxX = x + width;\n            if (y + height > maxY)\n                maxY = y + height;\n            textLines.push({ text: line, encoded: encoded, width: width, height: height, x: x, y: y });\n            // Only trim lines that we had to split ourselves. So we won't trim lines\n            // that the user provided themselves with whitespace.\n            prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n        }\n    }\n    return {\n        fontSize: fontSize,\n        lineHeight: lineHeight,\n        lines: textLines,\n        bounds: {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        },\n    };\n};\nexport var layoutCombedText = function (text, _a) {\n    var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;\n    var line = mergeLines(cleanText(text));\n    if (line.length > cellCount) {\n        throw new CombedTextLayoutError(line.length, cellCount);\n    }\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n    }\n    var cellWidth = bounds.width / cellCount;\n    var height = font.heightAtSize(fontSize, { descender: false });\n    var y = bounds.y + (bounds.height / 2 - height / 2);\n    var cells = [];\n    var minX = bounds.x;\n    var minY = bounds.y;\n    var maxX = bounds.x + bounds.width;\n    var maxY = bounds.y + bounds.height;\n    var cellOffset = 0;\n    var charOffset = 0;\n    while (cellOffset < cellCount) {\n        var _b = charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];\n        var encoded = font.encodeText(char);\n        var width = font.widthOfTextAtSize(char, fontSize);\n        var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n        var x = cellCenter - width / 2;\n        if (x < minX)\n            minX = x;\n        if (y < minY)\n            minY = y;\n        if (x + width > maxX)\n            maxX = x + width;\n        if (y + height > maxY)\n            maxY = y + height;\n        cells.push({ text: line, encoded: encoded, width: width, height: height, x: x, y: y });\n        cellOffset += 1;\n        charOffset += charLength;\n    }\n    return {\n        fontSize: fontSize,\n        cells: cells,\n        bounds: {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        },\n    };\n};\nexport var layoutSinglelineText = function (text, _a) {\n    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;\n    var line = mergeLines(cleanText(text));\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeFontSize([line], font, bounds);\n    }\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    var height = font.heightAtSize(fontSize, { descender: false });\n    // prettier-ignore\n    var x = (alignment === TextAlignment.Left ? bounds.x\n        : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n            : alignment === TextAlignment.Right ? bounds.x + bounds.width - width\n                : bounds.x);\n    var y = bounds.y + (bounds.height / 2 - height / 2);\n    return {\n        fontSize: fontSize,\n        line: { text: line, encoded: encoded, width: width, height: height, x: x, y: y },\n        bounds: { x: x, y: y, width: width, height: height },\n    };\n};\n//# sourceMappingURL=layout.js.map"]},"metadata":{},"sourceType":"module"}